
const vsnative = require("../bin/addon-" + process.platform + ".node");
import { Membuf, BaseMembuf, isMembuf, getMembufScratchBuffer } from "./membuf";
export { Membuf, BaseMembuf, isMembuf, getMembufScratchBuffer } from "./membuf";
import { initArray } from "./initArray";
export { initArray } from "./initArray";

export class char extends BaseMembuf {
  public constructor(value = 0) {
    super(1);
    this.view.setInt8(0, value);
  }

  public toNumber = (): number => this.view.getInt8(0);
}

export class uchar extends BaseMembuf {
  public constructor(value = 0) {
    super(1);
    this.view.setUint8(0, value);
  }

  public toNumber = (): number => this.view.getInt8(0);
}

export class int8_t extends BaseMembuf {
  public constructor(value = 0) {
    super(1);
    this.view.setInt8(0, value);
  }

  public toNumber = (): number => this.view.getInt8(0);
}

export class int16_t extends BaseMembuf {
  public constructor(value = 0) {
    super(2);
    this.view.setInt16(0, value, true);
  }

  public toNumber = (): number => this.view.getInt16(0, true);
}

export class int32_t extends BaseMembuf {
  public constructor(value = 0) {
    super(4);
    this.view.setInt32(0, value, true);
  }

  public toNumber = (): number => this.view.getInt32(0, true);
}

export class int64_t extends BaseMembuf {
  public constructor(value = 0) {
    super(8);
    this.view.setBigInt64(0, BigInt(value), true);
  }


  public toBigInt = (): bigint => this.view.getBigInt64(0, true);
}

export class uint8_t extends BaseMembuf {
  public constructor(value = 0) {
    super(1);
    this.view.setUint8(0, value);
  }

  public toNumber = (): number => this.view.getUint8(0);
}

export class uint16_t extends BaseMembuf {
  public constructor(value = 0) {
    super(2);
    this.view.setUint16(0, value, true);
  }

  public toNumber = (): number => this.view.getUint16(0, true);
}

export class uint32_t extends BaseMembuf {
  public constructor(value = 0) {
    super(4);
    this.view.setUint32(0, value, true);
  }

  public toNumber = (): number => this.view.getUint32(0, true);
}

export class uint64_t extends BaseMembuf {
  public constructor(value = 0) {
    super(8);
    this.view.setBigInt64(0, BigInt(value), true);
  }

  public toBigInt = (): bigint => this.view.getBigInt64(0, true);
}

export class ptr64_t extends BaseMembuf {
    public constructor(value = 0) {
        super(8);
        this.view.setBigInt64(0, BigInt(value), true);
    }

    public toBigInt = (): bigint => this.view.getBigInt64(0, true);
}

export class float extends BaseMembuf {
  public constructor(value = 0) {
    super(4);
    this.view.setFloat32(0, value, true);
  }

  public toNumber = (): number => this.view.getFloat32(0, true);
}

export class double extends BaseMembuf {
  public constructor(value = 0) {
    super(8);
    this.view.setFloat64(0, value, true);
  }

  public toNumber = (): number => this.view.getFloat64(0, true);
}

export class size_t extends BaseMembuf {
  public constructor(value = 0) {
    super(8);
    this.view.setBigUint64(0, BigInt(value), true);
  }

  public toBigInt = (): bigint => this.view.getBigUint64(0, true);
}

export class nullptr_t extends BaseMembuf {
  public constructor() {
    super(8);
  }
}


export type VkClearColorValue = float[];
export type VkClearValue = VkClearColorValue | VkClearDepthStencilValue;
export type VkClearValueDeserialized = VkClearValue

export interface ResizeEvent {
  width: number;
  height: number;
}
export interface FocusEvent {
  focused: boolean;
}
export interface CloseEvent {

}
export interface KeydownEvent {
  keyCode: number;
}
export interface KeyupEvent {
  keyCode: number;
}
export interface MousemoveEvent {
  x: number;
  y: number;
  movementX: number;
  movementY: number;
}
export interface MousewheelEvent {
  x: number;
  y: number;
  deltaX: number;
  deltaY: number;
}
export interface MousedownEvent {
  x: number;
  y: number;
  button: number;
}
export interface MouseupEvent {
  x: number;
  y: number;
  button: number;
}
export interface DropEvent {
  paths: string[];
}

export interface VulkanWindow {
  title: string;
  width: number;
  height: number;
  frameBufferWidth: number;
  frameBufferHeight: number;
  devicePixelRatio: number;
  pollEvents(): void;
  focus(): void;
  close(): void;
  enterPointerLock(): void;
  exitPointerLock(): void;
  shouldClose(): boolean;
  createSurface(instance: number | null, surface: number | null): number;
  getRequiredInstanceExtensions(): string[];
  onresize: ((ev: ResizeEvent) => any) | null;
  onfocus: ((ev: FocusEvent) => any) | null;
  onclose: ((ev: CloseEvent) => any) | null;
  onkeydown: ((ev: KeydownEvent) => any) | null;
  onkeyup: ((ev: KeyupEvent) => any) | null;
  onmousemove: ((ev: MousemoveEvent) => any) | null;
  onmousewheel: ((ev: MousewheelEvent) => any) | null;
  onmousedown: ((ev: MousedownEvent) => any) | null;
  onmouseup: ((ev: MouseupEvent) => any) | null;
  ondrop: ((ev: DropEvent) => any) | null;
}

export interface VulkanWindowInitializer {
  width: number;
  height: number;
  title?: string;
  resizable?: boolean;
}

export const createWindow = (options: VulkanWindowInitializer): VulkanWindow => new vsnative.VulkanWindow(options);
export const getMemoryAlignment = (): ArrayBuffer => vsnative.getMemoryAlignment();
 export const allocateString = (str: string): bigint => vsnative.allocateString(str);
 export const allocateStrings = (strs: string[]): bigint => vsnative.allocateStrings(strs);
export const sTypes = vsnative.sTypes;
// export const getAddressFromArrayBuffer = (a: ArrayBuffer): ArrayBuffer => vsnative.getAddressFromArrayBuffer(a);
// export const getArrayBufferFromAddress = (address: ArrayBuffer, size: number): ArrayBuffer => vsnative.getArrayBufferFromAddress(address, size);
// export const allocate = (size: number): ArrayBuffer => vsnative.allocate(size);
// export const free = (buffer: ArrayBuffer): void => vsnative.free(buffer);
export const getScratchBuffer = (): ArrayBuffer => vsnative.getScratchBuffer();
export const getAddressAtScratchBufferOffset = (offset: number): bigint => vsnative.getAddressAtScratchBufferOffset(offset);
export const memsetScratchBufferSlice = (offset: number, srcStart: number, size: number, data: ArrayBuffer): void => vsnative.memsetScratchBufferSlice(offset, srcStart, size, data);
export const memsetScratchBufferMove = (from: number, to: number, size: number): void => vsnative.memsetScratchBufferMove(from, to, size);
export const memsetScratchBufferZero = (offset: number, size: number): void => vsnative.memsetScratchBufferZero(offset, size);
export const memcpyArrayBuffers = (src: ArrayBuffer, srcStart: number, dst: ArrayBuffer, dstStart: number, size: number): void => vsnative.memcpyArrayBuffers(src, srcStart, dst, dstStart, size);

export const VK_MAKE_VERSION = (major: number, minor: number, patch: number): number => vsnative.VK_MAKE_VERSION(major, minor, patch);
export const VK_VERSION_MAJOR = (major: number): number => vsnative.VK_VERSION_MAJOR(major);
export const VK_VERSION_MINOR = (minor: number): number => vsnative.VK_VERSION_MINOR(minor);
export const VK_VERSION_PATCH = (patch: number): number => vsnative.VK_VERSION_PATCH(patch);
export const VK_API_VERSION_1_0: number = vsnative.VK_API_VERSION_1_0;
export const VK_API_VERSION_1_1 : number= vsnative.VK_API_VERSION_1_1;
export const VK_API_VERSION_1_2: number = vsnative.VK_API_VERSION_1_2;
export const VK_API_VERSION_1_3 : number= vsnative.VK_API_VERSION_1_3;

interface StructsMemoryMapEntry {
     structName: string;
     params: StructsMemoryMapParam[];
     total: number;
}

interface StructsMemoryMapParam {
    simpleType: string;
    fullType: string;
    offset: number;
    size: number;
    simpleTypeTS: string;
    isPointer: boolean;
    isDoublePointer: boolean;
    paramName: string;
    optional: boolean;
    modifiers: string[];
    values: string;
}

import * as alimap from "./alignmentValuesMap.json"
const bindata = new Uint32Array(vsnative.getMemoryAlignment());
export const structsMemoryMap: StructsMemoryMapEntry[] = Object.entries(alimap).map((entries) => {
    const structName = entries[0];
    let total = 0;
    const params = Object.entries(entries[1]).map((paramEntries) => {
        const paramName = paramEntries[0];
        const fullType = paramEntries[1].fullType;
        const simpleType = paramEntries[1].simpleType;
        const modifiers = paramEntries[1].modifiers;
        const optional = paramEntries[1].optional;
        const isDoublePointer = paramEntries[1].isDoublePointer;
        const isPointer = paramEntries[1].isPointer;
        const values = paramEntries[1].values;
        const simpleTypeTS = paramEntries[1].simpleTypeTS;
        const offset = bindata[paramEntries[1].offsetIndex * 2];
        const size = bindata[paramEntries[1].sizeIndex * 2];
        total = Math.max(total, offset + size);
        const val: StructsMemoryMapParam = {
            paramName, offset, size, fullType, simpleType,
            modifiers, optional, isDoublePointer, isPointer,
            simpleTypeTS, values
        }
        return val;
    });
    return {
        structName, params, total
    }
})


export const getStructSize = (name: string): number => {
    const res = structsMemoryMap.find((x) => x.structName === name)?.total;
    if(!res){
        throw new Error("Cannot find size for struct " + name);
    }
    return res;
}

export const numberToBuffer = (value: number, type: string): BaseMembuf => {
    switch(type){
        case "int8_t":
            return new int8_t(value);
        case "int16_t":
            return new int16_t(value);
        case "int32_t":
            return new int32_t(value);
        case "int64_t":
            return new int64_t(value);

        case "uint8_t":
            return new uint8_t(value);
        case "uint16_t":
            return new uint16_t(value);
        case "uint32_t":
            return new uint32_t(value);
        case "uint64_t":
            return new uint64_t(value);

        case "float":
            return new float(value);
        case "double":
            return new double(value);
        case "size_t":
            return new size_t(value);
        case "ptr64_t":
            return new ptr64_t(value);
        default:
            return new size_t(value);
    }
}

export const transformParameter = (value: any, type: {
    simple: string,
    isPointer: boolean
  }): number | bigint | null => {
    if(value === null || value === undefined){
        return null;
    }
    if(Array.isArray(value)){
        if(value.length > 0 && typeof value[0] === "string") {
            return allocateStrings(value);
        } else if(value.length > 0 && isMembuf(value[0])) {
          if(value.length > 1){
            if(!Membuf.isContinuousMemory(value as Membuf[])){
                throw new Error("Not continuous memory");
            }
          }
          const bufx = value[0] as Membuf;
          return bufx.allocation.offset;
        } else if(value.length > 0 && isVkSerializable(value[0])) {
          if(value.length > 1){
            if(!Membuf.isContinuousMemory(value.map((x) => x.buffer) as Membuf[])){
                throw new Error("Not continuous memory");
            }
          }
          const bufx = value[0].buffer as Membuf;
          return bufx.allocation.offset;
        }
    } else {
        if(isMembuf(value)) {
            return value.allocation.offset;
        } else if(typeof value === "string") {
            return allocateString(value);
        } else if (typeof value === "number"){
            return numberToBuffer(value, type.simple).allocation.offset;
        } else if (typeof value === "boolean"){
            return numberToBuffer(value ? 1 : 0, 'uint32_t').allocation.offset;
        } else if(isVkSerializable(value)){
          return value.buffer.allocation.offset;
        }
    }
    throw new Error("Unknown value passed to command");
}

export const transformMember = (paramali: StructsMemoryMapParam, paramName: string, value: any): Membuf => {
    if(value === null){
        return new Membuf(paramali.size);
    }
    let arbuf: Membuf | null = null;

    if(Array.isArray(value)){
        if(value.length > 0 && typeof value[0] === "string") {
            arbuf = Membuf.fromUint64(allocateStrings(value));
        } else if(value.length > 0 && typeof value[0] === "number") {
            const bufs = value.map((x) => numberToBuffer(x, paramali.simpleType));
            Membuf.reallocateIntoContinuousMemory(bufs);
            arbuf = bufs[0];
        } else if(value.length > 0 && isMembuf(value[0])) {
            if(!Membuf.isContinuousMemory(value as Membuf[])){
                throw new Error("Not continuous memory");
            }
            if(paramali.isPointer){
                arbuf = value[0].reference();
            } else {
                arbuf = value[0];
            }
        } else if(value.length > 0 && isVkSerializable(value[0])) {
            if(!Membuf.isContinuousMemory(value.map((x) => x.buffer) as Membuf[])){
                throw new Error("Not continuous memory");
            }
            if(paramali.isPointer){
                arbuf = value[0].buffer.reference();
            } else {
                arbuf = value[0].buffer;
            }
        } else if(value.length === 0) {
            const check = new Membuf(paramali.size);
            if(paramali.isPointer){
                arbuf = check.reference();
            } else {
                arbuf = check;
            }
        }
    } else {
        if(isMembuf(value)) {
            arbuf = value;
        } else if(typeof value === "string") {
            arbuf = Membuf.fromUint64(allocateString(value));
        } else if (typeof value === "number"){
            arbuf = numberToBuffer(value, paramali.simpleType);
        } else if (typeof value === "boolean"){
            arbuf = numberToBuffer(value ? 1 : 0, 'uint32_t');
        } else if(isVkSerializable(value)){
            if(paramali.isPointer){
                arbuf = value.buffer.reference();
            } else {
                arbuf = value.buffer;
            }
        }
    }

    if(!arbuf){
      throw new Error("Unknown value passed in struct");
    }
    if(arbuf.allocation.size !== paramali.size){
        console.dir({paramName, value, paramali}, {depth:10})
        throw new Error("Alignment")
    }
    return arbuf;
}

export const makeStructBinaryImage = (name: string, data: object): Membuf => {
    const ali = structsMemoryMap.find((e) => e.structName === name);
    if(!ali){
        throw Error('Cannot create struct ' + name);
    }
    if(sTypes[name]){
        const typeddata = data as { "sType": Membuf };
        typeddata.sType = new Membuf(4);
        typeddata.sType.view.setInt32(0, sTypes[name], true);
    }
    const buf = new Membuf(ali.total);
    Object.entries(data).forEach((entry) => {
        const paramName = entry[0];
        const value = entry[1];
        const paramali = ali.params.find((e) => e.paramName ===  paramName);
        if(!paramali){
            throw Error('Cannot create struct ' + ali.structName + '.' + paramName);
        }
        const offset = paramali.offset;
        const size = paramali.size;

        const arbuf = transformMember(paramali, paramName, value);
        buf.copyFromMembuf(arbuf, 0, offset, size);
    });
    return buf;
}

export const recreateStructFromBinary = <T>(name: string, buf: Membuf): T => {
    const ali = structsMemoryMap.find((e) => e.structName === name);
    if(!ali){
        throw Error('Cannot create struct ' + name);
    }
    const result: Record<string, any> = {};
    const view = buf.view;

    for(const param of ali.params){
        switch(param.simpleType){
            case "int8_t":
                result[param.paramName] = view.getInt8(param.offset);
                break;
            case "int16_t":
                result[param.paramName] = view.getInt16(param.offset, true);
                break;
            case "int32_t":
                result[param.paramName] = view.getInt32(param.offset, true);
                break;
            case "int64_t":
                result[param.paramName] = view.getBigInt64(param.offset, true);
                break;
            case "uint8_t":
                result[param.paramName] = view.getUint8(param.offset);
                break;
            case "uint16_t":
                result[param.paramName] = view.getUint16(param.offset, true);
                break;
            case "uint32_t":
                result[param.paramName] = view.getUint32(param.offset, true);
                break;
            case "float":
                result[param.paramName] = view.getFloat32(param.offset);
                break;
            case "double":
                result[param.paramName] = view.getFloat64(param.offset);
                break;
            case "size_t":
                result[param.paramName] = view.getBigUint64(param.offset);
                break;
            default:
                if(param.isPointer && param.simpleType === "uint64_t" ){
                    // pointer!
                    // result[param.paramName] = recreateStructFromPointer(param.fullType,
                    //     buf.slice(param.offset, param.offset + param.size))
                    throw new Error('Not implemented');
                } else if(!param.isPointer && param.simpleType === "uint64_t" ){
                    result[param.paramName] = view.getBigUint64(param.offset, true);
                } else if(!param.isPointer && param.simpleType === "char" ){
                    // pointer!
                    result[param.paramName] = readCString(
                        buf.slice(param.offset, param.offset + param.size),
                        param.size
                    );
                } else if(param.isPointer && param.simpleType === "char" ){
                    // pointer!
                    result[param.paramName] = " temporary placeholder string! "
                } else if(param.isDoublePointer && param.simpleType === "char" ){
                    // pointer!
                    result[param.paramName] = " temporary placeholder string array! "
                } else if(param.fullType.startsWith("Vk") && param.simpleType.startsWith("Vk") ){
                    result[param.paramName] = recreateStructFromBinaryArray(param.fullType,
                        new Membuf(buf.allocation.subAllocation(param.offset, param.offset + param.size)))
                } else {
                    // no idea, defaulting to undefined
                    result[param.paramName] = undefined
                }
        }
    }

    return result as T;
}

export const recreateStructFromBinaryArray = <T>(name: string, buf: Membuf): T[] => {
    const ali = structsMemoryMap.find((e) => e.structName === name);
    if(!ali){
        throw Error('Cannot create struct ' + name);
    }
    const count = buf.allocation.size / ali.total;
    const result: T[] = [];
    for(let i=0; i<count; i++){
        if(i * ali.total + ali.total > buf.allocation.size){
            break;
        }
        result.push(recreateStructFromBinary(name, buf.slice(i * ali.total, i * ali.total + ali.total)));
    }
    return result;
}
//
// export const recreateStructFromPointer = <T>(name: string, ptrbuf: Membuf): T => {
//     const ali = structsMemoryMap.find((e) => e.structName === name);
//     if(!ali){
//         throw Error('Cannot create struct ' + name);
//     }
//     const ab = getArrayBufferFromAddress(ptrbuf, ali.total);
//     return recreateStructFromBinary(name, ab);
// }


export const readCString = (data: Membuf, max: number): string => {
    for(let i=0;i<max;i++){
        if(data.view.getUint8(i) === 0x0){
            return Buffer.from(getMembufScratchBuffer().chunk.getBuffer(), 0, i).toString("utf-8");
        }
    }
    return "#ERROR";
}

export const readCStringArray = (data: Membuf, count: number, max:number): string[] => {
    let lastStart = 0;
    const result: string[] = [];
    for(let i=0;i<max;i++){
        if(data.view.getUint8(i) === 0x0){
            result.push(
                Buffer.from(
                    getMembufScratchBuffer().chunk.getBuffer(),
                    lastStart,
                    lastStart + i)
                .toString("utf-8"));
            lastStart = i + 1;
            count--;
            if(count === 0){
                return result;
            }
        }
    }
    return result;
}

export const vkMapMemoryToArrayBuffer = (input: Omit<vkMapMemoryInputWithDevice, "ppData">): ArrayBuffer => {
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkMapMemoryParamsTypes[e[0] as keyof typeof vkMapMemoryParamsTypes])];
    }));
    return vsnative.vts_native_vkMapMemoryToArrayBuffer(transformed);
}


export const setupDebugCallback = (input: {instance: VkInstance; callback: (message: string) => void}): void => {
    preventDeallocation(input.callback)
    vsnative.vts_native_setupDebugCallback(input.instance.allocation.offset, input.callback);
}

const deallocationPreventionPool: any[] = [];
export function preventDeallocation(what: any) { deallocationPreventionPool.push(what); }

export const nullptr = new nullptr_t();
nullptr.view.setBigInt64(0, BigInt(0n), true);

export const isVkSerializable = <T extends object = object, TDeser extends object = object>(test: {isVkSerializable?: boolean}): test is VkSerializable<T, TDeser> => test.isVkSerializable ?? false;
export abstract class VkSerializable<Data extends object, DeserData extends object = object> {
    public buffer: Membuf;
    public readonly isVkSerializable = true;
    protected constructor(private data: Data, private typeName: string){
        this.buffer = makeStructBinaryImage(this.typeName, this.data);
    }

    public update(data: Partial<Data>): void {
        this.data = {...this.data, ...data};
        this.buffer = makeStructBinaryImage(this.typeName, this.data);
    }

    public deserialize(): DeserData {
        return recreateStructFromBinary(this.typeName, this.buffer);
    }
}


export class VkInstance extends uint64_t {}
export class VkPhysicalDevice extends uint64_t {}
export class VkDevice extends uint64_t {}
export class VkQueue extends uint64_t {}
export class VkCommandBuffer extends uint64_t {}
export class VkDeviceMemory extends uint64_t {}
export class VkCommandPool extends uint64_t {}
export class VkBuffer extends uint64_t {}
export class VkBufferView extends uint64_t {}
export class VkImage extends uint64_t {}
export class VkImageView extends uint64_t {}
export class VkShaderModule extends uint64_t {}
export class VkPipeline extends uint64_t {}
export class VkPipelineLayout extends uint64_t {}
export class VkSampler extends uint64_t {}
export class VkDescriptorSet extends uint64_t {}
export class VkDescriptorSetLayout extends uint64_t {}
export class VkDescriptorPool extends uint64_t {}
export class VkFence extends uint64_t {}
export class VkSemaphore extends uint64_t {}
export class VkEvent extends uint64_t {}
export class VkQueryPool extends uint64_t {}
export class VkFramebuffer extends uint64_t {}
export class VkRenderPass extends uint64_t {}
export class VkPipelineCache extends uint64_t {}
export class VkIndirectCommandsLayoutNV extends uint64_t {}
export class VkDescriptorUpdateTemplate extends uint64_t {}
export class VkSamplerYcbcrConversion extends uint64_t {}
export class VkValidationCacheEXT extends uint64_t {}
export class VkAccelerationStructureKHR extends uint64_t {}
export class VkAccelerationStructureNV extends uint64_t {}
export class VkPerformanceConfigurationINTEL extends uint64_t {}
export class VkBufferCollectionFUCHSIA extends uint64_t {}
export class VkDeferredOperationKHR extends uint64_t {}
export class VkPrivateDataSlot extends uint64_t {}
export class VkCuModuleNVX extends uint64_t {}
export class VkCuFunctionNVX extends uint64_t {}
export class VkOpticalFlowSessionNV extends uint64_t {}
export class VkMicromapEXT extends uint64_t {}
export class VkShaderEXT extends uint64_t {}
export class VkDisplayKHR extends uint64_t {}
export class VkDisplayModeKHR extends uint64_t {}
export class VkSurfaceKHR extends uint64_t {}
export class VkSwapchainKHR extends uint64_t {}
export class VkDebugReportCallbackEXT extends uint64_t {}
export class VkDebugUtilsMessengerEXT extends uint64_t {}
export class VkVideoSessionKHR extends uint64_t {}
export class VkVideoSessionParametersKHR extends uint64_t {}
export class VkSemaphoreSciSyncPoolNV extends uint64_t {}

export const VK_MAX_PHYSICAL_DEVICE_NAME_SIZE = 256;
export const VK_UUID_SIZE = 16;
export const VK_LUID_SIZE = 8;
export const VK_LUID_SIZE_KHR = 8;
export const VK_MAX_EXTENSION_NAME_SIZE = 256;
export const VK_MAX_DESCRIPTION_SIZE = 256;
export const VK_MAX_MEMORY_TYPES = 32;
export const VK_MAX_MEMORY_HEAPS = 16;
export const VK_LOD_CLAMP_NONE = 1000;
export const VK_REMAINING_MIP_LEVELS = 4294967295;
export const VK_REMAINING_ARRAY_LAYERS = 4294967295;
export const VK_REMAINING_3D_SLICES_EXT = 4294967295;
export const VK_WHOLE_SIZE = 18446744073709551615n;
export const VK_ATTACHMENT_UNUSED = 4294967295;
export const VK_TRUE = 1;
export const VK_FALSE = 0;
export const VK_QUEUE_FAMILY_IGNORED = 4294967295;
export const VK_QUEUE_FAMILY_EXTERNAL = 4294967295;
export const VK_QUEUE_FAMILY_EXTERNAL_KHR = 4294967295;
export const VK_QUEUE_FAMILY_FOREIGN_EXT = 4294967293;
export const VK_SUBPASS_EXTERNAL = 4294967295;
export const VK_MAX_DEVICE_GROUP_SIZE = 32;
export const VK_MAX_DEVICE_GROUP_SIZE_KHR = 32;
export const VK_MAX_DRIVER_NAME_SIZE = 256;
export const VK_MAX_DRIVER_NAME_SIZE_KHR = 256;
export const VK_MAX_DRIVER_INFO_SIZE = 256;
export const VK_MAX_DRIVER_INFO_SIZE_KHR = 256;
export const VK_SHADER_UNUSED_KHR = 4294967295;
export const VK_SHADER_UNUSED_NV = 4294967295;
export const VK_MAX_GLOBAL_PRIORITY_SIZE_KHR = 16;
export const VK_MAX_GLOBAL_PRIORITY_SIZE_EXT = 16;
export const VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT = 32;
export const VK_SHADER_INDEX_UNUSED_AMDX = 4294967295;

// bitmasks
export const VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT = 0x1 << 0;
export const VK_QUEUE_GRAPHICS_BIT = 0x1 << 0;
export const VK_QUEUE_COMPUTE_BIT = 0x1 << 1;
export const VK_QUEUE_TRANSFER_BIT = 0x1 << 2;
export const VK_QUEUE_SPARSE_BINDING_BIT = 0x1 << 3;
export const VK_QUEUE_PROTECTED_BIT = 0x1 << 4;
export const VK_QUEUE_VIDEO_DECODE_BIT_KHR = 0x1 << 5;
export const VK_QUEUE_VIDEO_ENCODE_BIT_KHR = 0x1 << 6;
export const VK_QUEUE_OPTICAL_FLOW_BIT_NV = 0x1 << 8;
export const VK_CULL_MODE_NONE = 0;
export const VK_CULL_MODE_FRONT_BIT = 0x1 << 0;
export const VK_CULL_MODE_BACK_BIT = 0x1 << 1;
export const VK_CULL_MODE_FRONT_AND_BACK = 0x00000003;
export const VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM = 0x1 << 1;
export const VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 0x1 << 0;
export const VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x1 << 0;
export const VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x1 << 1;
export const VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x1 << 2;
export const VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x1 << 3;
export const VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x1 << 4;
export const VK_MEMORY_PROPERTY_PROTECTED_BIT = 0x1 << 5;
export const VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 0x1 << 6;
export const VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 0x1 << 7;
export const VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = 0x1 << 8;
export const VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x1 << 0;
export const VK_MEMORY_HEAP_MULTI_INSTANCE_BIT = 0x1 << 1;
export const VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x1 << 0;
export const VK_ACCESS_INDEX_READ_BIT = 0x1 << 1;
export const VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x1 << 2;
export const VK_ACCESS_UNIFORM_READ_BIT = 0x1 << 3;
export const VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x1 << 4;
export const VK_ACCESS_SHADER_READ_BIT = 0x1 << 5;
export const VK_ACCESS_SHADER_WRITE_BIT = 0x1 << 6;
export const VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x1 << 7;
export const VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x1 << 8;
export const VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x1 << 9;
export const VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x1 << 10;
export const VK_ACCESS_TRANSFER_READ_BIT = 0x1 << 11;
export const VK_ACCESS_TRANSFER_WRITE_BIT = 0x1 << 12;
export const VK_ACCESS_HOST_READ_BIT = 0x1 << 13;
export const VK_ACCESS_HOST_WRITE_BIT = 0x1 << 14;
export const VK_ACCESS_MEMORY_READ_BIT = 0x1 << 15;
export const VK_ACCESS_MEMORY_WRITE_BIT = 0x1 << 16;
export const VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x1 << 25;
export const VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x1 << 26;
export const VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x1 << 27;
export const VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x1 << 20;
export const VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x1 << 19;
export const VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x1 << 21;
export const VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x1 << 22;
export const VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x1 << 24;
export const VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 0x1 << 23;
export const VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV = 0x1 << 17;
export const VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV = 0x1 << 18;
export const VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x1 << 0;
export const VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x1 << 1;
export const VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x1 << 2;
export const VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x1 << 3;
export const VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x1 << 4;
export const VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x1 << 5;
export const VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x1 << 6;
export const VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x1 << 7;
export const VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x1 << 8;
export const VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = 0x1 << 17;
export const VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x1 << 13;
export const VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x1 << 14;
export const VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x1 << 11;
export const VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x1 << 12;
export const VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x1 << 9;
export const VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX = 0x1 << 25;
export const VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 0x1 << 19;
export const VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 0x1 << 20;
export const VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR = 0x1 << 10;
export const VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x1 << 15;
export const VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x1 << 16;
export const VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = 0x1 << 21;
export const VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = 0x1 << 22;
export const VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = 0x1 << 26;
export const VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = 0x1 << 23;
export const VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT = 0x1 << 24;
export const VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR = BigInt(1n << 0n);
export const VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR = BigInt(1n << 1n);
export const VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR = BigInt(1n << 2n);
export const VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR = BigInt(1n << 3n);
export const VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR = BigInt(1n << 4n);
export const VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR = BigInt(1n << 5n);
export const VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR = BigInt(1n << 6n);
export const VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR = BigInt(1n << 7n);
export const VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR = BigInt(1n << 8n);
export const VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX = BigInt(1n << 25n);
export const VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_KHR = BigInt(1n << 9n);
export const VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR = BigInt(1n << 10n);
export const VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_KHR = BigInt(1n << 11n);
export const VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_KHR = BigInt(1n << 12n);
export const VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR = BigInt(1n << 13n);
export const VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR = BigInt(1n << 14n);
export const VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR = BigInt(1n << 15n);
export const VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR = BigInt(1n << 16n);
export const VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT_KHR = BigInt(1n << 17n);
export const VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = BigInt(1n << 19n);
export const VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = BigInt(1n << 20n);
export const VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_KHR = BigInt(1n << 21n);
export const VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_KHR = BigInt(1n << 22n);
export const VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_KHR = BigInt(1n << 26n);
export const VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_KHR = BigInt(1n << 23n);
export const VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_KHR = BigInt(1n << 24n);
export const VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x1 << 0;
export const VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x1 << 1;
export const VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x1 << 2;
export const VK_BUFFER_CREATE_PROTECTED_BIT = 0x1 << 3;
export const VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x1 << 4;
export const VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x1 << 5;
export const VK_SHADER_STAGE_VERTEX_BIT = 0x1 << 0;
export const VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x1 << 1;
export const VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x1 << 2;
export const VK_SHADER_STAGE_GEOMETRY_BIT = 0x1 << 3;
export const VK_SHADER_STAGE_FRAGMENT_BIT = 0x1 << 4;
export const VK_SHADER_STAGE_COMPUTE_BIT = 0x1 << 5;
export const VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F;
export const VK_SHADER_STAGE_ALL = 0x7FFFFFFF;
export const VK_SHADER_STAGE_RAYGEN_BIT_KHR = 0x1 << 8;
export const VK_SHADER_STAGE_ANY_HIT_BIT_KHR = 0x1 << 9;
export const VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR = 0x1 << 10;
export const VK_SHADER_STAGE_MISS_BIT_KHR = 0x1 << 11;
export const VK_SHADER_STAGE_INTERSECTION_BIT_KHR = 0x1 << 12;
export const VK_SHADER_STAGE_CALLABLE_BIT_KHR = 0x1 << 13;
export const VK_SHADER_STAGE_TASK_BIT_EXT = 0x1 << 6;
export const VK_SHADER_STAGE_MESH_BIT_EXT = 0x1 << 7;
export const VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI = 0x1 << 14;
export const VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI = 0x1 << 19;
export const VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x1 << 0;
export const VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x1 << 1;
export const VK_IMAGE_USAGE_SAMPLED_BIT = 0x1 << 2;
export const VK_IMAGE_USAGE_STORAGE_BIT = 0x1 << 3;
export const VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x1 << 4;
export const VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x1 << 5;
export const VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x1 << 6;
export const VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x1 << 7;
export const VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x1 << 10;
export const VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x1 << 11;
export const VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR = 0x1 << 12;
export const VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x1 << 9;
export const VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x1 << 8;
export const VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT = 0x1 << 22;
export const VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x1 << 13;
export const VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x1 << 14;
export const VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR = 0x1 << 15;
export const VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x1 << 19;
export const VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI = 0x1 << 18;
export const VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM = 0x1 << 20;
export const VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM = 0x1 << 21;
export const VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x1 << 0;
export const VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x1 << 1;
export const VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x1 << 2;
export const VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x1 << 3;
export const VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x1 << 4;
export const VK_IMAGE_CREATE_ALIAS_BIT = 0x1 << 10;
export const VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 0x1 << 6;
export const VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 0x1 << 5;
export const VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 0x1 << 7;
export const VK_IMAGE_CREATE_EXTENDED_USAGE_BIT = 0x1 << 8;
export const VK_IMAGE_CREATE_PROTECTED_BIT = 0x1 << 11;
export const VK_IMAGE_CREATE_DISJOINT_BIT = 0x1 << 9;
export const VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV = 0x1 << 13;
export const VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 0x1 << 12;
export const VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT = 0x1 << 14;
export const VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x1 << 16;
export const VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT = 0x1 << 18;
export const VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT = 0x1 << 17;
export const VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM = 0x1 << 15;
export const VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 0x1 << 0;
export const VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x1 << 2;
export const VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = 0x1 << 1;
export const VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = 0x1 << 0;
export const VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 0x1 << 1;
export const VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x1 << 3;
export const VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT = 0x1 << 2;
export const VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM = 0x1 << 4;
export const VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x1 << 0;
export const VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x1 << 1;
export const VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x1 << 2;
export const VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 0x1 << 3;
export const VK_PIPELINE_CREATE_DISPATCH_BASE_BIT = 0x1 << 4;
export const VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = 0x1 << 8;
export const VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT = 0x1 << 9;
export const VK_PIPELINE_CREATE_DISPATCH_BASE = 0x1 << 4;
export const VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x1 << 21;
export const VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x1 << 22;
export const VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 0x1 << 14;
export const VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 0x1 << 15;
export const VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 0x1 << 16;
export const VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 0x1 << 17;
export const VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 0x1 << 12;
export const VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR = 0x1 << 13;
export const VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 0x1 << 19;
export const VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = 0x1 << 5;
export const VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = 0x1 << 6;
export const VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x1 << 7;
export const VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x1 << 18;
export const VK_PIPELINE_CREATE_LIBRARY_BIT_KHR = 0x1 << 11;
export const VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 0x1 << 29;
export const VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT = 0x1 << 23;
export const VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT = 0x1 << 10;
export const VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV = 0x1 << 20;
export const VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x1 << 25;
export const VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x1 << 26;
export const VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT = 0x1 << 24;
export const VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV = 0x1 << 28;
export const VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT = 0x1 << 27;
export const VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT = 0x1 << 30;
export const VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR = BigInt(1n << 0n);
export const VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR = BigInt(1n << 1n);
export const VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR = BigInt(1n << 2n);
export const VK_PIPELINE_CREATE_2_RESERVED_BIT_28_NV = BigInt(1n << 28n);
export const VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = BigInt(1n << 3n);
export const VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR = BigInt(1n << 4n);
export const VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_KHR = BigInt(1n << 5n);
export const VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR = BigInt(1n << 6n);
export const VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = BigInt(1n << 7n);
export const VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR = BigInt(1n << 8n);
export const VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR = BigInt(1n << 9n);
export const VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_KHR = BigInt(1n << 10n);
export const VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_KHR = BigInt(1n << 23n);
export const VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR = BigInt(1n << 11n);
export const VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = BigInt(1n << 12n);
export const VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR = BigInt(1n << 13n);
export const VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = BigInt(1n << 14n);
export const VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = BigInt(1n << 15n);
export const VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = BigInt(1n << 16n);
export const VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = BigInt(1n << 17n);
export const VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = BigInt(1n << 19n);
export const VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_KHR = BigInt(1n << 18n);
export const VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_KHR = BigInt(1n << 20n);
export const VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = BigInt(1n << 21n);
export const VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_KHR = BigInt(1n << 22n);
export const VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_KHR = BigInt(1n << 24n);
export const VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_KHR = BigInt(1n << 25n);
export const VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_KHR = BigInt(1n << 26n);
export const VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_KHR = BigInt(1n << 27n);
export const VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_KHR = BigInt(1n << 30n);
export const VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_KHR = BigInt(1n << 29n);
export const VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT = 0x1 << 0;
export const VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT = 0x1 << 1;
export const VK_COLOR_COMPONENT_R_BIT = 0x1 << 0;
export const VK_COLOR_COMPONENT_G_BIT = 0x1 << 1;
export const VK_COLOR_COMPONENT_B_BIT = 0x1 << 2;
export const VK_COLOR_COMPONENT_A_BIT = 0x1 << 3;
export const VK_FENCE_CREATE_SIGNALED_BIT = 0x1 << 0;

export const VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x1 << 0;
export const VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x1 << 1;
export const VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x1 << 2;
export const VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x1 << 3;
export const VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x1 << 4;
export const VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x1 << 5;
export const VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x1 << 6;
export const VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x1 << 7;
export const VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x1 << 8;
export const VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x1 << 9;
export const VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x1 << 10;
export const VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x1 << 11;
export const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x1 << 12;
export const VK_FORMAT_FEATURE_TRANSFER_SRC_BIT = 0x1 << 14;
export const VK_FORMAT_FEATURE_TRANSFER_DST_BIT = 0x1 << 15;
export const VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 0x1 << 17;
export const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x1 << 18;
export const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 0x1 << 19;
export const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 0x1 << 20;
export const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 0x1 << 21;
export const VK_FORMAT_FEATURE_DISJOINT_BIT = 0x1 << 22;
export const VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 0x1 << 23;
export const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 0x1 << 16;
export const VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR = 0x1 << 25;
export const VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR = 0x1 << 26;
export const VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 0x1 << 29;
export const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 0x1 << 13;
export const VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x1 << 24;
export const VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x1 << 30;
export const VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR = 0x1 << 27;
export const VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR = 0x1 << 28;
export const VK_QUERY_CONTROL_PRECISE_BIT = 0x1 << 0;
export const VK_QUERY_RESULT_64_BIT = 0x1 << 0;
export const VK_QUERY_RESULT_WAIT_BIT = 0x1 << 1;
export const VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x1 << 2;
export const VK_QUERY_RESULT_PARTIAL_BIT = 0x1 << 3;
export const VK_QUERY_RESULT_WITH_STATUS_BIT_KHR = 0x1 << 4;
export const VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x1 << 0;
export const VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x1 << 1;
export const VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x1 << 2;
export const VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x1 << 0;
export const VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x1 << 1;
export const VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x1 << 2;
export const VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x1 << 3;
export const VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x1 << 4;
export const VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x1 << 5;
export const VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x1 << 6;
export const VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x1 << 7;
export const VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x1 << 8;
export const VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x1 << 9;
export const VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x1 << 10;
export const VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT = 0x1 << 11;
export const VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT = 0x1 << 12;
export const VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI = 0x1 << 13;
export const VK_IMAGE_ASPECT_COLOR_BIT = 0x1 << 0;
export const VK_IMAGE_ASPECT_DEPTH_BIT = 0x1 << 1;
export const VK_IMAGE_ASPECT_STENCIL_BIT = 0x1 << 2;
export const VK_IMAGE_ASPECT_METADATA_BIT = 0x1 << 3;
export const VK_IMAGE_ASPECT_PLANE_0_BIT = 0x1 << 4;
export const VK_IMAGE_ASPECT_PLANE_1_BIT = 0x1 << 5;
export const VK_IMAGE_ASPECT_PLANE_2_BIT = 0x1 << 6;
export const VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x1 << 7;
export const VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x1 << 8;
export const VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x1 << 9;
export const VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x1 << 10;
export const VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x1 << 0;
export const VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x1 << 1;
export const VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x1 << 2;
export const VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x1 << 0;
export const VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x1 << 0;
export const VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x1 << 1;
export const VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x1 << 2;
export const VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x1 << 3;
export const VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x1 << 4;
export const VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x1 << 5;
export const VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x1 << 6;
export const VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x1 << 7;
export const VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x1 << 8;
export const VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x1 << 9;
export const VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x1 << 10;
export const VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x1 << 11;
export const VK_PIPELINE_STAGE_TRANSFER_BIT = 0x1 << 12;
export const VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x1 << 13;
export const VK_PIPELINE_STAGE_HOST_BIT = 0x1 << 14;
export const VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x1 << 15;
export const VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x1 << 16;
export const VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 0x1 << 24;
export const VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x1 << 18;
export const VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x1 << 25;
export const VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR = 0x1 << 21;
export const VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x1 << 23;
export const VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x1 << 22;
export const VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV = 0x1 << 17;
export const VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT = 0x1 << 19;
export const VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT = 0x1 << 20;
export const VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x1 << 0;
export const VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x1 << 1;
export const VK_COMMAND_POOL_CREATE_PROTECTED_BIT = 0x1 << 2;
export const VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x1 << 0;
export const VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x1 << 0;
export const VK_SAMPLE_COUNT_1_BIT = 0x1 << 0;
export const VK_SAMPLE_COUNT_2_BIT = 0x1 << 1;
export const VK_SAMPLE_COUNT_4_BIT = 0x1 << 2;
export const VK_SAMPLE_COUNT_8_BIT = 0x1 << 3;
export const VK_SAMPLE_COUNT_16_BIT = 0x1 << 4;
export const VK_SAMPLE_COUNT_32_BIT = 0x1 << 5;
export const VK_SAMPLE_COUNT_64_BIT = 0x1 << 6;
export const VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x1 << 0;
export const VK_STENCIL_FACE_FRONT_BIT = 0x1 << 0;
export const VK_STENCIL_FACE_BACK_BIT = 0x1 << 1;
export const VK_STENCIL_FACE_FRONT_AND_BACK = 0x00000003;
export const VK_STENCIL_FRONT_AND_BACK = VK_STENCIL_FACE_FRONT_AND_BACK;
export const VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x1 << 0;
export const VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = 0x1 << 1;
export const VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT = 0x1 << 2;
export const VK_DEPENDENCY_BY_REGION_BIT = 0x1 << 0;
export const VK_DEPENDENCY_DEVICE_GROUP_BIT = 0x1 << 2;
export const VK_DEPENDENCY_VIEW_LOCAL_BIT = 0x1 << 1;
export const VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT = 0x1 << 3;
export const VK_SEMAPHORE_WAIT_ANY_BIT = 0x1 << 0;
export const VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x1 << 0;
export const VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x1 << 1;
export const VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x1 << 2;
export const VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x1 << 3;
export const VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0x1 << 0;
export const VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0x1 << 1;
export const VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x1 << 2;
export const VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0x1 << 3;
export const VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x1 << 0;
export const VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x1 << 1;
export const VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x1 << 2;
export const VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x1 << 3;
export const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x1 << 4;
export const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x1 << 5;
export const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x1 << 6;
export const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x1 << 7;
export const VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x1 << 8;
export const VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID = 0x1 << 0;
export const VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0x1 << 0;
export const VK_DEBUG_REPORT_WARNING_BIT_EXT = 0x1 << 1;
export const VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x1 << 2;
export const VK_DEBUG_REPORT_ERROR_BIT_EXT = 0x1 << 3;
export const VK_DEBUG_REPORT_DEBUG_BIT_EXT = 0x1 << 4;
export const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 0x1 << 0;
export const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x1 << 1;
export const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 0x1 << 2;
export const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 0x1 << 3;
export const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 0x1 << 0;
export const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 0x1 << 1;
export const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 0x1 << 2;
export const VK_SUBGROUP_FEATURE_BASIC_BIT = 0x1 << 0;
export const VK_SUBGROUP_FEATURE_VOTE_BIT = 0x1 << 1;
export const VK_SUBGROUP_FEATURE_ARITHMETIC_BIT = 0x1 << 2;
export const VK_SUBGROUP_FEATURE_BALLOT_BIT = 0x1 << 3;
export const VK_SUBGROUP_FEATURE_SHUFFLE_BIT = 0x1 << 4;
export const VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 0x1 << 5;
export const VK_SUBGROUP_FEATURE_CLUSTERED_BIT = 0x1 << 6;
export const VK_SUBGROUP_FEATURE_QUAD_BIT = 0x1 << 7;
export const VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 0x1 << 8;
export const VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV = 0x1 << 0;
export const VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV = 0x1 << 1;
export const VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV = 0x1 << 2;
export const VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV = 0x1 << 0;

export const VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = 0x1 << 1;
export const VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 0x1 << 0;
export const VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 0x1 << 4;
export const VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT = 0x1 << 5;
export const VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x1 << 7;
export const VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT = 0x1 << 2;
export const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 0x1 << 0;
export const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x1 << 1;
export const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x1 << 2;
export const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 0x1 << 3;
export const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 0x1 << 4;
export const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 0x1 << 5;
export const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 0x1 << 6;
export const VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 0x1 << 9;
export const VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 0x1 << 10;
export const VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 0x1 << 7;
export const VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 0x1 << 8;
export const VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA = 0x1 << 11;
export const VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV = 0x1 << 12;
export const VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCI_BUF_BIT_NV = 0x1 << 13;
export const VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX = 0x1 << 14;
export const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 0x1 << 0;
export const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 0x1 << 1;
export const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 0x1 << 2;
export const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x1 << 0;
export const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x1 << 1;
export const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x1 << 2;
export const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 0x1 << 3;
export const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
export const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x1 << 4;
export const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA = 0x1 << 7;
export const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV = 0x1 << 5;
export const VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 0x1 << 0;
export const VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 0x1 << 1;
export const VK_SEMAPHORE_IMPORT_TEMPORARY_BIT = 0x1 << 0;
export const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x1 << 0;
export const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x1 << 1;
export const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x1 << 2;
export const VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x1 << 3;
export const VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV = 0x1 << 4;
export const VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV = 0x1 << 5;
export const VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 0x1 << 0;
export const VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 0x1 << 1;
export const VK_FENCE_IMPORT_TEMPORARY_BIT = 0x1 << 0;
export const VK_SURFACE_COUNTER_VBLANK_BIT_EXT = 0x1 << 0;
export const VK_SURFACE_COUNTER_VBLANK_EXT = VK_SURFACE_COUNTER_VBLANK_BIT_EXT;
export const VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT = 0x1 << 0;
export const VK_PEER_MEMORY_FEATURE_COPY_DST_BIT = 0x1 << 1;
export const VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 0x1 << 2;
export const VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 0x1 << 3;
export const VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT = 0x1 << 0;
export const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT = 0x1 << 1;
export const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x1 << 2;
export const VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = 0x1 << 0;
export const VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = 0x1 << 1;
export const VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = 0x1 << 2;
export const VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 0x1 << 3;
export const VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 0x1 << 0;
export const VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = 0x1 << 1;
export const VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = 0x1 << 2;
export const VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT = 0x1 << 3;
export const VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 0x1 << 0;
export const VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 0x1 << 1;
export const VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM = 0x1 << 2;
export const VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM = 0x1 << 3;
export const VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT = 0x1 << 4;
export const VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 0x1 << 5;
export const VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 0x1 << 6;
export const VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x1 << 7;
export const VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = 0x1 << 0;
export const VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = 0x1 << 4;
export const VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = 0x1 << 8;
export const VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = 0x1 << 12;
export const VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = 0x1 << 0;
export const VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = 0x1 << 1;
export const VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = 0x1 << 2;
export const VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT = 0x1 << 3;
export const VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT = 0x1 << 0;
export const VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT = 0x1 << 1;
export const VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT = 0x1 << 2;
export const VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT = 0x1 << 3;
export const VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT = 0x1 << 0;
export const VK_RESOLVE_MODE_NONE = 0;
export const VK_RESOLVE_MODE_SAMPLE_ZERO_BIT = 0x1 << 0;
export const VK_RESOLVE_MODE_AVERAGE_BIT = 0x1 << 1;
export const VK_RESOLVE_MODE_MIN_BIT = 0x1 << 2;
export const VK_RESOLVE_MODE_MAX_BIT = 0x1 << 3;
export const VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR = 0x1 << 0;
export const VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR = 0x1 << 1;
export const VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR = 0x1 << 2;
export const VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR = 0x1 << 3;
export const VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR = VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR;
export const VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT = 0x1 << 4;
export const VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT = 0x1 << 5;
export const VK_GEOMETRY_OPAQUE_BIT_KHR = 0x1 << 0;
export const VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR = 0x1 << 1;
export const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR = 0x1 << 0;
export const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR = 0x1 << 1;
export const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR = 0x1 << 2;
export const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR = 0x1 << 3;
export const VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR = 0x1 << 4;
export const VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV = 0x1 << 5;
export const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT = 0x1 << 6;
export const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT = 0x1 << 7;
export const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT = 0x1 << 8;
export const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_NV = 0x1 << 9;
export const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR = 0x1 << 11;
export const VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 0x1 << 0;
export const VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x1 << 3;
export const VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV = 0x1 << 2;
export const VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = 0x1 << 0;
export const VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV = 0x1 << 0;
export const VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV = 0x1 << 1;
export const VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV = 0x1 << 2;
export const VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV = 0x1 << 3;
export const VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT = 0x1 << 0;
export const VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT;
export const VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT = 0x1 << 1;
export const VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT = VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT;
export const VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT = 0x1 << 2;
export const VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT = VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT;
export const VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_NV = BigInt(1n << 0n);
export const VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR = 0x1 << 0;
export const VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR = VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR;
export const VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR = 0x1 << 1;
export const VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR = VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR;





export const VK_TOOL_PURPOSE_VALIDATION_BIT = 0x1 << 0;
export const VK_TOOL_PURPOSE_VALIDATION_BIT_EXT = VK_TOOL_PURPOSE_VALIDATION_BIT;
export const VK_TOOL_PURPOSE_PROFILING_BIT = 0x1 << 1;
export const VK_TOOL_PURPOSE_PROFILING_BIT_EXT = VK_TOOL_PURPOSE_PROFILING_BIT;
export const VK_TOOL_PURPOSE_TRACING_BIT = 0x1 << 2;
export const VK_TOOL_PURPOSE_TRACING_BIT_EXT = VK_TOOL_PURPOSE_TRACING_BIT;
export const VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT = 0x1 << 3;
export const VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT = VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT;
export const VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT = 0x1 << 4;
export const VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT = VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT;
export const VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT = 0x1 << 5;
export const VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT = 0x1 << 6;
export const VK_ACCESS_2_NONE = BigInt(0);
export const VK_ACCESS_2_NONE_KHR = BigInt(VK_ACCESS_2_NONE);
export const VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT = BigInt(1n << 0n);
export const VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR = BigInt(VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT);
export const VK_ACCESS_2_INDEX_READ_BIT = BigInt(1n << 1n);
export const VK_ACCESS_2_INDEX_READ_BIT_KHR = BigInt(VK_ACCESS_2_INDEX_READ_BIT);
export const VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT = BigInt(1n << 2n);
export const VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR = BigInt(VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT);
export const VK_ACCESS_2_UNIFORM_READ_BIT = BigInt(1n << 3n);
export const VK_ACCESS_2_UNIFORM_READ_BIT_KHR = BigInt(VK_ACCESS_2_UNIFORM_READ_BIT);
export const VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT = BigInt(1n << 4n);
export const VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR = BigInt(VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT);
export const VK_ACCESS_2_SHADER_READ_BIT = BigInt(1n << 5n);
export const VK_ACCESS_2_SHADER_READ_BIT_KHR = BigInt(VK_ACCESS_2_SHADER_READ_BIT);
export const VK_ACCESS_2_SHADER_WRITE_BIT = BigInt(1n << 6n);
export const VK_ACCESS_2_SHADER_WRITE_BIT_KHR = BigInt(VK_ACCESS_2_SHADER_WRITE_BIT);
export const VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT = BigInt(1n << 7n);
export const VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR = BigInt(VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT);
export const VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT = BigInt(1n << 8n);
export const VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR = BigInt(VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT);
export const VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT = BigInt(1n << 9n);
export const VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR = BigInt(VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT);
export const VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = BigInt(1n << 10n);
export const VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR = BigInt(VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT);
export const VK_ACCESS_2_TRANSFER_READ_BIT = BigInt(1n << 11n);
export const VK_ACCESS_2_TRANSFER_READ_BIT_KHR = BigInt(VK_ACCESS_2_TRANSFER_READ_BIT);
export const VK_ACCESS_2_TRANSFER_WRITE_BIT = BigInt(1n << 12n);
export const VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR = BigInt(VK_ACCESS_2_TRANSFER_WRITE_BIT);
export const VK_ACCESS_2_HOST_READ_BIT = BigInt(1n << 13n);
export const VK_ACCESS_2_HOST_READ_BIT_KHR = BigInt(VK_ACCESS_2_HOST_READ_BIT);
export const VK_ACCESS_2_HOST_WRITE_BIT = BigInt(1n << 14n);
export const VK_ACCESS_2_HOST_WRITE_BIT_KHR = BigInt(VK_ACCESS_2_HOST_WRITE_BIT);
export const VK_ACCESS_2_MEMORY_READ_BIT = BigInt(1n << 15n);
export const VK_ACCESS_2_MEMORY_READ_BIT_KHR = BigInt(VK_ACCESS_2_MEMORY_READ_BIT);
export const VK_ACCESS_2_MEMORY_WRITE_BIT = BigInt(1n << 16n);
export const VK_ACCESS_2_MEMORY_WRITE_BIT_KHR = BigInt(VK_ACCESS_2_MEMORY_WRITE_BIT);
export const VK_ACCESS_2_SHADER_SAMPLED_READ_BIT = BigInt(1n << 32n);
export const VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR = BigInt(VK_ACCESS_2_SHADER_SAMPLED_READ_BIT);
export const VK_ACCESS_2_SHADER_STORAGE_READ_BIT = BigInt(1n << 33n);
export const VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR = BigInt(VK_ACCESS_2_SHADER_STORAGE_READ_BIT);
export const VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT = BigInt(1n << 34n);
export const VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR = BigInt(VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT);
export const VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR = BigInt(1n << 35n);
export const VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR = BigInt(1n << 36n);
export const VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR = BigInt(1n << 37n);
export const VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR = BigInt(1n << 38n);
export const VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = BigInt(1n << 25n);
export const VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = BigInt(1n << 26n);
export const VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = BigInt(1n << 27n);
export const VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT = BigInt(1n << 20n);
export const VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV = BigInt(1n << 17n);
export const VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV = BigInt(1n << 18n);
export const VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = BigInt(1n << 23n);
export const VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR = BigInt(1n << 21n);
export const VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = BigInt(1n << 22n);
export const VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = BigInt(1n << 24n);
export const VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = BigInt(1n << 19n);
export const VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT = BigInt(1n << 41n);
export const VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI = BigInt(1n << 39n);
export const VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR = BigInt(1n << 40n);
export const VK_ACCESS_2_MICROMAP_READ_BIT_EXT = BigInt(1n << 44n);
export const VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT = BigInt(1n << 45n);
export const VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV = BigInt(1n << 42n);
export const VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV = BigInt(1n << 43n);
export const VK_PIPELINE_STAGE_2_NONE = BigInt(0);
export const VK_PIPELINE_STAGE_2_NONE_KHR = BigInt(VK_PIPELINE_STAGE_2_NONE);
export const VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT = BigInt(1n << 0n);
export const VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT);
export const VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT = BigInt(1n << 1n);
export const VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT);
export const VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT = BigInt(1n << 2n);
export const VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT);
export const VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT = BigInt(1n << 3n);
export const VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT);
export const VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT = BigInt(1n << 4n);
export const VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT);
export const VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT = BigInt(1n << 5n);
export const VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT);
export const VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT = BigInt(1n << 6n);
export const VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT);
export const VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT = BigInt(1n << 7n);
export const VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT);
export const VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT = BigInt(1n << 8n);
export const VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT);
export const VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT = BigInt(1n << 9n);
export const VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT);
export const VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT = BigInt(1n << 10n);
export const VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT);
export const VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT = BigInt(1n << 11n);
export const VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT);
export const VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT = BigInt(1n << 12n);
export const VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT);
export const VK_PIPELINE_STAGE_2_TRANSFER_BIT = BigInt(VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR);
export const VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT);
export const VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT = BigInt(1n << 13n);
export const VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT);
export const VK_PIPELINE_STAGE_2_HOST_BIT = BigInt(1n << 14n);
export const VK_PIPELINE_STAGE_2_HOST_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_HOST_BIT);
export const VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT = BigInt(1n << 15n);
export const VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT);
export const VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT = BigInt(1n << 16n);
export const VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT);
export const VK_PIPELINE_STAGE_2_COPY_BIT = BigInt(1n << 32n);
export const VK_PIPELINE_STAGE_2_COPY_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_COPY_BIT);
export const VK_PIPELINE_STAGE_2_RESOLVE_BIT = BigInt(1n << 33n);
export const VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_RESOLVE_BIT);
export const VK_PIPELINE_STAGE_2_BLIT_BIT = BigInt(1n << 34n);
export const VK_PIPELINE_STAGE_2_BLIT_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_BLIT_BIT);
export const VK_PIPELINE_STAGE_2_CLEAR_BIT = BigInt(1n << 35n);
export const VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_CLEAR_BIT);
export const VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT = BigInt(1n << 36n);
export const VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT);
export const VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT = BigInt(1n << 37n);
export const VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT);
export const VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT = BigInt(1n << 38n);
export const VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR = BigInt(VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT);
export const VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR = BigInt(1n << 26n);
export const VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR = BigInt(1n << 27n);
export const VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT = BigInt(1n << 24n);
export const VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT = BigInt(1n << 18n);
export const VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV = BigInt(1n << 17n);
export const VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = BigInt(1n << 22n);
export const VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = BigInt(1n << 25n);
export const VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR = BigInt(1n << 21n);
export const VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT = BigInt(1n << 23n);
export const VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT = BigInt(1n << 19n);
export const VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT = BigInt(1n << 20n);
export const VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI = BigInt(1n << 39n);
export const VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI = BigInt(1n << 40n);
export const VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR = BigInt(1n << 28n);
export const VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT = BigInt(1n << 30n);
export const VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI = BigInt(1n << 41n);
export const VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV = BigInt(1n << 29n);
export const VK_SUBMIT_PROTECTED_BIT = 0x1 << 0;
export const VK_SUBMIT_PROTECTED_BIT_KHR = VK_SUBMIT_PROTECTED_BIT;
export const VK_EVENT_CREATE_DEVICE_ONLY_BIT = 0x1 << 0;
export const VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT = 0x1 << 1;
export const VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT = 0x1 << 0;
export const VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 0x1 << 0;
export const VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 0x1 << 1;
export const VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT = 0x1 << 0;
export const VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT = 0x1 << 1;
export const VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT = 0x1 << 2;
export const VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT = 0x1 << 3;
export const VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT = 0x1 << 0;
export const VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT = 0x1 << 0;
export const VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT = 0x1 << 1;
export const VK_PRESENT_SCALING_STRETCH_BIT_EXT = 0x1 << 2;
export const VK_PRESENT_GRAVITY_MIN_BIT_EXT = 0x1 << 0;
export const VK_PRESENT_GRAVITY_MAX_BIT_EXT = 0x1 << 1;
export const VK_PRESENT_GRAVITY_CENTERED_BIT_EXT = 0x1 << 2;
export const VK_VIDEO_CODEC_OPERATION_NONE_KHR = 0;
export const VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_EXT = 0x1 << 16;
export const VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_EXT = 0x1 << 17;
export const VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR = 0x1 << 0;
export const VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR = 0x1 << 1;
export const VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR = 0;
export const VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR = 0x1 << 0;
export const VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR = 0x1 << 1;
export const VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR = 0x1 << 2;
export const VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR = 0x1 << 3;
export const VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR = 0;
export const VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR = 0x1 << 0;
export const VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR = 0x1 << 2;
export const VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR = 0x1 << 4;
export const VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR = 0x1 << 0;
export const VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR = 0x1 << 1;
export const VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR = 0x1 << 0;
export const VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR = 0x1 << 1;
export const VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR = 0;
export const VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR = 0x1 << 0;
export const VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR = 0x1 << 1;
export const VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR = 0x1 << 0;
export const VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR = 0x1 << 1;
export const VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR = 0x1 << 2;
export const VK_VIDEO_DECODE_USAGE_DEFAULT_KHR = 0;
export const VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR = 0x1 << 0;
export const VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR = 0x1 << 1;
export const VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR = 0x1 << 2;
export const VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR = 0x1 << 0;
export const VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR = 0x1 << 1;
export const VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR = 0;
export const VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR = 0x1 << 0;
export const VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR = 0x1 << 1;
export const VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR = 0x1 << 2;
export const VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR = 0x1 << 3;
export const VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR = 0;
export const VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR = 0x1 << 0;
export const VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR = 0x1 << 1;
export const VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR = 0x1 << 2;
export const VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR = 0x1 << 0;
export const VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR = 0x1 << 0;
export const VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR = 0x1 << 1;
export const VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR = 0x1 << 2;
export const VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR = 0;
export const VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR = 0x1 << 0;
export const VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR = 0x1 << 1;
export const VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR = 0x1 << 2;
export const VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_EXT = 0x1 << 0;
export const VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT = 0x1 << 1;
export const VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_EXT = 0x1 << 2;
export const VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_EXT = 0x1 << 3;
export const VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT = 0x1 << 4;
export const VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT = 0x1 << 5;
export const VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT = 0x1 << 6;
export const VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_EXT = 0x1 << 7;
export const VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_EXT = 0x1 << 8;
export const VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_EXT = 0x1 << 0;
export const VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_EXT = 0x1 << 1;
export const VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_EXT = 0x1 << 2;
export const VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_EXT = 0x1 << 3;
export const VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_EXT = 0x1 << 4;
export const VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_EXT = 0x1 << 5;
export const VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_EXT = 0x1 << 6;
export const VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_EXT = 0x1 << 7;
export const VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_EXT = 0x1 << 8;
export const VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_EXT = 0x1 << 9;
export const VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_EXT = 0x1 << 10;
export const VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_EXT = 0x1 << 11;
export const VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_EXT = 0x1 << 12;
export const VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_EXT = 0x1 << 13;
export const VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT = 0x1 << 14;
export const VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_EXT = 0x1 << 15;
export const VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_EXT = 0x1 << 16;
export const VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_EXT = 0x1 << 17;
export const VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_EXT = 0x1 << 0;
export const VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_EXT = 0x1 << 1;
export const VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT = 0x1 << 2;
export const VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT = 0x1 << 3;
export const VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_EXT = 0x1 << 4;
export const VK_HOST_IMAGE_COPY_MEMCPY_EXT = 0x1 << 0;

export const VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA = 0x1 << 0;
export const VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA = 0x1 << 1;
export const VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA = 0x1 << 2;
export const VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA = 0x1 << 3;
export const VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA = 0x1 << 4;
export const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT = BigInt(1n << 0n);
export const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT);
export const VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT = BigInt(1n << 1n);
export const VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT);
export const VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT = BigInt(1n << 2n);
export const VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT);
export const VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT = BigInt(1n << 3n);
export const VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT);
export const VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT = BigInt(1n << 4n);
export const VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT);
export const VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = BigInt(1n << 5n);
export const VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT);
export const VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT = BigInt(1n << 6n);
export const VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT);
export const VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT = BigInt(1n << 7n);
export const VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT);
export const VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT = BigInt(1n << 8n);
export const VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT);
export const VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT = BigInt(1n << 9n);
export const VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT);
export const VK_FORMAT_FEATURE_2_BLIT_SRC_BIT = BigInt(1n << 10n);
export const VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_BLIT_SRC_BIT);
export const VK_FORMAT_FEATURE_2_BLIT_DST_BIT = BigInt(1n << 11n);
export const VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_BLIT_DST_BIT);
export const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT = BigInt(1n << 12n);
export const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT);
export const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT = BigInt(1n << 13n);
export const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = BigInt(VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT);
export const VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT = BigInt(1n << 14n);
export const VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT);
export const VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT = BigInt(1n << 15n);
export const VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT);
export const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT = BigInt(1n << 16n);
export const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT);
export const VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT = BigInt(1n << 17n);
export const VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT);
export const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = BigInt(1n << 18n);
export const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT);
export const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = BigInt(1n << 19n);
export const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT);
export const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = BigInt(1n << 20n);
export const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT);
export const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = BigInt(1n << 21n);
export const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT);
export const VK_FORMAT_FEATURE_2_DISJOINT_BIT = BigInt(1n << 22n);
export const VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_DISJOINT_BIT);
export const VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT = BigInt(1n << 23n);
export const VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT);
export const VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT = BigInt(1n << 31n);
export const VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT);
export const VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT = BigInt(1n << 32n);
export const VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT);
export const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT = BigInt(1n << 33n);
export const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR = BigInt(VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT);
export const VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR = BigInt(1n << 25n);
export const VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR = BigInt(1n << 26n);
export const VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = BigInt(1n << 29n);
export const VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT = BigInt(1n << 24n);
export const VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = BigInt(1n << 30n);
export const VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT = BigInt(1n << 46n);
export const VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR = BigInt(1n << 27n);
export const VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR = BigInt(1n << 28n);
export const VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV = BigInt(1n << 38n);
export const VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM = BigInt(1n << 34n);
export const VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM = BigInt(1n << 35n);
export const VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM = BigInt(1n << 36n);
export const VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM = BigInt(1n << 37n);
export const VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV = BigInt(1n << 40n);
export const VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV = BigInt(1n << 41n);
export const VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV = BigInt(1n << 42n);
export const VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT = 0x1 << 0;
export const VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR = VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT;
export const VK_RENDERING_SUSPENDING_BIT = 0x1 << 1;
export const VK_RENDERING_SUSPENDING_BIT_KHR = VK_RENDERING_SUSPENDING_BIT;
export const VK_RENDERING_RESUMING_BIT = 0x1 << 2;
export const VK_RENDERING_RESUMING_BIT_KHR = VK_RENDERING_RESUMING_BIT;
export const VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x1 << 3;
export const VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_EXT = 0x1 << 0;
export const VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT = 0x1 << 1;
export const VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_EXT = 0x1 << 2;
export const VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_EXT = 0x1 << 3;
export const VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT = 0x1 << 4;
export const VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT = 0x1 << 5;
export const VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT = 0x1 << 6;
export const VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_EXT = 0x1 << 7;
export const VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_EXT = 0x1 << 8;
export const VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_EXT = 0x1 << 9;
export const VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_EXT = 0x1 << 0;
export const VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_EXT = 0x1 << 1;
export const VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_EXT = 0x1 << 2;
export const VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_EXT = 0x1 << 3;
export const VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_EXT = 0x1 << 4;
export const VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_EXT = 0x1 << 5;
export const VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_EXT = 0x1 << 6;
export const VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_EXT = 0x1 << 7;
export const VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_EXT = 0x1 << 8;
export const VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_EXT = 0x1 << 9;
export const VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_EXT = 0x1 << 10;
export const VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_EXT = 0x1 << 11;
export const VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_EXT = 0x1 << 12;
export const VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_EXT = 0x1 << 13;
export const VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT = 0x1 << 14;
export const VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_EXT = 0x1 << 15;
export const VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_EXT = 0x1 << 16;
export const VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_EXT = 0x1 << 17;
export const VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_EXT = 0x1 << 18;
export const VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_EXT = 0x1 << 0;
export const VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_EXT = 0x1 << 1;
export const VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT = 0x1 << 2;
export const VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT = 0x1 << 3;
export const VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_EXT = 0x1 << 4;
export const VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_EXT = 0x1 << 0;
export const VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_EXT = 0x1 << 1;
export const VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_EXT = 0x1 << 2;
export const VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_EXT = 0x1 << 0;
export const VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_EXT = 0x1 << 1;
export const VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_EXT = 0x1 << 2;
export const VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_EXT = 0x1 << 3;
export const VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT = 0x1 << 0;
export const VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT = 0x1 << 1;
export const VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT = 0x1 << 2;
export const VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT = 0x1 << 3;
export const VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT = 0x1 << 4;
export const VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT = 0x1 << 5;
export const VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR = 0x1 << 0;
export const VK_IMAGE_COMPRESSION_DEFAULT_EXT = 0;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT = 0x1 << 0;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT = 0x1 << 1;
export const VK_IMAGE_COMPRESSION_DISABLED_EXT = 0x1 << 2;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT = 0;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT = 0x1 << 0;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT = 0x1 << 1;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT = 0x1 << 2;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT = 0x1 << 3;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT = 0x1 << 4;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT = 0x1 << 5;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT = 0x1 << 6;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT = 0x1 << 7;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT = 0x1 << 8;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT = 0x1 << 9;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT = 0x1 << 10;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT = 0x1 << 11;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT = 0x1 << 12;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT = 0x1 << 13;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT = 0x1 << 14;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT = 0x1 << 15;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT = 0x1 << 16;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT = 0x1 << 17;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT = 0x1 << 18;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT = 0x1 << 19;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT = 0x1 << 20;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT = 0x1 << 21;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT = 0x1 << 22;
export const VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT = 0x1 << 23;
export const VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV = 0;
export const VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV = 0x1 << 0;
export const VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV = 0x1 << 1;
export const VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV = 0x1 << 2;
export const VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV = 0x1 << 3;
export const VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV = 0;
export const VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV = 0x1 << 0;
export const VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV = 0x1 << 1;
export const VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV = 0x1 << 2;
export const VK_OPTICAL_FLOW_USAGE_COST_BIT_NV = 0x1 << 3;
export const VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV = 0x1 << 4;
export const VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV = 0x1 << 0;
export const VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV = 0x1 << 1;
export const VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV = 0x1 << 2;
export const VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV = 0x1 << 3;
export const VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV = 0x1 << 4;
export const VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV = 0x1 << 0;
export const VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT = 0x1 << 0;
export const VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT = 0x1 << 1;
export const VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT = 0x1 << 2;
export const VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 0x1 << 0;
export const VK_SHADER_CREATE_LINK_STAGE_BIT_EXT = 0x1 << 0;
export const VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = 0x1 << 1;
export const VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = 0x1 << 2;
export const VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT = 0x1 << 3;
export const VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT = 0x1 << 4;
export const VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT = 0x1 << 5;
export const VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x1 << 6;

export enum VkPipelineCacheCreateFlagBits{
  VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT = 0x1 << 0,
}
export enum VkQueueFlagBits{
  VK_QUEUE_GRAPHICS_BIT = 0x1 << 0,
  VK_QUEUE_COMPUTE_BIT = 0x1 << 1,
  VK_QUEUE_TRANSFER_BIT = 0x1 << 2,
  VK_QUEUE_SPARSE_BINDING_BIT = 0x1 << 3,
  VK_QUEUE_PROTECTED_BIT = 0x1 << 4,
  VK_QUEUE_VIDEO_DECODE_BIT_KHR = 0x1 << 5,
  VK_QUEUE_VIDEO_ENCODE_BIT_KHR = 0x1 << 6,
  VK_QUEUE_OPTICAL_FLOW_BIT_NV = 0x1 << 8,
}
export enum VkCullModeFlagBits{
  VK_CULL_MODE_NONE = 0,
  VK_CULL_MODE_FRONT_BIT = 0x1 << 0,
  VK_CULL_MODE_BACK_BIT = 0x1 << 1,
  VK_CULL_MODE_FRONT_AND_BACK = 0x00000003,
}
export enum VkRenderPassCreateFlagBits{
  VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM = 0x1 << 1,
}
export enum VkDeviceQueueCreateFlagBits{
  VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 0x1 << 0,
}
export enum VkMemoryPropertyFlagBits{
  VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x1 << 0,
  VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x1 << 1,
  VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x1 << 2,
  VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x1 << 3,
  VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x1 << 4,
  VK_MEMORY_PROPERTY_PROTECTED_BIT = 0x1 << 5,
  VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 0x1 << 6,
  VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 0x1 << 7,
  VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = 0x1 << 8,
}
export enum VkMemoryHeapFlagBits{
  VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x1 << 0,
  VK_MEMORY_HEAP_MULTI_INSTANCE_BIT = 0x1 << 1,
}
export enum VkAccessFlagBits{
  VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x1 << 0,
  VK_ACCESS_INDEX_READ_BIT = 0x1 << 1,
  VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x1 << 2,
  VK_ACCESS_UNIFORM_READ_BIT = 0x1 << 3,
  VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x1 << 4,
  VK_ACCESS_SHADER_READ_BIT = 0x1 << 5,
  VK_ACCESS_SHADER_WRITE_BIT = 0x1 << 6,
  VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x1 << 7,
  VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x1 << 8,
  VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x1 << 9,
  VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x1 << 10,
  VK_ACCESS_TRANSFER_READ_BIT = 0x1 << 11,
  VK_ACCESS_TRANSFER_WRITE_BIT = 0x1 << 12,
  VK_ACCESS_HOST_READ_BIT = 0x1 << 13,
  VK_ACCESS_HOST_WRITE_BIT = 0x1 << 14,
  VK_ACCESS_MEMORY_READ_BIT = 0x1 << 15,
  VK_ACCESS_MEMORY_WRITE_BIT = 0x1 << 16,
  VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x1 << 25,
  VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x1 << 26,
  VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x1 << 27,
  VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x1 << 20,
  VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x1 << 19,
  VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = 0x1 << 21,
  VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 0x1 << 22,
  VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x1 << 24,
  VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 0x1 << 23,
  VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV = 0x1 << 17,
  VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV = 0x1 << 18,
}
export enum VkBufferUsageFlagBits{
  VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x1 << 0,
  VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x1 << 1,
  VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x1 << 2,
  VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x1 << 3,
  VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x1 << 4,
  VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x1 << 5,
  VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x1 << 6,
  VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x1 << 7,
  VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x1 << 8,
  VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = 0x1 << 17,
  VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x1 << 13,
  VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x1 << 14,
  VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x1 << 11,
  VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x1 << 12,
  VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x1 << 9,
  VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX = 0x1 << 25,
  VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR = 0x1 << 19,
  VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR = 0x1 << 20,
  VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR = 0x1 << 10,
  VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x1 << 15,
  VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x1 << 16,
  VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT = 0x1 << 21,
  VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT = 0x1 << 22,
  VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT = 0x1 << 26,
  VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT = 0x1 << 23,
  VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT = 0x1 << 24,
}
export enum VkBufferCreateFlagBits{
  VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0x1 << 0,
  VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0x1 << 1,
  VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0x1 << 2,
  VK_BUFFER_CREATE_PROTECTED_BIT = 0x1 << 3,
  VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x1 << 4,
  VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x1 << 5,
}
export enum VkShaderStageFlagBits{
  VK_SHADER_STAGE_VERTEX_BIT = 0x1 << 0,
  VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x1 << 1,
  VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x1 << 2,
  VK_SHADER_STAGE_GEOMETRY_BIT = 0x1 << 3,
  VK_SHADER_STAGE_FRAGMENT_BIT = 0x1 << 4,
  VK_SHADER_STAGE_COMPUTE_BIT = 0x1 << 5,
  VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F,
  VK_SHADER_STAGE_ALL = 0x7FFFFFFF,
  VK_SHADER_STAGE_RAYGEN_BIT_KHR = 0x1 << 8,
  VK_SHADER_STAGE_ANY_HIT_BIT_KHR = 0x1 << 9,
  VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR = 0x1 << 10,
  VK_SHADER_STAGE_MISS_BIT_KHR = 0x1 << 11,
  VK_SHADER_STAGE_INTERSECTION_BIT_KHR = 0x1 << 12,
  VK_SHADER_STAGE_CALLABLE_BIT_KHR = 0x1 << 13,
  VK_SHADER_STAGE_TASK_BIT_EXT = 0x1 << 6,
  VK_SHADER_STAGE_MESH_BIT_EXT = 0x1 << 7,
  VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI = 0x1 << 14,
  VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI = 0x1 << 19,
}
export enum VkImageUsageFlagBits{
  VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x1 << 0,
  VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x1 << 1,
  VK_IMAGE_USAGE_SAMPLED_BIT = 0x1 << 2,
  VK_IMAGE_USAGE_STORAGE_BIT = 0x1 << 3,
  VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x1 << 4,
  VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x1 << 5,
  VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x1 << 6,
  VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x1 << 7,
  VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR = 0x1 << 10,
  VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR = 0x1 << 11,
  VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR = 0x1 << 12,
  VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x1 << 9,
  VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x1 << 8,
  VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT = 0x1 << 22,
  VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR = 0x1 << 13,
  VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR = 0x1 << 14,
  VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR = 0x1 << 15,
  VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x1 << 19,
  VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI = 0x1 << 18,
  VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM = 0x1 << 20,
  VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM = 0x1 << 21,
}
export enum VkImageCreateFlagBits{
  VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0x1 << 0,
  VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0x1 << 1,
  VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0x1 << 2,
  VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0x1 << 3,
  VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0x1 << 4,
  VK_IMAGE_CREATE_ALIAS_BIT = 0x1 << 10,
  VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 0x1 << 6,
  VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 0x1 << 5,
  VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 0x1 << 7,
  VK_IMAGE_CREATE_EXTENDED_USAGE_BIT = 0x1 << 8,
  VK_IMAGE_CREATE_PROTECTED_BIT = 0x1 << 11,
  VK_IMAGE_CREATE_DISJOINT_BIT = 0x1 << 9,
  VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV = 0x1 << 13,
  VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 0x1 << 12,
  VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT = 0x1 << 14,
  VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x1 << 16,
  VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT = 0x1 << 18,
  VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT = 0x1 << 17,
  VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM = 0x1 << 15,
}
export enum VkImageViewCreateFlagBits{
  VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 0x1 << 0,
  VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x1 << 2,
  VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT = 0x1 << 1,
}
export enum VkSamplerCreateFlagBits{
  VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = 0x1 << 0,
  VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 0x1 << 1,
  VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x1 << 3,
  VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT = 0x1 << 2,
  VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM = 0x1 << 4,
}
export enum VkPipelineCreateFlagBits{
  VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0x1 << 0,
  VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0x1 << 1,
  VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0x1 << 2,
  VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 0x1 << 3,
  VK_PIPELINE_CREATE_DISPATCH_BASE_BIT = 0x1 << 4,
  VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT = 0x1 << 8,
  VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT = 0x1 << 9,
  VK_PIPELINE_CREATE_DISPATCH_BASE = 0x1 << 4,
  VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x1 << 21,
  VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x1 << 22,
  VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR = 0x1 << 14,
  VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR = 0x1 << 15,
  VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR = 0x1 << 16,
  VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR = 0x1 << 17,
  VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR = 0x1 << 12,
  VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR = 0x1 << 13,
  VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR = 0x1 << 19,
  VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = 0x1 << 5,
  VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = 0x1 << 6,
  VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 0x1 << 7,
  VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x1 << 18,
  VK_PIPELINE_CREATE_LIBRARY_BIT_KHR = 0x1 << 11,
  VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 0x1 << 29,
  VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT = 0x1 << 23,
  VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT = 0x1 << 10,
  VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV = 0x1 << 20,
  VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x1 << 25,
  VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT = 0x1 << 26,
  VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT = 0x1 << 24,
  VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV = 0x1 << 28,
  VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT = 0x1 << 27,
  VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT = 0x1 << 30,
}
export enum VkPipelineShaderStageCreateFlagBits{
  VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT = 0x1 << 0,
  VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT = 0x1 << 1,
}
export enum VkColorComponentFlagBits{
  VK_COLOR_COMPONENT_R_BIT = 0x1 << 0,
  VK_COLOR_COMPONENT_G_BIT = 0x1 << 1,
  VK_COLOR_COMPONENT_B_BIT = 0x1 << 2,
  VK_COLOR_COMPONENT_A_BIT = 0x1 << 3,
}
export enum VkFenceCreateFlagBits{
  VK_FENCE_CREATE_SIGNALED_BIT = 0x1 << 0,
}
export enum VkSemaphoreCreateFlagBits{
}
export enum VkFormatFeatureFlagBits{
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0x1 << 0,
  VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0x1 << 1,
  VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0x1 << 2,
  VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0x1 << 3,
  VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0x1 << 4,
  VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0x1 << 5,
  VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0x1 << 6,
  VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0x1 << 7,
  VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0x1 << 8,
  VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x1 << 9,
  VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0x1 << 10,
  VK_FORMAT_FEATURE_BLIT_DST_BIT = 0x1 << 11,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0x1 << 12,
  VK_FORMAT_FEATURE_TRANSFER_SRC_BIT = 0x1 << 14,
  VK_FORMAT_FEATURE_TRANSFER_DST_BIT = 0x1 << 15,
  VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 0x1 << 17,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 0x1 << 18,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 0x1 << 19,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 0x1 << 20,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 0x1 << 21,
  VK_FORMAT_FEATURE_DISJOINT_BIT = 0x1 << 22,
  VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 0x1 << 23,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT = 0x1 << 16,
  VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR = 0x1 << 25,
  VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR = 0x1 << 26,
  VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR = 0x1 << 29,
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT = 0x1 << 13,
  VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT = 0x1 << 24,
  VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x1 << 30,
  VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR = 0x1 << 27,
  VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR = 0x1 << 28,
}
export enum VkQueryControlFlagBits{
  VK_QUERY_CONTROL_PRECISE_BIT = 0x1 << 0,
}
export enum VkQueryResultFlagBits{
  VK_QUERY_RESULT_64_BIT = 0x1 << 0,
  VK_QUERY_RESULT_WAIT_BIT = 0x1 << 1,
  VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0x1 << 2,
  VK_QUERY_RESULT_PARTIAL_BIT = 0x1 << 3,
  VK_QUERY_RESULT_WITH_STATUS_BIT_KHR = 0x1 << 4,
}
export enum VkCommandBufferUsageFlagBits{
  VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x1 << 0,
  VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x1 << 1,
  VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x1 << 2,
}
export enum VkQueryPipelineStatisticFlagBits{
  VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0x1 << 0,
  VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0x1 << 1,
  VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0x1 << 2,
  VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0x1 << 3,
  VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0x1 << 4,
  VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0x1 << 5,
  VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0x1 << 6,
  VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0x1 << 7,
  VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0x1 << 8,
  VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0x1 << 9,
  VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0x1 << 10,
  VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT = 0x1 << 11,
  VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT = 0x1 << 12,
  VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI = 0x1 << 13,
}
export enum VkImageAspectFlagBits{
  VK_IMAGE_ASPECT_COLOR_BIT = 0x1 << 0,
  VK_IMAGE_ASPECT_DEPTH_BIT = 0x1 << 1,
  VK_IMAGE_ASPECT_STENCIL_BIT = 0x1 << 2,
  VK_IMAGE_ASPECT_METADATA_BIT = 0x1 << 3,
  VK_IMAGE_ASPECT_PLANE_0_BIT = 0x1 << 4,
  VK_IMAGE_ASPECT_PLANE_1_BIT = 0x1 << 5,
  VK_IMAGE_ASPECT_PLANE_2_BIT = 0x1 << 6,
  VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x1 << 7,
  VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x1 << 8,
  VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x1 << 9,
  VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x1 << 10,
}
export enum VkSparseImageFormatFlagBits{
  VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0x1 << 0,
  VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0x1 << 1,
  VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x1 << 2,
}
export enum VkSparseMemoryBindFlagBits{
  VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0x1 << 0,
}
export enum VkPipelineStageFlagBits{
  VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x1 << 0,
  VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x1 << 1,
  VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x1 << 2,
  VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x1 << 3,
  VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x1 << 4,
  VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x1 << 5,
  VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x1 << 6,
  VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x1 << 7,
  VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x1 << 8,
  VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x1 << 9,
  VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x1 << 10,
  VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x1 << 11,
  VK_PIPELINE_STAGE_TRANSFER_BIT = 0x1 << 12,
  VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x1 << 13,
  VK_PIPELINE_STAGE_HOST_BIT = 0x1 << 14,
  VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x1 << 15,
  VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x1 << 16,
  VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 0x1 << 24,
  VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x1 << 18,
  VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR = 0x1 << 25,
  VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR = 0x1 << 21,
  VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x1 << 23,
  VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 0x1 << 22,
  VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV = 0x1 << 17,
  VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT = 0x1 << 19,
  VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT = 0x1 << 20,
}
export enum VkCommandPoolCreateFlagBits{
  VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x1 << 0,
  VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x1 << 1,
  VK_COMMAND_POOL_CREATE_PROTECTED_BIT = 0x1 << 2,
}
export enum VkCommandPoolResetFlagBits{
  VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0x1 << 0,
}
export enum VkCommandBufferResetFlagBits{
  VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0x1 << 0,
}
export enum VkSampleCountFlagBits{
  VK_SAMPLE_COUNT_1_BIT = 0x1 << 0,
  VK_SAMPLE_COUNT_2_BIT = 0x1 << 1,
  VK_SAMPLE_COUNT_4_BIT = 0x1 << 2,
  VK_SAMPLE_COUNT_8_BIT = 0x1 << 3,
  VK_SAMPLE_COUNT_16_BIT = 0x1 << 4,
  VK_SAMPLE_COUNT_32_BIT = 0x1 << 5,
  VK_SAMPLE_COUNT_64_BIT = 0x1 << 6,
}
export enum VkAttachmentDescriptionFlagBits{
  VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0x1 << 0,
}
export enum VkStencilFaceFlagBits{
  VK_STENCIL_FACE_FRONT_BIT = 0x1 << 0,
  VK_STENCIL_FACE_BACK_BIT = 0x1 << 1,
  VK_STENCIL_FACE_FRONT_AND_BACK = 0x00000003,
  VK_STENCIL_FRONT_AND_BACK = VK_STENCIL_FACE_FRONT_AND_BACK,
}
export enum VkDescriptorPoolCreateFlagBits{
  VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0x1 << 0,
  VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = 0x1 << 1,
  VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT = 0x1 << 2,
}
export enum VkDependencyFlagBits{
  VK_DEPENDENCY_BY_REGION_BIT = 0x1 << 0,
  VK_DEPENDENCY_DEVICE_GROUP_BIT = 0x1 << 2,
  VK_DEPENDENCY_VIEW_LOCAL_BIT = 0x1 << 1,
  VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT = 0x1 << 3,
}
export enum VkSemaphoreWaitFlagBits{
  VK_SEMAPHORE_WAIT_ANY_BIT = 0x1 << 0,
}
export enum VkDisplayPlaneAlphaFlagBitsKHR{
  VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0x1 << 0,
  VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0x1 << 1,
  VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0x1 << 2,
  VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0x1 << 3,
}
export enum VkCompositeAlphaFlagBitsKHR{
  VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0x1 << 0,
  VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0x1 << 1,
  VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0x1 << 2,
  VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0x1 << 3,
}
export enum VkSurfaceTransformFlagBitsKHR{
  VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0x1 << 0,
  VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0x1 << 1,
  VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0x1 << 2,
  VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0x1 << 3,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0x1 << 4,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0x1 << 5,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0x1 << 6,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0x1 << 7,
  VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0x1 << 8,
}
export enum VkSwapchainImageUsageFlagBitsANDROID{
  VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID = 0x1 << 0,
}
export enum VkDebugReportFlagBitsEXT{
  VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0x1 << 0,
  VK_DEBUG_REPORT_WARNING_BIT_EXT = 0x1 << 1,
  VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0x1 << 2,
  VK_DEBUG_REPORT_ERROR_BIT_EXT = 0x1 << 3,
  VK_DEBUG_REPORT_DEBUG_BIT_EXT = 0x1 << 4,
}
export enum VkExternalMemoryHandleTypeFlagBitsNV{
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 0x1 << 0,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0x1 << 1,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 0x1 << 2,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 0x1 << 3,
}
export enum VkExternalMemoryFeatureFlagBitsNV{
  VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 0x1 << 0,
  VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 0x1 << 1,
  VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 0x1 << 2,
}
export enum VkSubgroupFeatureFlagBits{
  VK_SUBGROUP_FEATURE_BASIC_BIT = 0x1 << 0,
  VK_SUBGROUP_FEATURE_VOTE_BIT = 0x1 << 1,
  VK_SUBGROUP_FEATURE_ARITHMETIC_BIT = 0x1 << 2,
  VK_SUBGROUP_FEATURE_BALLOT_BIT = 0x1 << 3,
  VK_SUBGROUP_FEATURE_SHUFFLE_BIT = 0x1 << 4,
  VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 0x1 << 5,
  VK_SUBGROUP_FEATURE_CLUSTERED_BIT = 0x1 << 6,
  VK_SUBGROUP_FEATURE_QUAD_BIT = 0x1 << 7,
  VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 0x1 << 8,
}
export enum VkIndirectCommandsLayoutUsageFlagBitsNV{
  VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV = 0x1 << 0,
  VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV = 0x1 << 1,
  VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV = 0x1 << 2,
}
export enum VkIndirectStateFlagBitsNV{
  VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV = 0x1 << 0,
}
export enum VkPrivateDataSlotCreateFlagBits{
}
export enum VkDescriptorSetLayoutCreateFlagBits{
  VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = 0x1 << 1,
  VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 0x1 << 0,
  VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT = 0x1 << 4,
  VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT = 0x1 << 5,
  VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV = 0x1 << 7,
  VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT = 0x1 << 2,
}
export enum VkExternalMemoryHandleTypeFlagBits{
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 0x1 << 0,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x1 << 1,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x1 << 2,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 0x1 << 3,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 0x1 << 4,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 0x1 << 5,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 0x1 << 6,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 0x1 << 9,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 0x1 << 10,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 0x1 << 7,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 0x1 << 8,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA = 0x1 << 11,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV = 0x1 << 12,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCI_BUF_BIT_NV = 0x1 << 13,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX = 0x1 << 14,
}
export enum VkExternalMemoryFeatureFlagBits{
  VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 0x1 << 0,
  VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 0x1 << 1,
  VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 0x1 << 2,
}
export enum VkExternalSemaphoreHandleTypeFlagBits{
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x1 << 0,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x1 << 1,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x1 << 2,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 0x1 << 3,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x1 << 4,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA = 0x1 << 7,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV = 0x1 << 5,
}
export enum VkExternalSemaphoreFeatureFlagBits{
  VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 0x1 << 0,
  VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 0x1 << 1,
}
export enum VkSemaphoreImportFlagBits{
  VK_SEMAPHORE_IMPORT_TEMPORARY_BIT = 0x1 << 0,
}
export enum VkExternalFenceHandleTypeFlagBits{
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 0x1 << 0,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 0x1 << 1,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 0x1 << 2,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x1 << 3,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_OBJ_BIT_NV = 0x1 << 4,
  VK_EXTERNAL_FENCE_HANDLE_TYPE_SCI_SYNC_FENCE_BIT_NV = 0x1 << 5,
}
export enum VkExternalFenceFeatureFlagBits{
  VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 0x1 << 0,
  VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 0x1 << 1,
}
export enum VkFenceImportFlagBits{
  VK_FENCE_IMPORT_TEMPORARY_BIT = 0x1 << 0,
}
export enum VkSurfaceCounterFlagBitsEXT{
  VK_SURFACE_COUNTER_VBLANK_BIT_EXT = 0x1 << 0,
  VK_SURFACE_COUNTER_VBLANK_EXT = VK_SURFACE_COUNTER_VBLANK_BIT_EXT,
}
export enum VkPeerMemoryFeatureFlagBits{
  VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT = 0x1 << 0,
  VK_PEER_MEMORY_FEATURE_COPY_DST_BIT = 0x1 << 1,
  VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 0x1 << 2,
  VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 0x1 << 3,
}
export enum VkMemoryAllocateFlagBits{
  VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT = 0x1 << 0,
  VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT = 0x1 << 1,
  VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 0x1 << 2,
}
export enum VkDeviceGroupPresentModeFlagBitsKHR{
  VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = 0x1 << 0,
  VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = 0x1 << 1,
  VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = 0x1 << 2,
  VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 0x1 << 3,
}
export enum VkSwapchainCreateFlagBitsKHR{
  VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 0x1 << 0,
  VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = 0x1 << 1,
  VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = 0x1 << 2,
  VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT = 0x1 << 3,
}
export enum VkSubpassDescriptionFlagBits{
  VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 0x1 << 0,
  VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 0x1 << 1,
  VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM = 0x1 << 2,
  VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM = 0x1 << 3,
  VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT = 0x1 << 4,
  VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 0x1 << 5,
  VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 0x1 << 6,
  VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x1 << 7,
}
export enum VkDebugUtilsMessageSeverityFlagBitsEXT{
  VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = 0x1 << 0,
  VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = 0x1 << 4,
  VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = 0x1 << 8,
  VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = 0x1 << 12,
}
export enum VkDebugUtilsMessageTypeFlagBitsEXT{
  VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = 0x1 << 0,
  VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = 0x1 << 1,
  VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = 0x1 << 2,
  VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT = 0x1 << 3,
}
export enum VkDescriptorBindingFlagBits{
  VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT = 0x1 << 0,
  VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT = 0x1 << 1,
  VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT = 0x1 << 2,
  VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT = 0x1 << 3,
}
export enum VkConditionalRenderingFlagBitsEXT{
  VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT = 0x1 << 0,
}
export enum VkResolveModeFlagBits{
  VK_RESOLVE_MODE_NONE = 0,
  VK_RESOLVE_MODE_SAMPLE_ZERO_BIT = 0x1 << 0,
  VK_RESOLVE_MODE_AVERAGE_BIT = 0x1 << 1,
  VK_RESOLVE_MODE_MIN_BIT = 0x1 << 2,
  VK_RESOLVE_MODE_MAX_BIT = 0x1 << 3,
}
export enum VkGeometryInstanceFlagBitsKHR{
  VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR = 0x1 << 0,
  VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR = 0x1 << 1,
  VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR = 0x1 << 2,
  VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR = 0x1 << 3,
  VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR = VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR,
  VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT = 0x1 << 4,
  VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT = 0x1 << 5,
}
export enum VkGeometryFlagBitsKHR{
  VK_GEOMETRY_OPAQUE_BIT_KHR = 0x1 << 0,
  VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR = 0x1 << 1,
}
export enum VkBuildAccelerationStructureFlagBitsKHR{
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR = 0x1 << 0,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR = 0x1 << 1,
  VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR = 0x1 << 2,
  VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR = 0x1 << 3,
  VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR = 0x1 << 4,
  VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV = 0x1 << 5,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT = 0x1 << 6,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT = 0x1 << 7,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT = 0x1 << 8,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_NV = 0x1 << 9,
  VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR = 0x1 << 11,
}
export enum VkAccelerationStructureCreateFlagBitsKHR{
  VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 0x1 << 0,
  VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT = 0x1 << 3,
  VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV = 0x1 << 2,
}
export enum VkFramebufferCreateFlagBits{
  VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = 0x1 << 0,
}
export enum VkDeviceDiagnosticsConfigFlagBitsNV{
  VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV = 0x1 << 0,
  VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV = 0x1 << 1,
  VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV = 0x1 << 2,
  VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV = 0x1 << 3,
}
export enum VkPipelineCreationFeedbackFlagBits{
  VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT = 0x1 << 0,
  VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT,
  VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT = 0x1 << 1,
  VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT = VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT,
  VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT = 0x1 << 2,
  VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT = VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT,
}
export enum VkPerformanceCounterDescriptionFlagBitsKHR{
  VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR = 0x1 << 0,
  VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR = VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR,
  VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR = 0x1 << 1,
  VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR = VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR,
}
export enum VkAcquireProfilingLockFlagBitsKHR{
}
export enum VkShaderCorePropertiesFlagBitsAMD{
}
export enum VkRefreshObjectFlagBitsKHR{
}
export enum VkShaderModuleCreateFlagBits{
}
export enum VkPipelineCompilerControlFlagBitsAMD{
}
export enum VkToolPurposeFlagBits{
  VK_TOOL_PURPOSE_VALIDATION_BIT = 0x1 << 0,
  VK_TOOL_PURPOSE_VALIDATION_BIT_EXT = VK_TOOL_PURPOSE_VALIDATION_BIT,
  VK_TOOL_PURPOSE_PROFILING_BIT = 0x1 << 1,
  VK_TOOL_PURPOSE_PROFILING_BIT_EXT = VK_TOOL_PURPOSE_PROFILING_BIT,
  VK_TOOL_PURPOSE_TRACING_BIT = 0x1 << 2,
  VK_TOOL_PURPOSE_TRACING_BIT_EXT = VK_TOOL_PURPOSE_TRACING_BIT,
  VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT = 0x1 << 3,
  VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT = VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT,
  VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT = 0x1 << 4,
  VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT = VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT,
  VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT = 0x1 << 5,
  VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT = 0x1 << 6,
}
export enum VkSubmitFlagBits{
  VK_SUBMIT_PROTECTED_BIT = 0x1 << 0,
  VK_SUBMIT_PROTECTED_BIT_KHR = VK_SUBMIT_PROTECTED_BIT,
}
export enum VkEventCreateFlagBits{
  VK_EVENT_CREATE_DEVICE_ONLY_BIT = 0x1 << 0,
}
export enum VkPipelineLayoutCreateFlagBits{
  VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT = 0x1 << 1,
}
export enum VkPipelineColorBlendStateCreateFlagBits{
  VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT = 0x1 << 0,
}
export enum VkPipelineDepthStencilStateCreateFlagBits{
  VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT = 0x1 << 0,
  VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT = 0x1 << 1,
}
export enum VkGraphicsPipelineLibraryFlagBitsEXT{
  VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT = 0x1 << 0,
  VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT = 0x1 << 1,
  VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT = 0x1 << 2,
  VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT = 0x1 << 3,
}
export enum VkDeviceAddressBindingFlagBitsEXT{
  VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT = 0x1 << 0,
}
export enum VkPresentScalingFlagBitsEXT{
  VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT = 0x1 << 0,
  VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT = 0x1 << 1,
  VK_PRESENT_SCALING_STRETCH_BIT_EXT = 0x1 << 2,
}
export enum VkPresentGravityFlagBitsEXT{
  VK_PRESENT_GRAVITY_MIN_BIT_EXT = 0x1 << 0,
  VK_PRESENT_GRAVITY_MAX_BIT_EXT = 0x1 << 1,
  VK_PRESENT_GRAVITY_CENTERED_BIT_EXT = 0x1 << 2,
}
export enum VkVideoCodecOperationFlagBitsKHR{
  VK_VIDEO_CODEC_OPERATION_NONE_KHR = 0,
  VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_EXT = 0x1 << 16,
  VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_EXT = 0x1 << 17,
  VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR = 0x1 << 0,
  VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR = 0x1 << 1,
}
export enum VkVideoChromaSubsamplingFlagBitsKHR{
  VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR = 0,
  VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR = 0x1 << 0,
  VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR = 0x1 << 1,
  VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR = 0x1 << 2,
  VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR = 0x1 << 3,
}
export enum VkVideoComponentBitDepthFlagBitsKHR{
  VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR = 0,
  VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR = 0x1 << 0,
  VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR = 0x1 << 2,
  VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR = 0x1 << 4,
}
export enum VkVideoCapabilityFlagBitsKHR{
  VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR = 0x1 << 0,
  VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR = 0x1 << 1,
}
export enum VkVideoSessionCreateFlagBitsKHR{
  VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR = 0x1 << 0,
  VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR = 0x1 << 1,
}
export enum VkVideoDecodeH264PictureLayoutFlagBitsKHR{
  VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR = 0,
  VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR = 0x1 << 0,
  VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR = 0x1 << 1,
}
export enum VkVideoCodingControlFlagBitsKHR{
  VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR = 0x1 << 0,
  VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR = 0x1 << 1,
  VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR = 0x1 << 2,
}
export enum VkVideoDecodeUsageFlagBitsKHR{
  VK_VIDEO_DECODE_USAGE_DEFAULT_KHR = 0,
  VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR = 0x1 << 0,
  VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR = 0x1 << 1,
  VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR = 0x1 << 2,
}
export enum VkVideoDecodeCapabilityFlagBitsKHR{
  VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR = 0x1 << 0,
  VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR = 0x1 << 1,
}
export enum VkVideoEncodeUsageFlagBitsKHR{
  VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR = 0,
  VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR = 0x1 << 0,
  VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR = 0x1 << 1,
  VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR = 0x1 << 2,
  VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR = 0x1 << 3,
}
export enum VkVideoEncodeContentFlagBitsKHR{
  VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR = 0,
  VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR = 0x1 << 0,
  VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR = 0x1 << 1,
  VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR = 0x1 << 2,
}
export enum VkVideoEncodeCapabilityFlagBitsKHR{
  VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR = 0x1 << 0,
}
export enum VkVideoEncodeFeedbackFlagBitsKHR{
  VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR = 0x1 << 0,
  VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR = 0x1 << 1,
  VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR = 0x1 << 2,
}
export enum VkVideoEncodeRateControlModeFlagBitsKHR{
  VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR = 0,
  VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR = 0x1 << 0,
  VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR = 0x1 << 1,
  VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR = 0x1 << 2,
}
export enum VkVideoEncodeH264CapabilityFlagBitsEXT{
  VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_EXT = 0x1 << 0,
  VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT = 0x1 << 1,
  VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_EXT = 0x1 << 2,
  VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_EXT = 0x1 << 3,
  VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT = 0x1 << 4,
  VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT = 0x1 << 5,
  VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT = 0x1 << 6,
  VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_EXT = 0x1 << 7,
  VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_EXT = 0x1 << 8,
}
export enum VkVideoEncodeH264StdFlagBitsEXT{
  VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_EXT = 0x1 << 0,
  VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_EXT = 0x1 << 1,
  VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_EXT = 0x1 << 2,
  VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_EXT = 0x1 << 3,
  VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_EXT = 0x1 << 4,
  VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_EXT = 0x1 << 5,
  VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_EXT = 0x1 << 6,
  VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_EXT = 0x1 << 7,
  VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_EXT = 0x1 << 8,
  VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_EXT = 0x1 << 9,
  VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_EXT = 0x1 << 10,
  VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_EXT = 0x1 << 11,
  VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_EXT = 0x1 << 12,
  VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_EXT = 0x1 << 13,
  VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT = 0x1 << 14,
  VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_EXT = 0x1 << 15,
  VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_EXT = 0x1 << 16,
  VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_EXT = 0x1 << 17,
}
export enum VkVideoEncodeH264RateControlFlagBitsEXT{
  VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_EXT = 0x1 << 0,
  VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_EXT = 0x1 << 1,
  VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT = 0x1 << 2,
  VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT = 0x1 << 3,
  VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_EXT = 0x1 << 4,
}
export enum VkHostImageCopyFlagBitsEXT{
  VK_HOST_IMAGE_COPY_MEMCPY_EXT = 0x1 << 0,
}
export enum VkImageFormatConstraintsFlagBitsFUCHSIA{
}
export enum VkImageConstraintsInfoFlagBitsFUCHSIA{
  VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA = 0x1 << 0,
  VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA = 0x1 << 1,
  VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA = 0x1 << 2,
  VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA = 0x1 << 3,
  VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA = 0x1 << 4,
}
export enum VkRenderingFlagBits{
  VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT = 0x1 << 0,
  VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR = VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT,
  VK_RENDERING_SUSPENDING_BIT = 0x1 << 1,
  VK_RENDERING_SUSPENDING_BIT_KHR = VK_RENDERING_SUSPENDING_BIT,
  VK_RENDERING_RESUMING_BIT = 0x1 << 2,
  VK_RENDERING_RESUMING_BIT_KHR = VK_RENDERING_RESUMING_BIT,
  VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT = 0x1 << 3,
}
export enum VkVideoEncodeH265CapabilityFlagBitsEXT{
  VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_EXT = 0x1 << 0,
  VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_EXT = 0x1 << 1,
  VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_EXT = 0x1 << 2,
  VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_EXT = 0x1 << 3,
  VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT = 0x1 << 4,
  VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_EXT = 0x1 << 5,
  VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_EXT = 0x1 << 6,
  VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_EXT = 0x1 << 7,
  VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_EXT = 0x1 << 8,
  VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_EXT = 0x1 << 9,
}
export enum VkVideoEncodeH265StdFlagBitsEXT{
  VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_EXT = 0x1 << 0,
  VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_EXT = 0x1 << 1,
  VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_EXT = 0x1 << 2,
  VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_EXT = 0x1 << 3,
  VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_EXT = 0x1 << 4,
  VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_EXT = 0x1 << 5,
  VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_EXT = 0x1 << 6,
  VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_EXT = 0x1 << 7,
  VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_EXT = 0x1 << 8,
  VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_EXT = 0x1 << 9,
  VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_EXT = 0x1 << 10,
  VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_EXT = 0x1 << 11,
  VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_EXT = 0x1 << 12,
  VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_EXT = 0x1 << 13,
  VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_EXT = 0x1 << 14,
  VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_EXT = 0x1 << 15,
  VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_EXT = 0x1 << 16,
  VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_EXT = 0x1 << 17,
  VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_EXT = 0x1 << 18,
}
export enum VkVideoEncodeH265RateControlFlagBitsEXT{
  VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_EXT = 0x1 << 0,
  VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_EXT = 0x1 << 1,
  VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_EXT = 0x1 << 2,
  VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_EXT = 0x1 << 3,
  VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_EXT = 0x1 << 4,
}
export enum VkVideoEncodeH265CtbSizeFlagBitsEXT{
  VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_EXT = 0x1 << 0,
  VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_EXT = 0x1 << 1,
  VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_EXT = 0x1 << 2,
}
export enum VkVideoEncodeH265TransformBlockSizeFlagBitsEXT{
  VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_EXT = 0x1 << 0,
  VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_EXT = 0x1 << 1,
  VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_EXT = 0x1 << 2,
  VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_EXT = 0x1 << 3,
}
export enum VkExportMetalObjectTypeFlagBitsEXT{
  VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT = 0x1 << 0,
  VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT = 0x1 << 1,
  VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT = 0x1 << 2,
  VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT = 0x1 << 3,
  VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT = 0x1 << 4,
  VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT = 0x1 << 5,
}
export enum VkInstanceCreateFlagBits{
  VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR = 0x1 << 0,
}
export enum VkImageCompressionFlagBitsEXT{
  VK_IMAGE_COMPRESSION_DEFAULT_EXT = 0,
  VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT = 0x1 << 0,
  VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT = 0x1 << 1,
  VK_IMAGE_COMPRESSION_DISABLED_EXT = 0x1 << 2,
}
export enum VkImageCompressionFixedRateFlagBitsEXT{
  VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT = 0,
  VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT = 0x1 << 0,
  VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT = 0x1 << 1,
  VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT = 0x1 << 2,
  VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT = 0x1 << 3,
  VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT = 0x1 << 4,
  VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT = 0x1 << 5,
  VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT = 0x1 << 6,
  VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT = 0x1 << 7,
  VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT = 0x1 << 8,
  VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT = 0x1 << 9,
  VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT = 0x1 << 10,
  VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT = 0x1 << 11,
  VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT = 0x1 << 12,
  VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT = 0x1 << 13,
  VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT = 0x1 << 14,
  VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT = 0x1 << 15,
  VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT = 0x1 << 16,
  VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT = 0x1 << 17,
  VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT = 0x1 << 18,
  VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT = 0x1 << 19,
  VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT = 0x1 << 20,
  VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT = 0x1 << 21,
  VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT = 0x1 << 22,
  VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT = 0x1 << 23,
}
export enum VkOpticalFlowGridSizeFlagBitsNV{
  VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV = 0,
  VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV = 0x1 << 0,
  VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV = 0x1 << 1,
  VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV = 0x1 << 2,
  VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV = 0x1 << 3,
}
export enum VkOpticalFlowUsageFlagBitsNV{
  VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV = 0,
  VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV = 0x1 << 0,
  VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV = 0x1 << 1,
  VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV = 0x1 << 2,
  VK_OPTICAL_FLOW_USAGE_COST_BIT_NV = 0x1 << 3,
  VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV = 0x1 << 4,
}
export enum VkOpticalFlowSessionCreateFlagBitsNV{
  VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV = 0x1 << 0,
  VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV = 0x1 << 1,
  VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV = 0x1 << 2,
  VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV = 0x1 << 3,
  VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV = 0x1 << 4,
}
export enum VkOpticalFlowExecuteFlagBitsNV{
  VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV = 0x1 << 0,
}
export enum VkBuildMicromapFlagBitsEXT{
  VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT = 0x1 << 0,
  VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT = 0x1 << 1,
  VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT = 0x1 << 2,
}
export enum VkMicromapCreateFlagBitsEXT{
  VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT = 0x1 << 0,
}
export enum VkShaderCreateFlagBitsEXT{
  VK_SHADER_CREATE_LINK_STAGE_BIT_EXT = 0x1 << 0,
  VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = 0x1 << 1,
  VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = 0x1 << 2,
  VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT = 0x1 << 3,
  VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT = 0x1 << 4,
  VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT = 0x1 << 5,
  VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT = 0x1 << 6,
}

// enums
export const VK_IMAGE_LAYOUT_UNDEFINED = 0;
export const VK_IMAGE_LAYOUT_GENERAL = 1;
export const VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2;
export const VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3;
export const VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4;
export const VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5;
export const VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6;
export const VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7;
export const VK_IMAGE_LAYOUT_PREINITIALIZED = 8;
export const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000;
export const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001;
export const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 1000241000;
export const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 1000241001;
export const VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 1000241002;
export const VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003;
export const VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL = 1000314000;
export const VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL = 1000314001;
export const VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002;
export const VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR = 1000024000;
export const VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR = 1000024001;
export const VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR = 1000024002;
export const VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000;
export const VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000;
export const VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003;
export const VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR = 1000299000;
export const VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR = 1000299001;
export const VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR = 1000299002;
export const VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT = 1000339000;
export const VK_ATTACHMENT_LOAD_OP_LOAD = 0;
export const VK_ATTACHMENT_LOAD_OP_CLEAR = 1;
export const VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2;
export const VK_ATTACHMENT_LOAD_OP_NONE_EXT = 1000400000;
export const VK_ATTACHMENT_STORE_OP_STORE = 0;
export const VK_ATTACHMENT_STORE_OP_DONT_CARE = 1;
export const VK_ATTACHMENT_STORE_OP_NONE = 1000301000;
export const VK_IMAGE_TYPE_1D = 0;
export const VK_IMAGE_TYPE_2D = 1;
export const VK_IMAGE_TYPE_3D = 2;
export const VK_IMAGE_TILING_OPTIMAL = 0;
export const VK_IMAGE_TILING_LINEAR = 1;
export const VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000;
export const VK_IMAGE_VIEW_TYPE_1D = 0;
export const VK_IMAGE_VIEW_TYPE_2D = 1;
export const VK_IMAGE_VIEW_TYPE_3D = 2;
export const VK_IMAGE_VIEW_TYPE_CUBE = 3;
export const VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4;
export const VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5;
export const VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6;
export const VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0;
export const VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1;
export const VK_COMPONENT_SWIZZLE_IDENTITY = 0;
export const VK_COMPONENT_SWIZZLE_ZERO = 1;
export const VK_COMPONENT_SWIZZLE_ONE = 2;
export const VK_COMPONENT_SWIZZLE_R = 3;
export const VK_COMPONENT_SWIZZLE_G = 4;
export const VK_COMPONENT_SWIZZLE_B = 5;
export const VK_COMPONENT_SWIZZLE_A = 6;
export const VK_DESCRIPTOR_TYPE_SAMPLER = 0;
export const VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1;
export const VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2;
export const VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3;
export const VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4;
export const VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5;
export const VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6;
export const VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7;
export const VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8;
export const VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9;
export const VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10;
export const VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK = 1000138000;
export const VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000;
export const VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000;
export const VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM = 1000440000;
export const VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM = 1000440001;
export const VK_DESCRIPTOR_TYPE_MUTABLE_EXT = 1000351000;
export const VK_QUERY_TYPE_OCCLUSION = 0;
export const VK_QUERY_TYPE_PIPELINE_STATISTICS = 1;
export const VK_QUERY_TYPE_TIMESTAMP = 2;
export const VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR = 1000023000;
export const VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004;
export const VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR = 1000116000;
export const VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR = 1000150000;
export const VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR = 1000150001;
export const VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 1000165000;
export const VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL = 1000210000;
export const VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR = 1000299000;
export const VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT = 1000328000;
export const VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT = 1000382000;
export const VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR = 1000386000;
export const VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR = 1000386001;
export const VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT = 1000396000;
export const VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT = 1000396001;
export const VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0;
export const VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1;
export const VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2;
export const VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3;
export const VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4;
export const VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5;
export const VK_BORDER_COLOR_FLOAT_CUSTOM_EXT = 1000287003;
export const VK_BORDER_COLOR_INT_CUSTOM_EXT = 1000287004;
export const VK_PIPELINE_BIND_POINT_GRAPHICS = 0;
export const VK_PIPELINE_BIND_POINT_COMPUTE = 1;
export const VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX = 1000134000;
export const VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR = 1000165000;
export const VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI = 1000369003;
export const VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1;
export const VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0;
export const VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1;
export const VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2;
export const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3;
export const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4;
export const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5;
export const VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6;
export const VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7;
export const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8;
export const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9;
export const VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10;
export const VK_SHARING_MODE_EXCLUSIVE = 0;
export const VK_SHARING_MODE_CONCURRENT = 1;
export const VK_INDEX_TYPE_UINT16 = 0;
export const VK_INDEX_TYPE_UINT32 = 1;
export const VK_INDEX_TYPE_NONE_KHR = 1000165000;
export const VK_INDEX_TYPE_UINT8_EXT = 1000265000;
export const VK_FILTER_NEAREST = 0;
export const VK_FILTER_LINEAR = 1;
export const VK_FILTER_CUBIC_EXT = 1000015000;
export const VK_SAMPLER_MIPMAP_MODE_NEAREST = 0;
export const VK_SAMPLER_MIPMAP_MODE_LINEAR = 1;
export const VK_SAMPLER_ADDRESS_MODE_REPEAT = 0;
export const VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1;
export const VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2;
export const VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3;
export const VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4;
export const VK_COMPARE_OP_NEVER = 0;
export const VK_COMPARE_OP_LESS = 1;
export const VK_COMPARE_OP_EQUAL = 2;
export const VK_COMPARE_OP_LESS_OR_EQUAL = 3;
export const VK_COMPARE_OP_GREATER = 4;
export const VK_COMPARE_OP_NOT_EQUAL = 5;
export const VK_COMPARE_OP_GREATER_OR_EQUAL = 6;
export const VK_COMPARE_OP_ALWAYS = 7;
export const VK_POLYGON_MODE_FILL = 0;
export const VK_POLYGON_MODE_LINE = 1;
export const VK_POLYGON_MODE_POINT = 2;
export const VK_POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000;
export const VK_FRONT_FACE_COUNTER_CLOCKWISE = 0;
export const VK_FRONT_FACE_CLOCKWISE = 1;
export const VK_BLEND_FACTOR_ZERO = 0;
export const VK_BLEND_FACTOR_ONE = 1;
export const VK_BLEND_FACTOR_SRC_COLOR = 2;
export const VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3;
export const VK_BLEND_FACTOR_DST_COLOR = 4;
export const VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5;
export const VK_BLEND_FACTOR_SRC_ALPHA = 6;
export const VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7;
export const VK_BLEND_FACTOR_DST_ALPHA = 8;
export const VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9;
export const VK_BLEND_FACTOR_CONSTANT_COLOR = 10;
export const VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11;
export const VK_BLEND_FACTOR_CONSTANT_ALPHA = 12;
export const VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13;
export const VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14;
export const VK_BLEND_FACTOR_SRC1_COLOR = 15;
export const VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16;
export const VK_BLEND_FACTOR_SRC1_ALPHA = 17;
export const VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18;
export const VK_BLEND_OP_ADD = 0;
export const VK_BLEND_OP_SUBTRACT = 1;
export const VK_BLEND_OP_REVERSE_SUBTRACT = 2;
export const VK_BLEND_OP_MIN = 3;
export const VK_BLEND_OP_MAX = 4;
export const VK_BLEND_OP_ZERO_EXT = 1000148000;
export const VK_BLEND_OP_SRC_EXT = 1000148001;
export const VK_BLEND_OP_DST_EXT = 1000148002;
export const VK_BLEND_OP_SRC_OVER_EXT = 1000148003;
export const VK_BLEND_OP_DST_OVER_EXT = 1000148004;
export const VK_BLEND_OP_SRC_IN_EXT = 1000148005;
export const VK_BLEND_OP_DST_IN_EXT = 1000148006;
export const VK_BLEND_OP_SRC_OUT_EXT = 1000148007;
export const VK_BLEND_OP_DST_OUT_EXT = 1000148008;
export const VK_BLEND_OP_SRC_ATOP_EXT = 1000148009;
export const VK_BLEND_OP_DST_ATOP_EXT = 1000148010;
export const VK_BLEND_OP_XOR_EXT = 1000148011;
export const VK_BLEND_OP_MULTIPLY_EXT = 1000148012;
export const VK_BLEND_OP_SCREEN_EXT = 1000148013;
export const VK_BLEND_OP_OVERLAY_EXT = 1000148014;
export const VK_BLEND_OP_DARKEN_EXT = 1000148015;
export const VK_BLEND_OP_LIGHTEN_EXT = 1000148016;
export const VK_BLEND_OP_COLORDODGE_EXT = 1000148017;
export const VK_BLEND_OP_COLORBURN_EXT = 1000148018;
export const VK_BLEND_OP_HARDLIGHT_EXT = 1000148019;
export const VK_BLEND_OP_SOFTLIGHT_EXT = 1000148020;
export const VK_BLEND_OP_DIFFERENCE_EXT = 1000148021;
export const VK_BLEND_OP_EXCLUSION_EXT = 1000148022;
export const VK_BLEND_OP_INVERT_EXT = 1000148023;
export const VK_BLEND_OP_INVERT_RGB_EXT = 1000148024;
export const VK_BLEND_OP_LINEARDODGE_EXT = 1000148025;
export const VK_BLEND_OP_LINEARBURN_EXT = 1000148026;
export const VK_BLEND_OP_VIVIDLIGHT_EXT = 1000148027;
export const VK_BLEND_OP_LINEARLIGHT_EXT = 1000148028;
export const VK_BLEND_OP_PINLIGHT_EXT = 1000148029;
export const VK_BLEND_OP_HARDMIX_EXT = 1000148030;
export const VK_BLEND_OP_HSL_HUE_EXT = 1000148031;
export const VK_BLEND_OP_HSL_SATURATION_EXT = 1000148032;
export const VK_BLEND_OP_HSL_COLOR_EXT = 1000148033;
export const VK_BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034;
export const VK_BLEND_OP_PLUS_EXT = 1000148035;
export const VK_BLEND_OP_PLUS_CLAMPED_EXT = 1000148036;
export const VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037;
export const VK_BLEND_OP_PLUS_DARKER_EXT = 1000148038;
export const VK_BLEND_OP_MINUS_EXT = 1000148039;
export const VK_BLEND_OP_MINUS_CLAMPED_EXT = 1000148040;
export const VK_BLEND_OP_CONTRAST_EXT = 1000148041;
export const VK_BLEND_OP_INVERT_OVG_EXT = 1000148042;
export const VK_BLEND_OP_RED_EXT = 1000148043;
export const VK_BLEND_OP_GREEN_EXT = 1000148044;
export const VK_BLEND_OP_BLUE_EXT = 1000148045;
export const VK_STENCIL_OP_KEEP = 0;
export const VK_STENCIL_OP_ZERO = 1;
export const VK_STENCIL_OP_REPLACE = 2;
export const VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3;
export const VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4;
export const VK_STENCIL_OP_INVERT = 5;
export const VK_STENCIL_OP_INCREMENT_AND_WRAP = 6;
export const VK_STENCIL_OP_DECREMENT_AND_WRAP = 7;
export const VK_LOGIC_OP_CLEAR = 0;
export const VK_LOGIC_OP_AND = 1;
export const VK_LOGIC_OP_AND_REVERSE = 2;
export const VK_LOGIC_OP_COPY = 3;
export const VK_LOGIC_OP_AND_INVERTED = 4;
export const VK_LOGIC_OP_NO_OP = 5;
export const VK_LOGIC_OP_XOR = 6;
export const VK_LOGIC_OP_OR = 7;
export const VK_LOGIC_OP_NOR = 8;
export const VK_LOGIC_OP_EQUIVALENT = 9;
export const VK_LOGIC_OP_INVERT = 10;
export const VK_LOGIC_OP_OR_REVERSE = 11;
export const VK_LOGIC_OP_COPY_INVERTED = 12;
export const VK_LOGIC_OP_OR_INVERTED = 13;
export const VK_LOGIC_OP_NAND = 14;
export const VK_LOGIC_OP_SET = 15;
export const VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0;
export const VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0;
export const VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1;
export const VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2;
export const VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3;
export const VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4;
export const VK_PHYSICAL_DEVICE_TYPE_OTHER = 0;
export const VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1;
export const VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2;
export const VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3;
export const VK_PHYSICAL_DEVICE_TYPE_CPU = 4;
export const VK_VERTEX_INPUT_RATE_VERTEX = 0;
export const VK_VERTEX_INPUT_RATE_INSTANCE = 1;
export const VK_FORMAT_UNDEFINED = 0;
export const VK_FORMAT_R4G4_UNORM_PACK8 = 1;
export const VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2;
export const VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3;
export const VK_FORMAT_R5G6B5_UNORM_PACK16 = 4;
export const VK_FORMAT_B5G6R5_UNORM_PACK16 = 5;
export const VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6;
export const VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7;
export const VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8;
export const VK_FORMAT_R8_UNORM = 9;
export const VK_FORMAT_R8_SNORM = 10;
export const VK_FORMAT_R8_USCALED = 11;
export const VK_FORMAT_R8_SSCALED = 12;
export const VK_FORMAT_R8_UINT = 13;
export const VK_FORMAT_R8_SINT = 14;
export const VK_FORMAT_R8_SRGB = 15;
export const VK_FORMAT_R8G8_UNORM = 16;
export const VK_FORMAT_R8G8_SNORM = 17;
export const VK_FORMAT_R8G8_USCALED = 18;
export const VK_FORMAT_R8G8_SSCALED = 19;
export const VK_FORMAT_R8G8_UINT = 20;
export const VK_FORMAT_R8G8_SINT = 21;
export const VK_FORMAT_R8G8_SRGB = 22;
export const VK_FORMAT_R8G8B8_UNORM = 23;
export const VK_FORMAT_R8G8B8_SNORM = 24;
export const VK_FORMAT_R8G8B8_USCALED = 25;
export const VK_FORMAT_R8G8B8_SSCALED = 26;
export const VK_FORMAT_R8G8B8_UINT = 27;
export const VK_FORMAT_R8G8B8_SINT = 28;
export const VK_FORMAT_R8G8B8_SRGB = 29;
export const VK_FORMAT_B8G8R8_UNORM = 30;
export const VK_FORMAT_B8G8R8_SNORM = 31;
export const VK_FORMAT_B8G8R8_USCALED = 32;
export const VK_FORMAT_B8G8R8_SSCALED = 33;
export const VK_FORMAT_B8G8R8_UINT = 34;
export const VK_FORMAT_B8G8R8_SINT = 35;
export const VK_FORMAT_B8G8R8_SRGB = 36;
export const VK_FORMAT_R8G8B8A8_UNORM = 37;
export const VK_FORMAT_R8G8B8A8_SNORM = 38;
export const VK_FORMAT_R8G8B8A8_USCALED = 39;
export const VK_FORMAT_R8G8B8A8_SSCALED = 40;
export const VK_FORMAT_R8G8B8A8_UINT = 41;
export const VK_FORMAT_R8G8B8A8_SINT = 42;
export const VK_FORMAT_R8G8B8A8_SRGB = 43;
export const VK_FORMAT_B8G8R8A8_UNORM = 44;
export const VK_FORMAT_B8G8R8A8_SNORM = 45;
export const VK_FORMAT_B8G8R8A8_USCALED = 46;
export const VK_FORMAT_B8G8R8A8_SSCALED = 47;
export const VK_FORMAT_B8G8R8A8_UINT = 48;
export const VK_FORMAT_B8G8R8A8_SINT = 49;
export const VK_FORMAT_B8G8R8A8_SRGB = 50;
export const VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51;
export const VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52;
export const VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53;
export const VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54;
export const VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55;
export const VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56;
export const VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57;
export const VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58;
export const VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59;
export const VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60;
export const VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61;
export const VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62;
export const VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63;
export const VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64;
export const VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65;
export const VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66;
export const VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67;
export const VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68;
export const VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69;
export const VK_FORMAT_R16_UNORM = 70;
export const VK_FORMAT_R16_SNORM = 71;
export const VK_FORMAT_R16_USCALED = 72;
export const VK_FORMAT_R16_SSCALED = 73;
export const VK_FORMAT_R16_UINT = 74;
export const VK_FORMAT_R16_SINT = 75;
export const VK_FORMAT_R16_SFLOAT = 76;
export const VK_FORMAT_R16G16_UNORM = 77;
export const VK_FORMAT_R16G16_SNORM = 78;
export const VK_FORMAT_R16G16_USCALED = 79;
export const VK_FORMAT_R16G16_SSCALED = 80;
export const VK_FORMAT_R16G16_UINT = 81;
export const VK_FORMAT_R16G16_SINT = 82;
export const VK_FORMAT_R16G16_SFLOAT = 83;
export const VK_FORMAT_R16G16B16_UNORM = 84;
export const VK_FORMAT_R16G16B16_SNORM = 85;
export const VK_FORMAT_R16G16B16_USCALED = 86;
export const VK_FORMAT_R16G16B16_SSCALED = 87;
export const VK_FORMAT_R16G16B16_UINT = 88;
export const VK_FORMAT_R16G16B16_SINT = 89;
export const VK_FORMAT_R16G16B16_SFLOAT = 90;
export const VK_FORMAT_R16G16B16A16_UNORM = 91;
export const VK_FORMAT_R16G16B16A16_SNORM = 92;
export const VK_FORMAT_R16G16B16A16_USCALED = 93;
export const VK_FORMAT_R16G16B16A16_SSCALED = 94;
export const VK_FORMAT_R16G16B16A16_UINT = 95;
export const VK_FORMAT_R16G16B16A16_SINT = 96;
export const VK_FORMAT_R16G16B16A16_SFLOAT = 97;
export const VK_FORMAT_R32_UINT = 98;
export const VK_FORMAT_R32_SINT = 99;
export const VK_FORMAT_R32_SFLOAT = 100;
export const VK_FORMAT_R32G32_UINT = 101;
export const VK_FORMAT_R32G32_SINT = 102;
export const VK_FORMAT_R32G32_SFLOAT = 103;
export const VK_FORMAT_R32G32B32_UINT = 104;
export const VK_FORMAT_R32G32B32_SINT = 105;
export const VK_FORMAT_R32G32B32_SFLOAT = 106;
export const VK_FORMAT_R32G32B32A32_UINT = 107;
export const VK_FORMAT_R32G32B32A32_SINT = 108;
export const VK_FORMAT_R32G32B32A32_SFLOAT = 109;
export const VK_FORMAT_R64_UINT = 110;
export const VK_FORMAT_R64_SINT = 111;
export const VK_FORMAT_R64_SFLOAT = 112;
export const VK_FORMAT_R64G64_UINT = 113;
export const VK_FORMAT_R64G64_SINT = 114;
export const VK_FORMAT_R64G64_SFLOAT = 115;
export const VK_FORMAT_R64G64B64_UINT = 116;
export const VK_FORMAT_R64G64B64_SINT = 117;
export const VK_FORMAT_R64G64B64_SFLOAT = 118;
export const VK_FORMAT_R64G64B64A64_UINT = 119;
export const VK_FORMAT_R64G64B64A64_SINT = 120;
export const VK_FORMAT_R64G64B64A64_SFLOAT = 121;
export const VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122;
export const VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123;
export const VK_FORMAT_D16_UNORM = 124;
export const VK_FORMAT_X8_D24_UNORM_PACK32 = 125;
export const VK_FORMAT_D32_SFLOAT = 126;
export const VK_FORMAT_S8_UINT = 127;
export const VK_FORMAT_D16_UNORM_S8_UINT = 128;
export const VK_FORMAT_D24_UNORM_S8_UINT = 129;
export const VK_FORMAT_D32_SFLOAT_S8_UINT = 130;
export const VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131;
export const VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132;
export const VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133;
export const VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134;
export const VK_FORMAT_BC2_UNORM_BLOCK = 135;
export const VK_FORMAT_BC2_SRGB_BLOCK = 136;
export const VK_FORMAT_BC3_UNORM_BLOCK = 137;
export const VK_FORMAT_BC3_SRGB_BLOCK = 138;
export const VK_FORMAT_BC4_UNORM_BLOCK = 139;
export const VK_FORMAT_BC4_SNORM_BLOCK = 140;
export const VK_FORMAT_BC5_UNORM_BLOCK = 141;
export const VK_FORMAT_BC5_SNORM_BLOCK = 142;
export const VK_FORMAT_BC6H_UFLOAT_BLOCK = 143;
export const VK_FORMAT_BC6H_SFLOAT_BLOCK = 144;
export const VK_FORMAT_BC7_UNORM_BLOCK = 145;
export const VK_FORMAT_BC7_SRGB_BLOCK = 146;
export const VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147;
export const VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148;
export const VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149;
export const VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150;
export const VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151;
export const VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152;
export const VK_FORMAT_EAC_R11_UNORM_BLOCK = 153;
export const VK_FORMAT_EAC_R11_SNORM_BLOCK = 154;
export const VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155;
export const VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156;
export const VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157;
export const VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158;
export const VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159;
export const VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160;
export const VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161;
export const VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162;
export const VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163;
export const VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164;
export const VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165;
export const VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166;
export const VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167;
export const VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168;
export const VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169;
export const VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170;
export const VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171;
export const VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172;
export const VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173;
export const VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174;
export const VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175;
export const VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176;
export const VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177;
export const VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178;
export const VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179;
export const VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180;
export const VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181;
export const VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182;
export const VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183;
export const VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184;
export const VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000;
export const VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001;
export const VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002;
export const VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003;
export const VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004;
export const VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005;
export const VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006;
export const VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007;
export const VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008;
export const VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009;
export const VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010;
export const VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011;
export const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012;
export const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013;
export const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014;
export const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015;
export const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016;
export const VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017;
export const VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018;
export const VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019;
export const VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020;
export const VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021;
export const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022;
export const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023;
export const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024;
export const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025;
export const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026;
export const VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027;
export const VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028;
export const VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029;
export const VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030;
export const VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031;
export const VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032;
export const VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033;
export const VK_FORMAT_G8_B8R8_2PLANE_444_UNORM = 1000330000;
export const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 = 1000330001;
export const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 = 1000330002;
export const VK_FORMAT_G16_B16R16_2PLANE_444_UNORM = 1000330003;
export const VK_FORMAT_A4R4G4B4_UNORM_PACK16 = 1000340000;
export const VK_FORMAT_A4B4G4R4_UNORM_PACK16 = 1000340001;
export const VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK = 1000066000;
export const VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK = 1000066001;
export const VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK = 1000066002;
export const VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK = 1000066003;
export const VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK = 1000066004;
export const VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK = 1000066005;
export const VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK = 1000066006;
export const VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK = 1000066007;
export const VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK = 1000066008;
export const VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK = 1000066009;
export const VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK = 1000066010;
export const VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK = 1000066011;
export const VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK = 1000066012;
export const VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK = 1000066013;
export const VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000;
export const VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001;
export const VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002;
export const VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003;
export const VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004;
export const VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005;
export const VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006;
export const VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007;
export const VK_FORMAT_R16G16_S10_5_NV = 1000464000;
export const VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR = 1000470000;
export const VK_FORMAT_A8_UNORM_KHR = 1000470001;
export const VK_STRUCTURE_TYPE_APPLICATION_INFO = 0;
export const VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1;
export const VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2;
export const VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3;
export const VK_STRUCTURE_TYPE_SUBMIT_INFO = 4;
export const VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5;
export const VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6;
export const VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7;
export const VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8;
export const VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9;
export const VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10;
export const VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11;
export const VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12;
export const VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13;
export const VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14;
export const VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15;
export const VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16;
export const VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17;
export const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18;
export const VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19;
export const VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20;
export const VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21;
export const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22;
export const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23;
export const VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24;
export const VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25;
export const VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26;
export const VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27;
export const VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28;
export const VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29;
export const VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30;
export const VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31;
export const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32;
export const VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33;
export const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34;
export const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35;
export const VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36;
export const VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37;
export const VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38;
export const VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39;
export const VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40;
export const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41;
export const VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42;
export const VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43;
export const VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44;
export const VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45;
export const VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46;
export const VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47;
export const VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000;
export const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000;
export const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000;
export const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000;
export const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001;
export const VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000;
export const VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003;
export const VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004;
export const VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005;
export const VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006;
export const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013;
export const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000;
export const VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001;
export const VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000;
export const VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001;
export const VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002;
export const VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003;
export const VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001;
export const VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002;
export const VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004;
export const VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006;
export const VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000;
export const VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001;
export const VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002;
export const VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003;
export const VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000;
export const VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002;
export const VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003;
export const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000;
export const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001;
export const VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002;
export const VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004;
export const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005;
export const VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000;
export const VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002;
export const VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004;
export const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000;
export const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001;
export const VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000;
export const VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001;
export const VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000;
export const VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000;
export const VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000;
export const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000;
export const VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO = 1000147000;
export const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 = 1000109000;
export const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 = 1000109001;
export const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 = 1000109002;
export const VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 = 1000109003;
export const VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 = 1000109004;
export const VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO = 1000109005;
export const VK_STRUCTURE_TYPE_SUBPASS_END_INFO = 1000109006;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES = 1000177000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES = 1000196000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES = 1000180000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES = 1000082000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES = 1000197000;
export const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES = 1000161001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES = 1000161002;
export const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO = 1000161003;
export const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT = 1000161004;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES = 1000199000;
export const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE = 1000199001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES = 1000221000;
export const VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO = 1000246000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 1000130000;
export const VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO = 1000130001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES = 1000211000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 1000108000;
export const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 1000108001;
export const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 1000108002;
export const VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO = 1000108003;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES = 1000253000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES = 1000175000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES = 1000241000;
export const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT = 1000241001;
export const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT = 1000241002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES = 1000261000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES = 1000207000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES = 1000207001;
export const VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO = 1000207002;
export const VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO = 1000207003;
export const VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO = 1000207004;
export const VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO = 1000207005;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES = 1000257000;
export const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO = 1000244001;
export const VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 1000257002;
export const VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 1000257003;
export const VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 1000257004;
export const VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO = 1000192000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES = 1000215000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES = 1000245000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES = 1000276000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES = 1000295000;
export const VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO = 1000295001;
export const VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO = 1000295002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES = 1000297000;
export const VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 = 1000314000;
export const VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 = 1000314001;
export const VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 = 1000314002;
export const VK_STRUCTURE_TYPE_DEPENDENCY_INFO = 1000314003;
export const VK_STRUCTURE_TYPE_SUBMIT_INFO_2 = 1000314004;
export const VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO = 1000314005;
export const VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO = 1000314006;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES = 1000314007;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES = 1000325000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES = 1000335000;
export const VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 = 1000337000;
export const VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 = 1000337001;
export const VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 = 1000337002;
export const VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 = 1000337003;
export const VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 = 1000337004;
export const VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 = 1000337005;
export const VK_STRUCTURE_TYPE_BUFFER_COPY_2 = 1000337006;
export const VK_STRUCTURE_TYPE_IMAGE_COPY_2 = 1000337007;
export const VK_STRUCTURE_TYPE_IMAGE_BLIT_2 = 1000337008;
export const VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 = 1000337009;
export const VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 = 1000337010;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES = 1000225000;
export const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO = 1000225001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES = 1000225002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES = 1000138000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES = 1000138001;
export const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK = 1000138002;
export const VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO = 1000138003;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES = 1000066000;
export const VK_STRUCTURE_TYPE_RENDERING_INFO = 1000044000;
export const VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO = 1000044001;
export const VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO = 1000044002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES = 1000044003;
export const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO = 1000044004;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES = 1000280000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES = 1000280001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES = 1000281001;
export const VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 = 1000360000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES = 1000413000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES = 1000413001;
export const VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS = 1000413002;
export const VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS = 1000413003;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = 1000120000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = 1000063000;
export const VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000;
export const VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001;
export const VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007;
export const VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008;
export const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009;
export const VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010;
export const VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011;
export const VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012;
export const VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000;
export const VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001;
export const VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000;
export const VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000;
export const VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000;
export const VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000;
export const VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000;
export const VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000;
export const VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000;
export const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000;
export const VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000;
export const VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001;
export const VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002;
export const VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR = 1000023000;
export const VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR = 1000023001;
export const VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR = 1000023002;
export const VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR = 1000023003;
export const VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR = 1000023004;
export const VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR = 1000023005;
export const VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000023006;
export const VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR = 1000023007;
export const VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR = 1000023008;
export const VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR = 1000023009;
export const VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR = 1000023010;
export const VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR = 1000023011;
export const VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR = 1000023012;
export const VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR = 1000023013;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR = 1000023014;
export const VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR = 1000023015;
export const VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR = 1000023016;
export const VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR = 1000024000;
export const VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR = 1000024001;
export const VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR = 1000024002;
export const VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000;
export const VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001;
export const VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001;
export const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002;
export const VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX = 1000029000;
export const VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX = 1000029001;
export const VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX = 1000029002;
export const VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000;
export const VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX = 1000030001;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT = 1000038000;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000038001;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT = 1000038002;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_EXT = 1000038003;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT = 1000038004;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_EXT = 1000038005;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_EXT = 1000038006;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_EXT = 1000038007;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT = 1000038008;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT = 1000038009;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_EXT = 1000038010;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_EXT = 1000038011;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_EXT = 1000038012;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_EXT = 1000038013;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_EXT = 1000039000;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000039001;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT = 1000039002;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_EXT = 1000039003;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT = 1000039004;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_EXT = 1000039005;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_EXT = 1000039006;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_EXT = 1000039007;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT = 1000039009;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT = 1000039010;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_EXT = 1000039011;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_EXT = 1000039012;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_EXT = 1000039013;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_EXT = 1000039014;
export const VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR = 1000040000;
export const VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR = 1000040001;
export const VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR = 1000040003;
export const VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000040004;
export const VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR = 1000040005;
export const VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR = 1000040006;
export const VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000;
export const VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000044006;
export const VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 1000044007;
export const VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 1000044008;
export const VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 1000044009;
export const VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000;
export const VK_STRUCTURE_TYPE_PRIVATE_VENDOR_INFO_RESERVED_OFFSET_0_NV = 1000051000;
export const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000;
export const VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001;
export const VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000;
export const VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001;
export const VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000;
export const VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000;
export const VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000;
export const VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001;
export const VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT = 1000068000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT = 1000068001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT = 1000068002;
export const VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000;
export const VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001;
export const VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002;
export const VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003;
export const VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000;
export const VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001;
export const VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002;
export const VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000;
export const VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000;
export const VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001;
export const VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002;
export const VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003;
export const VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000;
export const VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000;
export const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001;
export const VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002;
export const VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000;
export const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000;
export const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000;
export const VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000;
export const VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001;
export const VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002;
export const VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003;
export const VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000;
export const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000;
export const VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000;
export const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000;
export const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001;
export const VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000;
export const VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000;
export const VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000;
export const VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001;
export const VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002;
export const VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000;
export const VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001;
export const VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002;
export const VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR = 1000116003;
export const VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR = 1000116004;
export const VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR = 1000116005;
export const VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR = 1000116006;
export const VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR = 1000116007;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000;
export const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001;
export const VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002;
export const VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000;
export const VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001;
export const VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002;
export const VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003;
export const VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004;
export const VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000;
export const VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000;
export const VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000;
export const VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001;
export const VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002;
export const VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003;
export const VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004;
export const VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000;
export const VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001;
export const VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002;
export const VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003;
export const VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004;
export const VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005;
export const VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID = 1000129006;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX = 1000134000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX = 1000134001;
export const VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX = 1000134002;
export const VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX = 1000134003;
export const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX = 1000134004;
export const VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000;
export const VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001;
export const VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003;
export const VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001;
export const VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002;
export const VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000;
export const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR = 1000150007;
export const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR = 1000150000;
export const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR = 1000150002;
export const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR = 1000150003;
export const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR = 1000150004;
export const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR = 1000150005;
export const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR = 1000150006;
export const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR = 1000150009;
export const VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR = 1000150010;
export const VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR = 1000150011;
export const VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR = 1000150012;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR = 1000150013;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR = 1000150014;
export const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR = 1000150017;
export const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR = 1000150020;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR = 1000347000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR = 1000347001;
export const VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR = 1000150015;
export const VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR = 1000150016;
export const VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR = 1000150018;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR = 1000348013;
export const VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 1000154000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 1000154001;
export const VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002;
export const VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003;
export const VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004;
export const VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005;
export const VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006;
export const VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000;
export const VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR = 1000163000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR = 1000163001;
export const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002;
export const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005;
export const VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000;
export const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001;
export const VK_STRUCTURE_TYPE_GEOMETRY_NV = 1000165003;
export const VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV = 1000165004;
export const VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV = 1000165005;
export const VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006;
export const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007;
export const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009;
export const VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011;
export const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV = 1000165012;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000;
export const VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000;
export const VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001;
export const VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000;
export const VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 1000181000;
export const VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000;
export const VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT = 1000184000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000;
export const VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR = 1000187000;
export const VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000187001;
export const VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR = 1000187002;
export const VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR = 1000187003;
export const VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR = 1000187004;
export const VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR = 1000187005;
export const VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR = 1000174000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR = 1000388000;
export const VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR = 1000388001;
export const VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000;
export const VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = 1000190001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = 1000190002;
export const VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = 1000201000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000;
export const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002;
export const VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000;
export const VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000;
export const VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL = 1000210000;
export const VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001;
export const VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL = 1000210002;
export const VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL = 1000210003;
export const VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL = 1000210004;
export const VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 1000210005;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000;
export const VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000;
export const VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001;
export const VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000;
export const VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001;
export const VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002;
export const VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000226000;
export const VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR = 1000226001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR = 1000226002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR = 1000226003;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR = 1000226004;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT = 1000234000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000;
export const VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001;
export const VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000;
export const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002;
export const VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR = 1000248000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000;
export const VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 1000250000;
export const VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 1000250001;
export const VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 1000250002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT = 1000254000;
export const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT = 1000254001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT = 1000254002;
export const VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000;
export const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002;
export const VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001;
export const VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = 1000259000;
export const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = 1000259001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = 1000259002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT = 1000260000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = 1000265000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT = 1000267000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000;
export const VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR = 1000269001;
export const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002;
export const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003;
export const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004;
export const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT = 1000270000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT = 1000270001;
export const VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT = 1000270002;
export const VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT = 1000270003;
export const VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT = 1000270004;
export const VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT = 1000270005;
export const VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT = 1000270006;
export const VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT = 1000270007;
export const VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT = 1000270008;
export const VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT = 1000270009;
export const VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR = 1000271000;
export const VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR = 1000271001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT = 1000273000;
export const VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT = 1000274000;
export const VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT = 1000274001;
export const VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT = 1000274002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT = 1000275000;
export const VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT = 1000275001;
export const VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT = 1000275002;
export const VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT = 1000275003;
export const VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT = 1000275004;
export const VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT = 1000275005;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV = 1000277000;
export const VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV = 1000277001;
export const VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV = 1000277002;
export const VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV = 1000277003;
export const VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV = 1000277004;
export const VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV = 1000277005;
export const VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV = 1000277006;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV = 1000277007;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV = 1000278000;
export const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV = 1000278001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000;
export const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM = 1000282000;
export const VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM = 1000282001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT = 1000283000;
export const VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT = 1000283001;
export const VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT = 1000283002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT = 1000284000;
export const VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT = 1000284001;
export const VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT = 1000284002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT = 1000286000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT = 1000286001;
export const VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT = 1000287000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT = 1000287001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT = 1000287002;
export const VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR = 1000290000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV = 1000292000;
export const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV = 1000292001;
export const VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV = 1000292002;
export const VK_STRUCTURE_TYPE_PRESENT_ID_KHR = 1000294000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR = 1000294001;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR = 1000299000;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR = 1000299001;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR = 1000299002;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR = 1000299003;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR = 1000299004;
export const VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR = 1000299005;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR = 1000299006;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR = 1000299007;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR = 1000299008;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR = 1000299009;
export const VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000299010;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV = 1000300000;
export const VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV = 1000300001;
export const VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR = 1000308000;
export const VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV = 1000310000;
export const VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT = 1000311000;
export const VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT = 1000311001;
export const VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT = 1000311002;
export const VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT = 1000311003;
export const VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT = 1000311004;
export const VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT = 1000311005;
export const VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT = 1000311006;
export const VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT = 1000311007;
export const VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT = 1000311008;
export const VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT = 1000311009;
export const VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311010;
export const VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311011;
export const VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008;
export const VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 1000314009;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT = 1000316000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT = 1000316001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT = 1000316002;
export const VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT = 1000316003;
export const VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT = 1000316004;
export const VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316005;
export const VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316006;
export const VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316007;
export const VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316008;
export const VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT = 1000316010;
export const VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT = 1000316011;
export const VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT = 1000316012;
export const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316009;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT = 1000320000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT = 1000320001;
export const VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT = 1000320002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD = 1000321000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR = 1000203000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR = 1000322000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR = 1000323000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV = 1000326000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV = 1000326001;
export const VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV = 1000326002;
export const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV = 1000327000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV = 1000327001;
export const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV = 1000327002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT = 1000328000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT = 1000328001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT = 1000330000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT = 1000332000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT = 1000332001;
export const VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM = 1000333000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR = 1000336000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT = 1000338000;
export const VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT = 1000338001;
export const VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT = 1000338004;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT = 1000339000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT = 1000340000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT = 1000341000;
export const VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT = 1000341001;
export const VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT = 1000341002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT = 1000344000;
export const VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT = 1000346000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT = 1000352000;
export const VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT = 1000352001;
export const VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT = 1000352002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT = 1000353000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT = 1000354000;
export const VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT = 1000354001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT = 1000355000;
export const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT = 1000355001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT = 1000356000;
export const VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364000;
export const VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA = 1000364001;
export const VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364002;
export const VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365000;
export const VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365001;
export const VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA = 1000366000;
export const VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA = 1000366001;
export const VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA = 1000366002;
export const VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA = 1000366003;
export const VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA = 1000366004;
export const VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA = 1000366005;
export const VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA = 1000366006;
export const VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA = 1000366007;
export const VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA = 1000366008;
export const VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA = 1000366009;
export const VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI = 1000369000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI = 1000369001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI = 1000369002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI = 1000370000;
export const VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV = 1000371000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV = 1000371001;
export const VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT = 1000372000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT = 1000372001;
export const VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV = 1000373000;
export const VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV = 1000373001;
export const VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV = 1000373002;
export const VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV = 1000373003;
export const VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV = 1000373004;
export const VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV = 1000373005;
export const VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV = 1000373006;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV = 1000373007;
export const VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV = 1000374000;
export const VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV = 1000374001;
export const VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV = 1000374002;
export const VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV = 1000374003;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV = 1000374004;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT = 1000376000;
export const VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT = 1000376001;
export const VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT = 1000376002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT = 1000377000;
export const VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX = 1000378000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT = 1000381000;
export const VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT = 1000381001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT = 1000382000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR = 1000386000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT = 1000391000;
export const VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT = 1000391001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT = 1000392000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT = 1000392001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT = 1000393000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT = 1000395000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT = 1000395001;
export const VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT = 1000396000;
export const VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT = 1000396001;
export const VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT = 1000396002;
export const VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT = 1000396003;
export const VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT = 1000396004;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT = 1000396005;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT = 1000396006;
export const VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT = 1000396007;
export const VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT = 1000396008;
export const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT = 1000396009;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV = 1000397000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV = 1000397001;
export const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV = 1000397002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI = 1000404000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI = 1000404001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT = 1000411000;
export const VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT = 1000411001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT = 1000412000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM = 1000415000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT = 1000418000;
export const VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT = 1000418001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE = 1000420000;
export const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE = 1000420001;
export const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE = 1000420002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT = 1000421000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT = 1000422000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM = 1000425000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM = 1000425001;
export const VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM = 1000425002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV = 1000426000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV = 1000426001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV = 1000427000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV = 1000427001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV = 1000428000;
export const VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV = 1000428001;
export const VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV = 1000428002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV = 1000430000;
export const VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT = 1000435000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT = 1000437000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM = 1000440000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM = 1000440001;
export const VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM = 1000440002;
export const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT = 1000453000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT = 1000455000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT = 1000455001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT = 1000458000;
export const VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT = 1000458001;
export const VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000458002;
export const VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT = 1000458003;
export const VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG = 1000459000;
export const VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG = 1000459001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT = 1000462000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT = 1000462001;
export const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT = 1000462002;
export const VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT = 1000462003;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT = 1000342000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV = 1000464000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV = 1000464001;
export const VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV = 1000464002;
export const VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV = 1000464003;
export const VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV = 1000464004;
export const VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV = 1000464005;
export const VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV = 1000464010;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT = 1000465000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT = 1000466000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR = 1000470000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR = 1000470001;
export const VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR = 1000470003;
export const VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR = 1000470004;
export const VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR = 1000338002;
export const VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR = 1000338003;
export const VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR = 1000470005;
export const VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR = 1000470006;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR = 1000481000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT = 1000482000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT = 1000482001;
export const VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT = 1000482002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM = 1000484000;
export const VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM = 1000484001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC = 1000485000;
export const VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC = 1000485001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM = 1000488000;
export const VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV = 1000489000;
export const VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV = 1000489001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV = 1000489002;
export const VK_STRUCTURE_TYPE_DEVICE_SEMAPHORE_SCI_SYNC_POOL_RESERVATION_CREATE_INFO_NV = 1000489003;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV = 1000490000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV = 1000490001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT = 1000351000;
export const VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT = 1000351002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM = 1000497000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM = 1000497001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT = 1000498000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT = 1000499000;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR = 1000506000;
export const VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR = 1000506001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR = 1000506002;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM = 1000510000;
export const VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM = 1000510001;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT = 1000524000;
export const VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX = 1000529000;
export const VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX = 1000529001;
export const VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX = 1000529002;
export const VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX = 1000529003;
export const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX = 1000529004;
export const VK_SUBPASS_CONTENTS_INLINE = 0;
export const VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1;
export const VK_SUCCESS = 0;
export const VK_NOT_READY = 1;
export const VK_TIMEOUT = 2;
export const VK_EVENT_SET = 3;
export const VK_EVENT_RESET = 4;
export const VK_INCOMPLETE = 5;
export const VK_ERROR_OUT_OF_HOST_MEMORY = -1;
export const VK_ERROR_OUT_OF_DEVICE_MEMORY = -2;
export const VK_ERROR_INITIALIZATION_FAILED = -3;
export const VK_ERROR_DEVICE_LOST = -4;
export const VK_ERROR_MEMORY_MAP_FAILED = -5;
export const VK_ERROR_LAYER_NOT_PRESENT = -6;
export const VK_ERROR_EXTENSION_NOT_PRESENT = -7;
export const VK_ERROR_FEATURE_NOT_PRESENT = -8;
export const VK_ERROR_INCOMPATIBLE_DRIVER = -9;
export const VK_ERROR_TOO_MANY_OBJECTS = -10;
export const VK_ERROR_FORMAT_NOT_SUPPORTED = -11;
export const VK_ERROR_FRAGMENTED_POOL = -12;
export const VK_ERROR_UNKNOWN = -13;
export const VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000;
export const VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003;
export const VK_ERROR_FRAGMENTATION = -1000161000;
export const VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000;
export const VK_PIPELINE_COMPILE_REQUIRED = 1000297000;
export const VK_ERROR_SURFACE_LOST_KHR = -1000000000;
export const VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001;
export const VK_SUBOPTIMAL_KHR = 1000001003;
export const VK_ERROR_OUT_OF_DATE_KHR = -1000001004;
export const VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001;
export const VK_ERROR_VALIDATION_FAILED_EXT = -1000011001;
export const VK_ERROR_INVALID_SHADER_NV = -1000012000;
export const VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR = -1000023000;
export const VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR = -1000023001;
export const VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR = -1000023002;
export const VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR = -1000023003;
export const VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR = -1000023004;
export const VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR = -1000023005;
export const VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000;
export const VK_ERROR_NOT_PERMITTED_KHR = -1000174001;
export const VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000;
export const VK_THREAD_IDLE_KHR = 1000268000;
export const VK_THREAD_DONE_KHR = 1000268001;
export const VK_OPERATION_DEFERRED_KHR = 1000268002;
export const VK_OPERATION_NOT_DEFERRED_KHR = 1000268003;
export const VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR = -1000299000;
export const VK_ERROR_COMPRESSION_EXHAUSTED_EXT = -1000338000;
export const VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT = 1000482000;
export const VK_DYNAMIC_STATE_VIEWPORT = 0;
export const VK_DYNAMIC_STATE_SCISSOR = 1;
export const VK_DYNAMIC_STATE_LINE_WIDTH = 2;
export const VK_DYNAMIC_STATE_DEPTH_BIAS = 3;
export const VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4;
export const VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5;
export const VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6;
export const VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7;
export const VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8;
export const VK_DYNAMIC_STATE_CULL_MODE = 1000267000;
export const VK_DYNAMIC_STATE_FRONT_FACE = 1000267001;
export const VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY = 1000267002;
export const VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT = 1000267003;
export const VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT = 1000267004;
export const VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE = 1000267005;
export const VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE = 1000267006;
export const VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE = 1000267007;
export const VK_DYNAMIC_STATE_DEPTH_COMPARE_OP = 1000267008;
export const VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE = 1000267009;
export const VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE = 1000267010;
export const VK_DYNAMIC_STATE_STENCIL_OP = 1000267011;
export const VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE = 1000377001;
export const VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE = 1000377002;
export const VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE = 1000377004;
export const VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000;
export const VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000;
export const VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT = 1000099001;
export const VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT = 1000099002;
export const VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000;
export const VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR = 1000347000;
export const VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004;
export const VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006;
export const VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV = 1000205000;
export const VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV = 1000205001;
export const VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR = 1000226000;
export const VK_DYNAMIC_STATE_LINE_STIPPLE_EXT = 1000259000;
export const VK_DYNAMIC_STATE_VERTEX_INPUT_EXT = 1000352000;
export const VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT = 1000377000;
export const VK_DYNAMIC_STATE_LOGIC_OP_EXT = 1000377003;
export const VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT = 1000381000;
export const VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT = 1000455002;
export const VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT = 1000455003;
export const VK_DYNAMIC_STATE_POLYGON_MODE_EXT = 1000455004;
export const VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT = 1000455005;
export const VK_DYNAMIC_STATE_SAMPLE_MASK_EXT = 1000455006;
export const VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT = 1000455007;
export const VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT = 1000455008;
export const VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT = 1000455009;
export const VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT = 1000455010;
export const VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT = 1000455011;
export const VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT = 1000455012;
export const VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT = 1000455013;
export const VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT = 1000455014;
export const VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT = 1000455015;
export const VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT = 1000455016;
export const VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT = 1000455017;
export const VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT = 1000455018;
export const VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT = 1000455019;
export const VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT = 1000455020;
export const VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT = 1000455021;
export const VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT = 1000455022;
export const VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV = 1000455023;
export const VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV = 1000455024;
export const VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV = 1000455025;
export const VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV = 1000455026;
export const VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV = 1000455027;
export const VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV = 1000455028;
export const VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV = 1000455029;
export const VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV = 1000455030;
export const VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV = 1000455031;
export const VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV = 1000455032;
export const VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT = 1000524000;
export const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0;
export const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1;
export const VK_OBJECT_TYPE_UNKNOWN = 0;
export const VK_OBJECT_TYPE_INSTANCE = 1;
export const VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2;
export const VK_OBJECT_TYPE_DEVICE = 3;
export const VK_OBJECT_TYPE_QUEUE = 4;
export const VK_OBJECT_TYPE_SEMAPHORE = 5;
export const VK_OBJECT_TYPE_COMMAND_BUFFER = 6;
export const VK_OBJECT_TYPE_FENCE = 7;
export const VK_OBJECT_TYPE_DEVICE_MEMORY = 8;
export const VK_OBJECT_TYPE_BUFFER = 9;
export const VK_OBJECT_TYPE_IMAGE = 10;
export const VK_OBJECT_TYPE_EVENT = 11;
export const VK_OBJECT_TYPE_QUERY_POOL = 12;
export const VK_OBJECT_TYPE_BUFFER_VIEW = 13;
export const VK_OBJECT_TYPE_IMAGE_VIEW = 14;
export const VK_OBJECT_TYPE_SHADER_MODULE = 15;
export const VK_OBJECT_TYPE_PIPELINE_CACHE = 16;
export const VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17;
export const VK_OBJECT_TYPE_RENDER_PASS = 18;
export const VK_OBJECT_TYPE_PIPELINE = 19;
export const VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20;
export const VK_OBJECT_TYPE_SAMPLER = 21;
export const VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22;
export const VK_OBJECT_TYPE_DESCRIPTOR_SET = 23;
export const VK_OBJECT_TYPE_FRAMEBUFFER = 24;
export const VK_OBJECT_TYPE_COMMAND_POOL = 25;
export const VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 1000156000;
export const VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 1000085000;
export const VK_OBJECT_TYPE_PRIVATE_DATA_SLOT = 1000295000;
export const VK_OBJECT_TYPE_SURFACE_KHR = 1000000000;
export const VK_OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000;
export const VK_OBJECT_TYPE_DISPLAY_KHR = 1000002000;
export const VK_OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001;
export const VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000;
export const VK_OBJECT_TYPE_VIDEO_SESSION_KHR = 1000023000;
export const VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR = 1000023001;
export const VK_OBJECT_TYPE_CU_MODULE_NVX = 1000029000;
export const VK_OBJECT_TYPE_CU_FUNCTION_NVX = 1000029001;
export const VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = 1000128000;
export const VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000;
export const VK_OBJECT_TYPE_VALIDATION_CACHE_EXT = 1000160000;
export const VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000;
export const VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL = 1000210000;
export const VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR = 1000268000;
export const VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV = 1000277000;
export const VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA = 1000366000;
export const VK_OBJECT_TYPE_MICROMAP_EXT = 1000396000;
export const VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV = 1000464000;
export const VK_OBJECT_TYPE_SHADER_EXT = 1000482000;
export const VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV = 1000489000;
export const VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV = 0;
export const VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV = 1;
export const VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG = 0;
export const VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG = 1;
export const VK_SEMAPHORE_TYPE_BINARY = 0;
export const VK_SEMAPHORE_TYPE_TIMELINE = 1;
export const VK_PRESENT_MODE_IMMEDIATE_KHR = 0;
export const VK_PRESENT_MODE_MAILBOX_KHR = 1;
export const VK_PRESENT_MODE_FIFO_KHR = 2;
export const VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3;
export const VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000;
export const VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001;
export const VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0;
export const VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001;
export const VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002;
export const VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = 1000104003;
export const VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004;
export const VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005;
export const VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006;
export const VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007;
export const VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008;
export const VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009;
export const VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010;
export const VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011;
export const VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012;
export const VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013;
export const VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014;
export const VK_COLOR_SPACE_DISPLAY_NATIVE_AMD = 1000213000;
export const VK_TIME_DOMAIN_DEVICE_EXT = 0;
export const VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT = 1;
export const VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT = 2;
export const VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT = 3;
export const VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0;
export const VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1;
export const VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2;
export const VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3;
export const VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4;
export const VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5;
export const VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6;
export const VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7;
export const VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8;
export const VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9;
export const VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10;
export const VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11;
export const VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12;
export const VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13;
export const VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14;
export const VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15;
export const VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16;
export const VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17;
export const VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18;
export const VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19;
export const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20;
export const VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21;
export const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22;
export const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23;
export const VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24;
export const VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25;
export const VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26;
export const VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27;
export const VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28;
export const VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29;
export const VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30;
export const VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33;
export const VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000;
export const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000;
export const VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT = 1000029000;
export const VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT = 1000029001;
export const VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT = 1000150000;
export const VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = 1000165000;
export const VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT = 1000366000;
export const VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT = 0;
export const VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT = 1;
export const VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT = 2;
export const VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT = 3;
export const VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT = 4;
export const VK_RASTERIZATION_ORDER_STRICT_AMD = 0;
export const VK_RASTERIZATION_ORDER_RELAXED_AMD = 1;
export const VK_VALIDATION_CHECK_ALL_EXT = 0;
export const VK_VALIDATION_CHECK_SHADERS_EXT = 1;
export const VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = 0;
export const VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1;
export const VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT = 2;
export const VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT = 3;
export const VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT = 4;
export const VK_VALIDATION_FEATURE_DISABLE_ALL_EXT = 0;
export const VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 1;
export const VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 2;
export const VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 3;
export const VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 4;
export const VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 5;
export const VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 6;
export const VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT = 7;
export const VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV = 0;
export const VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV = 1;
export const VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV = 2;
export const VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV = 3;
export const VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV = 4;
export const VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV = 5;
export const VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV = 6;
export const VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV = 7;
export const VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV = 1000328000;
export const VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV = 1000428003;
export const VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV = 1000428004;
export const VK_DISPLAY_POWER_STATE_OFF_EXT = 0;
export const VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1;
export const VK_DISPLAY_POWER_STATE_ON_EXT = 2;
export const VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0;
export const VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0;
export const VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0;
export const VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1;
export const VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2;
export const VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3;
export const VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4;
export const VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5;
export const VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6;
export const VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7;
export const VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0;
export const VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1;
export const VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0;
export const VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1;
export const VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE = 0;
export const VK_SAMPLER_REDUCTION_MODE_MIN = 1;
export const VK_SAMPLER_REDUCTION_MODE_MAX = 2;
export const VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0;
export const VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1;
export const VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0;
export const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1;
export const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2;
export const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3;
export const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4;
export const VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0;
export const VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 1;
export const VK_CHROMA_LOCATION_COSITED_EVEN = 0;
export const VK_CHROMA_LOCATION_MIDPOINT = 1;
export const VK_BLEND_OVERLAP_UNCORRELATED_EXT = 0;
export const VK_BLEND_OVERLAP_DISJOINT_EXT = 1;
export const VK_BLEND_OVERLAP_CONJOINT_EXT = 2;
export const VK_COVERAGE_MODULATION_MODE_NONE_NV = 0;
export const VK_COVERAGE_MODULATION_MODE_RGB_NV = 1;
export const VK_COVERAGE_MODULATION_MODE_ALPHA_NV = 2;
export const VK_COVERAGE_MODULATION_MODE_RGBA_NV = 3;
export const VK_COVERAGE_REDUCTION_MODE_MERGE_NV = 0;
export const VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV = 1;
export const VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 1;
export const VK_SHADER_INFO_TYPE_STATISTICS_AMD = 0;
export const VK_SHADER_INFO_TYPE_BINARY_AMD = 1;
export const VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD = 2;
export const VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR = 128;
export const VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR = 256;
export const VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR = 512;
export const VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR = 1024;
export const VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = 0;
export const VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = 1;
export const VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = 2;
export const VK_VENDOR_ID_VIV = 0x10001;
export const VK_VENDOR_ID_VSI = 0x10002;
export const VK_VENDOR_ID_KAZAN = 0x10003;
export const VK_VENDOR_ID_CODEPLAY = 0x10004;
export const VK_VENDOR_ID_MESA = 0x10005;
export const VK_VENDOR_ID_POCL = 0x10006;
export const VK_VENDOR_ID_MOBILEYE = 0x10007;
export const VK_DRIVER_ID_AMD_PROPRIETARY = 1;
export const VK_DRIVER_ID_AMD_OPEN_SOURCE = 2;
export const VK_DRIVER_ID_MESA_RADV = 3;
export const VK_DRIVER_ID_NVIDIA_PROPRIETARY = 4;
export const VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = 5;
export const VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA = 6;
export const VK_DRIVER_ID_IMAGINATION_PROPRIETARY = 7;
export const VK_DRIVER_ID_QUALCOMM_PROPRIETARY = 8;
export const VK_DRIVER_ID_ARM_PROPRIETARY = 9;
export const VK_DRIVER_ID_GOOGLE_SWIFTSHADER = 10;
export const VK_DRIVER_ID_GGP_PROPRIETARY = 11;
export const VK_DRIVER_ID_BROADCOM_PROPRIETARY = 12;
export const VK_DRIVER_ID_MESA_LLVMPIPE = 13;
export const VK_DRIVER_ID_MOLTENVK = 14;
export const VK_DRIVER_ID_COREAVI_PROPRIETARY = 15;
export const VK_DRIVER_ID_JUICE_PROPRIETARY = 16;
export const VK_DRIVER_ID_VERISILICON_PROPRIETARY = 17;
export const VK_DRIVER_ID_MESA_TURNIP = 18;
export const VK_DRIVER_ID_MESA_V3DV = 19;
export const VK_DRIVER_ID_MESA_PANVK = 20;
export const VK_DRIVER_ID_SAMSUNG_PROPRIETARY = 21;
export const VK_DRIVER_ID_MESA_VENUS = 22;
export const VK_DRIVER_ID_MESA_DOZEN = 23;
export const VK_DRIVER_ID_MESA_NVK = 24;
export const VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA = 25;
export const VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV = 0;
export const VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV = 1;
export const VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV = 2;
export const VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV = 3;
export const VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV = 4;
export const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV = 5;
export const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV = 6;
export const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV = 7;
export const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV = 8;
export const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV = 9;
export const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV = 10;
export const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV = 11;
export const VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV = 0;
export const VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV = 1;
export const VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV = 2;
export const VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV = 3;
export const VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR = 0;
export const VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR = 1;
export const VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR = 2;
export const VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR = 3;
export const VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR = 0;
export const VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR = 1;
export const VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR = 0;
export const VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR = 1;
export const VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR = 2;
export const VK_GEOMETRY_TYPE_TRIANGLES_KHR = 0;
export const VK_GEOMETRY_TYPE_AABBS_KHR = 1;
export const VK_GEOMETRY_TYPE_INSTANCES_KHR = 2;
export const VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV = 0;
export const VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV = 1;
export const VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV = 2;
export const VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR = 0;
export const VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR = 1;
export const VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR = 2;
export const VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR = 0;
export const VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR = 1;
export const VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR = 2;
export const VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR = 0;
export const VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR = 1;
export const VK_SHADER_GROUP_SHADER_GENERAL_KHR = 0;
export const VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR = 1;
export const VK_SHADER_GROUP_SHADER_ANY_HIT_KHR = 2;
export const VK_SHADER_GROUP_SHADER_INTERSECTION_KHR = 3;
export const VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = 0;
export const VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = 1;
export const VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = 2;
export const VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT = 0;
export const VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT = 1;
export const VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT = 2;
export const VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT = 3;
export const VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR = 0;
export const VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR = 1;
export const VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR = 2;
export const VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = 0;
export const VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = 1;
export const VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = 2;
export const VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR = 3;
export const VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = 4;
export const VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = 5;
export const VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR = 6;
export const VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = 7;
export const VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR = 8;
export const VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = 9;
export const VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = 10;
export const VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0;
export const VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 1;
export const VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 2;
export const VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 3;
export const VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 4;
export const VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 5;
export const VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = 0;
export const VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL = 0;
export const VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL = 0;
export const VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL = 1;
export const VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL = 0;
export const VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL = 1;
export const VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL = 0;
export const VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL = 1;
export const VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL = 2;
export const VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL = 3;
export const VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL = 4;
export const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY = 0;
export const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL = 1;
export const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE = 2;
export const VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR = 0;
export const VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR = 1;
export const VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR = 2;
export const VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR = 3;
export const VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = 0;
export const VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = 1;
export const VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = 2;
export const VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = 3;
export const VK_FAULT_LEVEL_UNASSIGNED = 0;
export const VK_FAULT_LEVEL_CRITICAL = 1;
export const VK_FAULT_LEVEL_RECOVERABLE = 2;
export const VK_FAULT_LEVEL_WARNING = 3;
export const VK_FAULT_TYPE_INVALID = 0;
export const VK_FAULT_TYPE_UNASSIGNED = 1;
export const VK_FAULT_TYPE_IMPLEMENTATION = 2;
export const VK_FAULT_TYPE_SYSTEM = 3;
export const VK_FAULT_TYPE_PHYSICAL_DEVICE = 4;
export const VK_FAULT_TYPE_COMMAND_BUFFER_FULL = 5;
export const VK_FAULT_TYPE_INVALID_API_USAGE = 6;
export const VK_FAULT_QUERY_BEHAVIOR_GET_AND_CLEAR_ALL_FAULTS = 0;
export const VK_PIPELINE_MATCH_CONTROL_APPLICATION_UUID_EXACT_MATCH = 0;
export const VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR = 0;
export const VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR = 1;
export const VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR = 2;
export const VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR = 3;
export const VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR = 4;
export const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = 0;
export const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = 1;
export const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = 4;
export const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = 5;
export const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = 6;
export const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = 9;
export const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = 10;
export const VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = 11;
export const VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = 12;
export const VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = 13;
export const VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = 14;
export const VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV = 15;
export const VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV = 0;
export const VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV = 1;
export const VK_SUBPASS_MERGE_STATUS_MERGED_EXT = 0;
export const VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT = 1;
export const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT = 2;
export const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT = 3;
export const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT = 4;
export const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT = 5;
export const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT = 6;
export const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT = 7;
export const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT = 8;
export const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT = 9;
export const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT = 10;
export const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT = 11;
export const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT = 12;
export const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT = 13;
export const VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_NV = 0;
export const VK_SCI_SYNC_CLIENT_TYPE_WAITER_NV = 1;
export const VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_WAITER_NV = 2;
export const VK_SCI_SYNC_PRIMITIVE_TYPE_FENCE_NV = 0;
export const VK_SCI_SYNC_PRIMITIVE_TYPE_SEMAPHORE_NV = 1;
export const VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT = 0;
export const VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT = 1;
export const VK_PIPELINE_CACHE_VALIDATION_VERSION_SAFETY_CRITICAL_ONE = 1;
export const VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV = 0;
export const VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV = 1;
export const VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV = 2;
export const VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT = 0;
export const VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT = 1;
export const VK_QUERY_RESULT_STATUS_ERROR_KHR = -1;
export const VK_QUERY_RESULT_STATUS_NOT_READY_KHR = 0;
export const VK_QUERY_RESULT_STATUS_COMPLETE_KHR = 1;
export const VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR = 0;
export const VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR = 1;
export const VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR = 2;
export const VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR = 3;
export const VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR = 4;
export const VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT = 0;
export const VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT = 1;
export const VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT = 2;
export const VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT = 3;
export const VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT = 0;
export const VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT = 1;
export const VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT = 2;
export const VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT = 3;
export const VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV = 0;
export const VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV = 1;
export const VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV = 2;
export const VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV = 3;
export const VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV = 0;
export const VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV = 1;
export const VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV = 2;
export const VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV = 3;
export const VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV = 4;
export const VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV = 5;
export const VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV = 6;
export const VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV = 7;
export const VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV = 8;
export const VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT = 0;
export const VK_MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV = 1000397000;
export const VK_COPY_MICROMAP_MODE_CLONE_EXT = 0;
export const VK_COPY_MICROMAP_MODE_SERIALIZE_EXT = 1;
export const VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT = 2;
export const VK_COPY_MICROMAP_MODE_COMPACT_EXT = 3;
export const VK_BUILD_MICROMAP_MODE_BUILD_EXT = 0;
export const VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT = 1;
export const VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT = 2;
export const VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT = -1;
export const VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT = -2;
export const VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT = -3;
export const VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT = -4;
export const VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT = 0;
export const VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT = 1;
export const VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT = 2;
export const VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT = 0;
export const VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT = 1;
export const VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT = 2;
export const VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT = 3;
export const VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT = 4;
export const VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT = 5;
export const VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT = 6;
export const VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT = 1;
export const VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV = 1;
export const VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV = 2;
export const VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV = 3;
export const VK_SHADER_CODE_TYPE_BINARY_EXT = 0;
export const VK_SHADER_CODE_TYPE_SPIRV_EXT = 1;
export const VK_SCOPE_DEVICE_KHR = 1;
export const VK_SCOPE_WORKGROUP_KHR = 2;
export const VK_SCOPE_SUBGROUP_KHR = 3;
export const VK_SCOPE_QUEUE_FAMILY_KHR = 5;
export const VK_COMPONENT_TYPE_FLOAT16_KHR = 0;
export const VK_COMPONENT_TYPE_FLOAT32_KHR = 1;
export const VK_COMPONENT_TYPE_FLOAT64_KHR = 2;
export const VK_COMPONENT_TYPE_SINT8_KHR = 3;
export const VK_COMPONENT_TYPE_SINT16_KHR = 4;
export const VK_COMPONENT_TYPE_SINT32_KHR = 5;
export const VK_COMPONENT_TYPE_SINT64_KHR = 6;
export const VK_COMPONENT_TYPE_UINT8_KHR = 7;
export const VK_COMPONENT_TYPE_UINT16_KHR = 8;
export const VK_COMPONENT_TYPE_UINT32_KHR = 9;
export const VK_COMPONENT_TYPE_UINT64_KHR = 10;

export enum VkImageLayout{
  VK_IMAGE_LAYOUT_UNDEFINED = 0,
  VK_IMAGE_LAYOUT_GENERAL = 1,
  VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
  VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
  VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
  VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
  VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
  VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
  VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
  VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
  VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
  VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 1000241000,
  VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 1000241001,
  VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 1000241002,
  VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003,
  VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL = 1000314000,
  VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL = 1000314001,
  VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
  VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR = 1000024000,
  VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR = 1000024001,
  VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR = 1000024002,
  VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000,
  VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000,
  VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003,
  VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR = 1000299000,
  VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR = 1000299001,
  VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR = 1000299002,
  VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT = 1000339000,
}
export enum VkAttachmentLoadOp{
  VK_ATTACHMENT_LOAD_OP_LOAD = 0,
  VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
  VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
  VK_ATTACHMENT_LOAD_OP_NONE_EXT = 1000400000,
}
export enum VkAttachmentStoreOp{
  VK_ATTACHMENT_STORE_OP_STORE = 0,
  VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
  VK_ATTACHMENT_STORE_OP_NONE = 1000301000,
}
export enum VkImageType{
  VK_IMAGE_TYPE_1D = 0,
  VK_IMAGE_TYPE_2D = 1,
  VK_IMAGE_TYPE_3D = 2,
}
export enum VkImageTiling{
  VK_IMAGE_TILING_OPTIMAL = 0,
  VK_IMAGE_TILING_LINEAR = 1,
  VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000,
}
export enum VkImageViewType{
  VK_IMAGE_VIEW_TYPE_1D = 0,
  VK_IMAGE_VIEW_TYPE_2D = 1,
  VK_IMAGE_VIEW_TYPE_3D = 2,
  VK_IMAGE_VIEW_TYPE_CUBE = 3,
  VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
  VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
  VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
}
export enum VkCommandBufferLevel{
  VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
  VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
}
export enum VkComponentSwizzle{
  VK_COMPONENT_SWIZZLE_IDENTITY = 0,
  VK_COMPONENT_SWIZZLE_ZERO = 1,
  VK_COMPONENT_SWIZZLE_ONE = 2,
  VK_COMPONENT_SWIZZLE_R = 3,
  VK_COMPONENT_SWIZZLE_G = 4,
  VK_COMPONENT_SWIZZLE_B = 5,
  VK_COMPONENT_SWIZZLE_A = 6,
}
export enum VkDescriptorType{
  VK_DESCRIPTOR_TYPE_SAMPLER = 0,
  VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
  VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
  VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
  VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
  VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
  VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
  VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
  VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
  VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK = 1000138000,
  VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
  VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
  VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM = 1000440000,
  VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM = 1000440001,
  VK_DESCRIPTOR_TYPE_MUTABLE_EXT = 1000351000,
}
export enum VkQueryType{
  VK_QUERY_TYPE_OCCLUSION = 0,
  VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
  VK_QUERY_TYPE_TIMESTAMP = 2,
  VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR = 1000023000,
  VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT = 1000028004,
  VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR = 1000116000,
  VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR = 1000150000,
  VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR = 1000150001,
  VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV = 1000165000,
  VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL = 1000210000,
  VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR = 1000299000,
  VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT = 1000328000,
  VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT = 1000382000,
  VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR = 1000386000,
  VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR = 1000386001,
  VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT = 1000396000,
  VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT = 1000396001,
}
export enum VkBorderColor{
  VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
  VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
  VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
  VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
  VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
  VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
  VK_BORDER_COLOR_FLOAT_CUSTOM_EXT = 1000287003,
  VK_BORDER_COLOR_INT_CUSTOM_EXT = 1000287004,
}
export enum VkPipelineBindPoint{
  VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
  VK_PIPELINE_BIND_POINT_COMPUTE = 1,
  VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX = 1000134000,
  VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR = 1000165000,
  VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI = 1000369003,
}
export enum VkPipelineCacheHeaderVersion{
  VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
}
export enum VkPrimitiveTopology{
  VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
  VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
  VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
  VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
  VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
  VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
}
export enum VkSharingMode{
  VK_SHARING_MODE_EXCLUSIVE = 0,
  VK_SHARING_MODE_CONCURRENT = 1,
}
export enum VkIndexType{
  VK_INDEX_TYPE_UINT16 = 0,
  VK_INDEX_TYPE_UINT32 = 1,
  VK_INDEX_TYPE_NONE_KHR = 1000165000,
  VK_INDEX_TYPE_UINT8_EXT = 1000265000,
}
export enum VkFilter{
  VK_FILTER_NEAREST = 0,
  VK_FILTER_LINEAR = 1,
  VK_FILTER_CUBIC_EXT = 1000015000,
}
export enum VkSamplerMipmapMode{
  VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
  VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
}
export enum VkSamplerAddressMode{
  VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
  VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
  VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
  VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
  VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
}
export enum VkCompareOp{
  VK_COMPARE_OP_NEVER = 0,
  VK_COMPARE_OP_LESS = 1,
  VK_COMPARE_OP_EQUAL = 2,
  VK_COMPARE_OP_LESS_OR_EQUAL = 3,
  VK_COMPARE_OP_GREATER = 4,
  VK_COMPARE_OP_NOT_EQUAL = 5,
  VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
  VK_COMPARE_OP_ALWAYS = 7,
}
export enum VkPolygonMode{
  VK_POLYGON_MODE_FILL = 0,
  VK_POLYGON_MODE_LINE = 1,
  VK_POLYGON_MODE_POINT = 2,
  VK_POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000,
}
export enum VkFrontFace{
  VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
  VK_FRONT_FACE_CLOCKWISE = 1,
}
export enum VkBlendFactor{
  VK_BLEND_FACTOR_ZERO = 0,
  VK_BLEND_FACTOR_ONE = 1,
  VK_BLEND_FACTOR_SRC_COLOR = 2,
  VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
  VK_BLEND_FACTOR_DST_COLOR = 4,
  VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
  VK_BLEND_FACTOR_SRC_ALPHA = 6,
  VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
  VK_BLEND_FACTOR_DST_ALPHA = 8,
  VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
  VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
  VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
  VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
  VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
  VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
  VK_BLEND_FACTOR_SRC1_COLOR = 15,
  VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
  VK_BLEND_FACTOR_SRC1_ALPHA = 17,
  VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
}
export enum VkBlendOp{
  VK_BLEND_OP_ADD = 0,
  VK_BLEND_OP_SUBTRACT = 1,
  VK_BLEND_OP_REVERSE_SUBTRACT = 2,
  VK_BLEND_OP_MIN = 3,
  VK_BLEND_OP_MAX = 4,
  VK_BLEND_OP_ZERO_EXT = 1000148000,
  VK_BLEND_OP_SRC_EXT = 1000148001,
  VK_BLEND_OP_DST_EXT = 1000148002,
  VK_BLEND_OP_SRC_OVER_EXT = 1000148003,
  VK_BLEND_OP_DST_OVER_EXT = 1000148004,
  VK_BLEND_OP_SRC_IN_EXT = 1000148005,
  VK_BLEND_OP_DST_IN_EXT = 1000148006,
  VK_BLEND_OP_SRC_OUT_EXT = 1000148007,
  VK_BLEND_OP_DST_OUT_EXT = 1000148008,
  VK_BLEND_OP_SRC_ATOP_EXT = 1000148009,
  VK_BLEND_OP_DST_ATOP_EXT = 1000148010,
  VK_BLEND_OP_XOR_EXT = 1000148011,
  VK_BLEND_OP_MULTIPLY_EXT = 1000148012,
  VK_BLEND_OP_SCREEN_EXT = 1000148013,
  VK_BLEND_OP_OVERLAY_EXT = 1000148014,
  VK_BLEND_OP_DARKEN_EXT = 1000148015,
  VK_BLEND_OP_LIGHTEN_EXT = 1000148016,
  VK_BLEND_OP_COLORDODGE_EXT = 1000148017,
  VK_BLEND_OP_COLORBURN_EXT = 1000148018,
  VK_BLEND_OP_HARDLIGHT_EXT = 1000148019,
  VK_BLEND_OP_SOFTLIGHT_EXT = 1000148020,
  VK_BLEND_OP_DIFFERENCE_EXT = 1000148021,
  VK_BLEND_OP_EXCLUSION_EXT = 1000148022,
  VK_BLEND_OP_INVERT_EXT = 1000148023,
  VK_BLEND_OP_INVERT_RGB_EXT = 1000148024,
  VK_BLEND_OP_LINEARDODGE_EXT = 1000148025,
  VK_BLEND_OP_LINEARBURN_EXT = 1000148026,
  VK_BLEND_OP_VIVIDLIGHT_EXT = 1000148027,
  VK_BLEND_OP_LINEARLIGHT_EXT = 1000148028,
  VK_BLEND_OP_PINLIGHT_EXT = 1000148029,
  VK_BLEND_OP_HARDMIX_EXT = 1000148030,
  VK_BLEND_OP_HSL_HUE_EXT = 1000148031,
  VK_BLEND_OP_HSL_SATURATION_EXT = 1000148032,
  VK_BLEND_OP_HSL_COLOR_EXT = 1000148033,
  VK_BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034,
  VK_BLEND_OP_PLUS_EXT = 1000148035,
  VK_BLEND_OP_PLUS_CLAMPED_EXT = 1000148036,
  VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037,
  VK_BLEND_OP_PLUS_DARKER_EXT = 1000148038,
  VK_BLEND_OP_MINUS_EXT = 1000148039,
  VK_BLEND_OP_MINUS_CLAMPED_EXT = 1000148040,
  VK_BLEND_OP_CONTRAST_EXT = 1000148041,
  VK_BLEND_OP_INVERT_OVG_EXT = 1000148042,
  VK_BLEND_OP_RED_EXT = 1000148043,
  VK_BLEND_OP_GREEN_EXT = 1000148044,
  VK_BLEND_OP_BLUE_EXT = 1000148045,
}
export enum VkStencilOp{
  VK_STENCIL_OP_KEEP = 0,
  VK_STENCIL_OP_ZERO = 1,
  VK_STENCIL_OP_REPLACE = 2,
  VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
  VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
  VK_STENCIL_OP_INVERT = 5,
  VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
  VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
}
export enum VkLogicOp{
  VK_LOGIC_OP_CLEAR = 0,
  VK_LOGIC_OP_AND = 1,
  VK_LOGIC_OP_AND_REVERSE = 2,
  VK_LOGIC_OP_COPY = 3,
  VK_LOGIC_OP_AND_INVERTED = 4,
  VK_LOGIC_OP_NO_OP = 5,
  VK_LOGIC_OP_XOR = 6,
  VK_LOGIC_OP_OR = 7,
  VK_LOGIC_OP_NOR = 8,
  VK_LOGIC_OP_EQUIVALENT = 9,
  VK_LOGIC_OP_INVERT = 10,
  VK_LOGIC_OP_OR_REVERSE = 11,
  VK_LOGIC_OP_COPY_INVERTED = 12,
  VK_LOGIC_OP_OR_INVERTED = 13,
  VK_LOGIC_OP_NAND = 14,
  VK_LOGIC_OP_SET = 15,
}
export enum VkInternalAllocationType{
  VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
}
export enum VkSystemAllocationScope{
  VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
  VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
  VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
  VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
  VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
}
export enum VkPhysicalDeviceType{
  VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
  VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
  VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
  VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
  VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
}
export enum VkVertexInputRate{
  VK_VERTEX_INPUT_RATE_VERTEX = 0,
  VK_VERTEX_INPUT_RATE_INSTANCE = 1,
}
export enum VkFormat{
  VK_FORMAT_UNDEFINED = 0,
  VK_FORMAT_R4G4_UNORM_PACK8 = 1,
  VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
  VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
  VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
  VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
  VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
  VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
  VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
  VK_FORMAT_R8_UNORM = 9,
  VK_FORMAT_R8_SNORM = 10,
  VK_FORMAT_R8_USCALED = 11,
  VK_FORMAT_R8_SSCALED = 12,
  VK_FORMAT_R8_UINT = 13,
  VK_FORMAT_R8_SINT = 14,
  VK_FORMAT_R8_SRGB = 15,
  VK_FORMAT_R8G8_UNORM = 16,
  VK_FORMAT_R8G8_SNORM = 17,
  VK_FORMAT_R8G8_USCALED = 18,
  VK_FORMAT_R8G8_SSCALED = 19,
  VK_FORMAT_R8G8_UINT = 20,
  VK_FORMAT_R8G8_SINT = 21,
  VK_FORMAT_R8G8_SRGB = 22,
  VK_FORMAT_R8G8B8_UNORM = 23,
  VK_FORMAT_R8G8B8_SNORM = 24,
  VK_FORMAT_R8G8B8_USCALED = 25,
  VK_FORMAT_R8G8B8_SSCALED = 26,
  VK_FORMAT_R8G8B8_UINT = 27,
  VK_FORMAT_R8G8B8_SINT = 28,
  VK_FORMAT_R8G8B8_SRGB = 29,
  VK_FORMAT_B8G8R8_UNORM = 30,
  VK_FORMAT_B8G8R8_SNORM = 31,
  VK_FORMAT_B8G8R8_USCALED = 32,
  VK_FORMAT_B8G8R8_SSCALED = 33,
  VK_FORMAT_B8G8R8_UINT = 34,
  VK_FORMAT_B8G8R8_SINT = 35,
  VK_FORMAT_B8G8R8_SRGB = 36,
  VK_FORMAT_R8G8B8A8_UNORM = 37,
  VK_FORMAT_R8G8B8A8_SNORM = 38,
  VK_FORMAT_R8G8B8A8_USCALED = 39,
  VK_FORMAT_R8G8B8A8_SSCALED = 40,
  VK_FORMAT_R8G8B8A8_UINT = 41,
  VK_FORMAT_R8G8B8A8_SINT = 42,
  VK_FORMAT_R8G8B8A8_SRGB = 43,
  VK_FORMAT_B8G8R8A8_UNORM = 44,
  VK_FORMAT_B8G8R8A8_SNORM = 45,
  VK_FORMAT_B8G8R8A8_USCALED = 46,
  VK_FORMAT_B8G8R8A8_SSCALED = 47,
  VK_FORMAT_B8G8R8A8_UINT = 48,
  VK_FORMAT_B8G8R8A8_SINT = 49,
  VK_FORMAT_B8G8R8A8_SRGB = 50,
  VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
  VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
  VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
  VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
  VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
  VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
  VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
  VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
  VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
  VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
  VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
  VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
  VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
  VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
  VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
  VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
  VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
  VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
  VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
  VK_FORMAT_R16_UNORM = 70,
  VK_FORMAT_R16_SNORM = 71,
  VK_FORMAT_R16_USCALED = 72,
  VK_FORMAT_R16_SSCALED = 73,
  VK_FORMAT_R16_UINT = 74,
  VK_FORMAT_R16_SINT = 75,
  VK_FORMAT_R16_SFLOAT = 76,
  VK_FORMAT_R16G16_UNORM = 77,
  VK_FORMAT_R16G16_SNORM = 78,
  VK_FORMAT_R16G16_USCALED = 79,
  VK_FORMAT_R16G16_SSCALED = 80,
  VK_FORMAT_R16G16_UINT = 81,
  VK_FORMAT_R16G16_SINT = 82,
  VK_FORMAT_R16G16_SFLOAT = 83,
  VK_FORMAT_R16G16B16_UNORM = 84,
  VK_FORMAT_R16G16B16_SNORM = 85,
  VK_FORMAT_R16G16B16_USCALED = 86,
  VK_FORMAT_R16G16B16_SSCALED = 87,
  VK_FORMAT_R16G16B16_UINT = 88,
  VK_FORMAT_R16G16B16_SINT = 89,
  VK_FORMAT_R16G16B16_SFLOAT = 90,
  VK_FORMAT_R16G16B16A16_UNORM = 91,
  VK_FORMAT_R16G16B16A16_SNORM = 92,
  VK_FORMAT_R16G16B16A16_USCALED = 93,
  VK_FORMAT_R16G16B16A16_SSCALED = 94,
  VK_FORMAT_R16G16B16A16_UINT = 95,
  VK_FORMAT_R16G16B16A16_SINT = 96,
  VK_FORMAT_R16G16B16A16_SFLOAT = 97,
  VK_FORMAT_R32_UINT = 98,
  VK_FORMAT_R32_SINT = 99,
  VK_FORMAT_R32_SFLOAT = 100,
  VK_FORMAT_R32G32_UINT = 101,
  VK_FORMAT_R32G32_SINT = 102,
  VK_FORMAT_R32G32_SFLOAT = 103,
  VK_FORMAT_R32G32B32_UINT = 104,
  VK_FORMAT_R32G32B32_SINT = 105,
  VK_FORMAT_R32G32B32_SFLOAT = 106,
  VK_FORMAT_R32G32B32A32_UINT = 107,
  VK_FORMAT_R32G32B32A32_SINT = 108,
  VK_FORMAT_R32G32B32A32_SFLOAT = 109,
  VK_FORMAT_R64_UINT = 110,
  VK_FORMAT_R64_SINT = 111,
  VK_FORMAT_R64_SFLOAT = 112,
  VK_FORMAT_R64G64_UINT = 113,
  VK_FORMAT_R64G64_SINT = 114,
  VK_FORMAT_R64G64_SFLOAT = 115,
  VK_FORMAT_R64G64B64_UINT = 116,
  VK_FORMAT_R64G64B64_SINT = 117,
  VK_FORMAT_R64G64B64_SFLOAT = 118,
  VK_FORMAT_R64G64B64A64_UINT = 119,
  VK_FORMAT_R64G64B64A64_SINT = 120,
  VK_FORMAT_R64G64B64A64_SFLOAT = 121,
  VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
  VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
  VK_FORMAT_D16_UNORM = 124,
  VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
  VK_FORMAT_D32_SFLOAT = 126,
  VK_FORMAT_S8_UINT = 127,
  VK_FORMAT_D16_UNORM_S8_UINT = 128,
  VK_FORMAT_D24_UNORM_S8_UINT = 129,
  VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
  VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
  VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
  VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
  VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
  VK_FORMAT_BC2_UNORM_BLOCK = 135,
  VK_FORMAT_BC2_SRGB_BLOCK = 136,
  VK_FORMAT_BC3_UNORM_BLOCK = 137,
  VK_FORMAT_BC3_SRGB_BLOCK = 138,
  VK_FORMAT_BC4_UNORM_BLOCK = 139,
  VK_FORMAT_BC4_SNORM_BLOCK = 140,
  VK_FORMAT_BC5_UNORM_BLOCK = 141,
  VK_FORMAT_BC5_SNORM_BLOCK = 142,
  VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
  VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
  VK_FORMAT_BC7_UNORM_BLOCK = 145,
  VK_FORMAT_BC7_SRGB_BLOCK = 146,
  VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
  VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
  VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
  VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
  VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
  VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
  VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
  VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
  VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
  VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
  VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
  VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
  VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
  VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
  VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
  VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
  VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
  VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
  VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
  VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
  VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
  VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
  VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
  VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
  VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
  VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
  VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
  VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
  VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
  VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
  VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
  VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
  VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
  VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
  VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
  VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
  VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
  VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
  VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000,
  VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001,
  VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
  VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
  VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
  VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
  VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
  VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007,
  VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
  VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
  VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
  VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
  VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
  VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
  VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
  VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
  VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
  VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017,
  VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
  VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
  VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
  VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
  VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
  VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
  VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
  VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
  VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
  VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027,
  VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028,
  VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
  VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
  VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
  VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
  VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
  VK_FORMAT_G8_B8R8_2PLANE_444_UNORM = 1000330000,
  VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 = 1000330001,
  VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 = 1000330002,
  VK_FORMAT_G16_B16R16_2PLANE_444_UNORM = 1000330003,
  VK_FORMAT_A4R4G4B4_UNORM_PACK16 = 1000340000,
  VK_FORMAT_A4B4G4R4_UNORM_PACK16 = 1000340001,
  VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK = 1000066000,
  VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK = 1000066001,
  VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK = 1000066002,
  VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK = 1000066003,
  VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK = 1000066004,
  VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK = 1000066005,
  VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK = 1000066006,
  VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK = 1000066007,
  VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK = 1000066008,
  VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK = 1000066009,
  VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK = 1000066010,
  VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK = 1000066011,
  VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK = 1000066012,
  VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK = 1000066013,
  VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
  VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
  VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
  VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
  VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
  VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
  VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
  VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
  VK_FORMAT_R16G16_S10_5_NV = 1000464000,
  VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR = 1000470000,
  VK_FORMAT_A8_UNORM_KHR = 1000470001,
}
export enum VkStructureType{
  VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
  VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
  VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
  VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
  VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
  VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
  VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
  VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
  VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
  VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
  VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
  VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
  VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
  VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
  VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
  VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
  VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
  VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
  VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
  VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
  VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
  VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
  VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
  VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
  VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
  VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
  VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
  VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
  VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
  VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
  VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
  VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
  VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
  VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
  VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
  VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
  VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
  VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
  VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
  VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
  VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
  VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
  VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
  VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
  VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
  VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
  VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
  VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
  VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
  VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
  VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003,
  VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
  VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002,
  VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
  VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
  VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
  VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
  VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
  VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000,
  VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
  VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003,
  VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
  VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
  VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
  VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
  VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
  VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
  VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
  VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
  VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
  VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
  VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
  VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
  VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
  VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
  VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000,
  VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO = 1000147000,
  VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 = 1000109000,
  VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 = 1000109001,
  VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 = 1000109002,
  VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 = 1000109003,
  VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 = 1000109004,
  VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO = 1000109005,
  VK_STRUCTURE_TYPE_SUBPASS_END_INFO = 1000109006,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES = 1000177000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES = 1000196000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES = 1000180000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES = 1000082000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES = 1000197000,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES = 1000161001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES = 1000161002,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO = 1000161003,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT = 1000161004,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES = 1000199000,
  VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE = 1000199001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES = 1000221000,
  VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO = 1000246000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 1000130000,
  VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO = 1000130001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES = 1000211000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 1000108000,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 1000108001,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 1000108002,
  VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO = 1000108003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES = 1000253000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES = 1000175000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES = 1000241000,
  VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT = 1000241001,
  VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT = 1000241002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES = 1000261000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES = 1000207000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES = 1000207001,
  VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO = 1000207002,
  VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO = 1000207003,
  VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO = 1000207004,
  VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO = 1000207005,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES = 1000257000,
  VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO = 1000244001,
  VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 1000257002,
  VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 1000257003,
  VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 1000257004,
  VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO = 1000192000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES = 1000215000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES = 1000245000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES = 1000276000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES = 1000295000,
  VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO = 1000295001,
  VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO = 1000295002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES = 1000297000,
  VK_STRUCTURE_TYPE_MEMORY_BARRIER_2 = 1000314000,
  VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2 = 1000314001,
  VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2 = 1000314002,
  VK_STRUCTURE_TYPE_DEPENDENCY_INFO = 1000314003,
  VK_STRUCTURE_TYPE_SUBMIT_INFO_2 = 1000314004,
  VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO = 1000314005,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO = 1000314006,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES = 1000314007,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES = 1000325000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES = 1000335000,
  VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2 = 1000337000,
  VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2 = 1000337001,
  VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2 = 1000337002,
  VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2 = 1000337003,
  VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2 = 1000337004,
  VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2 = 1000337005,
  VK_STRUCTURE_TYPE_BUFFER_COPY_2 = 1000337006,
  VK_STRUCTURE_TYPE_IMAGE_COPY_2 = 1000337007,
  VK_STRUCTURE_TYPE_IMAGE_BLIT_2 = 1000337008,
  VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2 = 1000337009,
  VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2 = 1000337010,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES = 1000225000,
  VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO = 1000225001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES = 1000225002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES = 1000138000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES = 1000138001,
  VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK = 1000138002,
  VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO = 1000138003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES = 1000066000,
  VK_STRUCTURE_TYPE_RENDERING_INFO = 1000044000,
  VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO = 1000044001,
  VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO = 1000044002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES = 1000044003,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO = 1000044004,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES = 1000280000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES = 1000280001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES = 1000281001,
  VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 = 1000360000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES = 1000413000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES = 1000413001,
  VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS = 1000413002,
  VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS = 1000413003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = 1000120000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = 1000063000,
  VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
  VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
  VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
  VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
  VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
  VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
  VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
  VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
  VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
  VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
  VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
  VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
  VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
  VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
  VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
  VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
  VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
  VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR = 1000023000,
  VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR = 1000023001,
  VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR = 1000023002,
  VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR = 1000023003,
  VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR = 1000023004,
  VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR = 1000023005,
  VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000023006,
  VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR = 1000023007,
  VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR = 1000023008,
  VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR = 1000023009,
  VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR = 1000023010,
  VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR = 1000023011,
  VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR = 1000023012,
  VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR = 1000023013,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR = 1000023014,
  VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR = 1000023015,
  VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR = 1000023016,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR = 1000024000,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR = 1000024001,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR = 1000024002,
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002,
  VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX = 1000029000,
  VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX = 1000029001,
  VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX = 1000029002,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX = 1000030001,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_EXT = 1000038000,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000038001,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_EXT = 1000038002,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_EXT = 1000038003,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_EXT = 1000038004,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_EXT = 1000038005,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_EXT = 1000038006,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_EXT = 1000038007,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_EXT = 1000038008,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_EXT = 1000038009,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_EXT = 1000038010,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_EXT = 1000038011,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_EXT = 1000038012,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_EXT = 1000038013,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_EXT = 1000039000,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_EXT = 1000039001,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_EXT = 1000039002,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_EXT = 1000039003,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_EXT = 1000039004,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_EXT = 1000039005,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_EXT = 1000039006,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_EXT = 1000039007,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_EXT = 1000039009,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_EXT = 1000039010,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_EXT = 1000039011,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_EXT = 1000039012,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_EXT = 1000039013,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_EXT = 1000039014,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR = 1000040000,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR = 1000040001,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR = 1000040003,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000040004,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR = 1000040005,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR = 1000040006,
  VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
  VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000044006,
  VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT = 1000044007,
  VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD = 1000044008,
  VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX = 1000044009,
  VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000,
  VK_STRUCTURE_TYPE_PRIVATE_VENDOR_INFO_RESERVED_OFFSET_0_NV = 1000051000,
  VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
  VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
  VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
  VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
  VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
  VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001,
  VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT = 1000068000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT = 1000068001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT = 1000068002,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
  VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
  VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
  VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
  VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
  VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
  VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
  VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
  VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
  VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
  VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
  VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
  VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
  VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
  VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
  VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000,
  VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000,
  VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001,
  VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002,
  VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
  VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
  VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001,
  VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
  VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
  VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
  VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
  VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
  VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
  VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001,
  VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002,
  VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR = 1000116003,
  VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR = 1000116004,
  VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR = 1000116005,
  VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR = 1000116006,
  VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_RESERVATION_INFO_KHR = 1000116007,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
  VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001,
  VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002,
  VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000,
  VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
  VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
  VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003,
  VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
  VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
  VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
  VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
  VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
  VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002,
  VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
  VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
  VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
  VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
  VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
  VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
  VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
  VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005,
  VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID = 1000129006,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX = 1000134000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX = 1000134001,
  VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX = 1000134002,
  VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX = 1000134003,
  VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX = 1000134004,
  VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
  VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
  VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
  VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
  VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
  VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
  VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR = 1000150007,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR = 1000150000,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR = 1000150002,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR = 1000150003,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR = 1000150004,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR = 1000150005,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR = 1000150006,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR = 1000150009,
  VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR = 1000150010,
  VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR = 1000150011,
  VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR = 1000150012,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR = 1000150013,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR = 1000150014,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR = 1000150017,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR = 1000150020,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR = 1000347000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR = 1000347001,
  VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR = 1000150015,
  VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR = 1000150016,
  VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR = 1000150018,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR = 1000348013,
  VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 1000154000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 1000154001,
  VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
  VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
  VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
  VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
  VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006,
  VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
  VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR = 1000163000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR = 1000163001,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005,
  VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001,
  VK_STRUCTURE_TYPE_GEOMETRY_NV = 1000165003,
  VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV = 1000165004,
  VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV = 1000165005,
  VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006,
  VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009,
  VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV = 1000165012,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000,
  VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000,
  VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
  VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 1000181000,
  VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000,
  VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT = 1000184000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR = 1000187000,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR = 1000187001,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR = 1000187002,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR = 1000187003,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR = 1000187004,
  VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR = 1000187005,
  VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR = 1000174000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR = 1000388000,
  VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR = 1000388001,
  VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
  VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = 1000190001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = 1000190002,
  VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = 1000201000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002,
  VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000,
  VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000,
  VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL = 1000210000,
  VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001,
  VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL = 1000210002,
  VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL = 1000210003,
  VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL = 1000210004,
  VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 1000210005,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000,
  VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000,
  VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001,
  VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000,
  VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001,
  VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002,
  VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000226000,
  VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR = 1000226001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR = 1000226002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR = 1000226003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR = 1000226004,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT = 1000234000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000,
  VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001,
  VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000,
  VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002,
  VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR = 1000248000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000,
  VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 1000250000,
  VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 1000250001,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 1000250002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT = 1000254000,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT = 1000254001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT = 1000254002,
  VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000,
  VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002,
  VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001,
  VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = 1000259000,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = 1000259001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = 1000259002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT = 1000260000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = 1000265000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT = 1000267000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000,
  VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR = 1000269001,
  VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002,
  VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003,
  VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004,
  VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT = 1000270000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT = 1000270001,
  VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT = 1000270002,
  VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT = 1000270003,
  VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT = 1000270004,
  VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT = 1000270005,
  VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT = 1000270006,
  VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT = 1000270007,
  VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT = 1000270008,
  VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT = 1000270009,
  VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR = 1000271000,
  VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR = 1000271001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT = 1000273000,
  VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT = 1000274000,
  VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT = 1000274001,
  VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT = 1000274002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT = 1000275000,
  VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT = 1000275001,
  VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT = 1000275002,
  VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT = 1000275003,
  VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT = 1000275004,
  VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT = 1000275005,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV = 1000277000,
  VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV = 1000277001,
  VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV = 1000277002,
  VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV = 1000277003,
  VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV = 1000277004,
  VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV = 1000277005,
  VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV = 1000277006,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV = 1000277007,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV = 1000278000,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV = 1000278001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM = 1000282000,
  VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM = 1000282001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT = 1000283000,
  VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT = 1000283001,
  VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT = 1000283002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT = 1000284000,
  VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT = 1000284001,
  VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT = 1000284002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT = 1000286000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT = 1000286001,
  VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT = 1000287000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT = 1000287001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT = 1000287002,
  VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR = 1000290000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV = 1000292000,
  VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV = 1000292001,
  VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV = 1000292002,
  VK_STRUCTURE_TYPE_PRESENT_ID_KHR = 1000294000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR = 1000294001,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR = 1000299000,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR = 1000299001,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR = 1000299002,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR = 1000299003,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR = 1000299004,
  VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR = 1000299005,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR = 1000299006,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR = 1000299007,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR = 1000299008,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR = 1000299009,
  VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR = 1000299010,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV = 1000300000,
  VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV = 1000300001,
  VK_STRUCTURE_TYPE_REFRESH_OBJECT_LIST_KHR = 1000308000,
  VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV = 1000310000,
  VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT = 1000311000,
  VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT = 1000311001,
  VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT = 1000311002,
  VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT = 1000311003,
  VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT = 1000311004,
  VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT = 1000311005,
  VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT = 1000311006,
  VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT = 1000311007,
  VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT = 1000311008,
  VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT = 1000311009,
  VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311010,
  VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT = 1000311011,
  VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008,
  VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 1000314009,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT = 1000316000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT = 1000316001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT = 1000316002,
  VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT = 1000316003,
  VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT = 1000316004,
  VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316005,
  VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316006,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316007,
  VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316008,
  VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT = 1000316010,
  VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT = 1000316011,
  VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT = 1000316012,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT = 1000316009,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT = 1000320000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT = 1000320001,
  VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT = 1000320002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD = 1000321000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR = 1000203000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR = 1000322000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR = 1000323000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV = 1000326000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV = 1000326001,
  VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV = 1000326002,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV = 1000327000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV = 1000327001,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV = 1000327002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT = 1000328000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT = 1000328001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT = 1000330000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT = 1000332000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT = 1000332001,
  VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM = 1000333000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR = 1000336000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT = 1000338000,
  VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT = 1000338001,
  VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT = 1000338004,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT = 1000339000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT = 1000340000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT = 1000341000,
  VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT = 1000341001,
  VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT = 1000341002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT = 1000344000,
  VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT = 1000346000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT = 1000352000,
  VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT = 1000352001,
  VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT = 1000352002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT = 1000353000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT = 1000354000,
  VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT = 1000354001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT = 1000355000,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT = 1000355001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT = 1000356000,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364000,
  VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA = 1000364001,
  VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364002,
  VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365000,
  VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365001,
  VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA = 1000366000,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA = 1000366001,
  VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA = 1000366002,
  VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA = 1000366003,
  VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA = 1000366004,
  VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA = 1000366005,
  VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA = 1000366006,
  VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA = 1000366007,
  VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA = 1000366008,
  VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA = 1000366009,
  VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI = 1000369000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI = 1000369001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI = 1000369002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI = 1000370000,
  VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV = 1000371000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV = 1000371001,
  VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT = 1000372000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT = 1000372001,
  VK_STRUCTURE_TYPE_IMPORT_FENCE_SCI_SYNC_INFO_NV = 1000373000,
  VK_STRUCTURE_TYPE_EXPORT_FENCE_SCI_SYNC_INFO_NV = 1000373001,
  VK_STRUCTURE_TYPE_FENCE_GET_SCI_SYNC_INFO_NV = 1000373002,
  VK_STRUCTURE_TYPE_SCI_SYNC_ATTRIBUTES_INFO_NV = 1000373003,
  VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_SCI_SYNC_INFO_NV = 1000373004,
  VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_SCI_SYNC_INFO_NV = 1000373005,
  VK_STRUCTURE_TYPE_SEMAPHORE_GET_SCI_SYNC_INFO_NV = 1000373006,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_FEATURES_NV = 1000373007,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_SCI_BUF_INFO_NV = 1000374000,
  VK_STRUCTURE_TYPE_EXPORT_MEMORY_SCI_BUF_INFO_NV = 1000374001,
  VK_STRUCTURE_TYPE_MEMORY_GET_SCI_BUF_INFO_NV = 1000374002,
  VK_STRUCTURE_TYPE_MEMORY_SCI_BUF_PROPERTIES_NV = 1000374003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCI_BUF_FEATURES_NV = 1000374004,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT = 1000376000,
  VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT = 1000376001,
  VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT = 1000376002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT = 1000377000,
  VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX = 1000378000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT = 1000381000,
  VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT = 1000381001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT = 1000382000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR = 1000386000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT = 1000391000,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT = 1000391001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT = 1000392000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT = 1000392001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT = 1000393000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT = 1000395000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT = 1000395001,
  VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT = 1000396000,
  VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT = 1000396001,
  VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT = 1000396002,
  VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT = 1000396003,
  VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT = 1000396004,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT = 1000396005,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT = 1000396006,
  VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT = 1000396007,
  VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT = 1000396008,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT = 1000396009,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV = 1000397000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV = 1000397001,
  VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV = 1000397002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI = 1000404000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI = 1000404001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT = 1000411000,
  VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT = 1000411001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT = 1000412000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM = 1000415000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT = 1000418000,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT = 1000418001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE = 1000420000,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE = 1000420001,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE = 1000420002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT = 1000421000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT = 1000422000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM = 1000425000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM = 1000425001,
  VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM = 1000425002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV = 1000426000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV = 1000426001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV = 1000427000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV = 1000427001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV = 1000428000,
  VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV = 1000428001,
  VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV = 1000428002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV = 1000430000,
  VK_STRUCTURE_TYPE_APPLICATION_PARAMETERS_EXT = 1000435000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT = 1000437000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM = 1000440000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM = 1000440001,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM = 1000440002,
  VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT = 1000453000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT = 1000455000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT = 1000455001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT = 1000458000,
  VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT = 1000458001,
  VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000458002,
  VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT = 1000458003,
  VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG = 1000459000,
  VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG = 1000459001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT = 1000462000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT = 1000462001,
  VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT = 1000462002,
  VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT = 1000462003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT = 1000342000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV = 1000464000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV = 1000464001,
  VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV = 1000464002,
  VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV = 1000464003,
  VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV = 1000464004,
  VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV = 1000464005,
  VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV = 1000464010,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT = 1000465000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT = 1000466000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR = 1000470000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR = 1000470001,
  VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR = 1000470003,
  VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR = 1000470004,
  VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR = 1000338002,
  VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR = 1000338003,
  VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR = 1000470005,
  VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR = 1000470006,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR = 1000481000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT = 1000482000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT = 1000482001,
  VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT = 1000482002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM = 1000484000,
  VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM = 1000484001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC = 1000485000,
  VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC = 1000485001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM = 1000488000,
  VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_POOL_CREATE_INFO_NV = 1000489000,
  VK_STRUCTURE_TYPE_SEMAPHORE_SCI_SYNC_CREATE_INFO_NV = 1000489001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SCI_SYNC_2_FEATURES_NV = 1000489002,
  VK_STRUCTURE_TYPE_DEVICE_SEMAPHORE_SCI_SYNC_POOL_RESERVATION_CREATE_INFO_NV = 1000489003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV = 1000490000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV = 1000490001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT = 1000351000,
  VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT = 1000351002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM = 1000497000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM = 1000497001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT = 1000498000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT = 1000499000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR = 1000506000,
  VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR = 1000506001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR = 1000506002,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM = 1000510000,
  VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM = 1000510001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT = 1000524000,
  VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX = 1000529000,
  VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX = 1000529001,
  VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX = 1000529002,
  VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX = 1000529003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX = 1000529004,
}
export enum VkSubpassContents{
  VK_SUBPASS_CONTENTS_INLINE = 0,
  VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
}
export enum VkResult{
  VK_SUCCESS = 0,
  VK_NOT_READY = 1,
  VK_TIMEOUT = 2,
  VK_EVENT_SET = 3,
  VK_EVENT_RESET = 4,
  VK_INCOMPLETE = 5,
  VK_ERROR_OUT_OF_HOST_MEMORY = -1,
  VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
  VK_ERROR_INITIALIZATION_FAILED = -3,
  VK_ERROR_DEVICE_LOST = -4,
  VK_ERROR_MEMORY_MAP_FAILED = -5,
  VK_ERROR_LAYER_NOT_PRESENT = -6,
  VK_ERROR_EXTENSION_NOT_PRESENT = -7,
  VK_ERROR_FEATURE_NOT_PRESENT = -8,
  VK_ERROR_INCOMPATIBLE_DRIVER = -9,
  VK_ERROR_TOO_MANY_OBJECTS = -10,
  VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
  VK_ERROR_FRAGMENTED_POOL = -12,
  VK_ERROR_UNKNOWN = -13,
  VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
  VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
  VK_ERROR_FRAGMENTATION = -1000161000,
  VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
  VK_PIPELINE_COMPILE_REQUIRED = 1000297000,
  VK_ERROR_SURFACE_LOST_KHR = -1000000000,
  VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
  VK_SUBOPTIMAL_KHR = 1000001003,
  VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
  VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
  VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
  VK_ERROR_INVALID_SHADER_NV = -1000012000,
  VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR = -1000023000,
  VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR = -1000023001,
  VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR = -1000023002,
  VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR = -1000023003,
  VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR = -1000023004,
  VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR = -1000023005,
  VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
  VK_ERROR_NOT_PERMITTED_KHR = -1000174001,
  VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
  VK_THREAD_IDLE_KHR = 1000268000,
  VK_THREAD_DONE_KHR = 1000268001,
  VK_OPERATION_DEFERRED_KHR = 1000268002,
  VK_OPERATION_NOT_DEFERRED_KHR = 1000268003,
  VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR = -1000299000,
  VK_ERROR_COMPRESSION_EXHAUSTED_EXT = -1000338000,
  VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT = 1000482000,
}
export enum VkDynamicState{
  VK_DYNAMIC_STATE_VIEWPORT = 0,
  VK_DYNAMIC_STATE_SCISSOR = 1,
  VK_DYNAMIC_STATE_LINE_WIDTH = 2,
  VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
  VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
  VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
  VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
  VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
  VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
  VK_DYNAMIC_STATE_CULL_MODE = 1000267000,
  VK_DYNAMIC_STATE_FRONT_FACE = 1000267001,
  VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY = 1000267002,
  VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT = 1000267003,
  VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT = 1000267004,
  VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE = 1000267005,
  VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE = 1000267006,
  VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE = 1000267007,
  VK_DYNAMIC_STATE_DEPTH_COMPARE_OP = 1000267008,
  VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE = 1000267009,
  VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE = 1000267010,
  VK_DYNAMIC_STATE_STENCIL_OP = 1000267011,
  VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE = 1000377001,
  VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE = 1000377002,
  VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE = 1000377004,
  VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000,
  VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000,
  VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT = 1000099001,
  VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT = 1000099002,
  VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000,
  VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR = 1000347000,
  VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV = 1000164004,
  VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV = 1000164006,
  VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV = 1000205000,
  VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV = 1000205001,
  VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR = 1000226000,
  VK_DYNAMIC_STATE_LINE_STIPPLE_EXT = 1000259000,
  VK_DYNAMIC_STATE_VERTEX_INPUT_EXT = 1000352000,
  VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT = 1000377000,
  VK_DYNAMIC_STATE_LOGIC_OP_EXT = 1000377003,
  VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT = 1000381000,
  VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT = 1000455002,
  VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT = 1000455003,
  VK_DYNAMIC_STATE_POLYGON_MODE_EXT = 1000455004,
  VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT = 1000455005,
  VK_DYNAMIC_STATE_SAMPLE_MASK_EXT = 1000455006,
  VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT = 1000455007,
  VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT = 1000455008,
  VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT = 1000455009,
  VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT = 1000455010,
  VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT = 1000455011,
  VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT = 1000455012,
  VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT = 1000455013,
  VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT = 1000455014,
  VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT = 1000455015,
  VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT = 1000455016,
  VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT = 1000455017,
  VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT = 1000455018,
  VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT = 1000455019,
  VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT = 1000455020,
  VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT = 1000455021,
  VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT = 1000455022,
  VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV = 1000455023,
  VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV = 1000455024,
  VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV = 1000455025,
  VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV = 1000455026,
  VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV = 1000455027,
  VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV = 1000455028,
  VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV = 1000455029,
  VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV = 1000455030,
  VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV = 1000455031,
  VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV = 1000455032,
  VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT = 1000524000,
}
export enum VkDescriptorUpdateTemplateType{
  VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0,
  VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1,
}
export enum VkObjectType{
  VK_OBJECT_TYPE_UNKNOWN = 0,
  VK_OBJECT_TYPE_INSTANCE = 1,
  VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2,
  VK_OBJECT_TYPE_DEVICE = 3,
  VK_OBJECT_TYPE_QUEUE = 4,
  VK_OBJECT_TYPE_SEMAPHORE = 5,
  VK_OBJECT_TYPE_COMMAND_BUFFER = 6,
  VK_OBJECT_TYPE_FENCE = 7,
  VK_OBJECT_TYPE_DEVICE_MEMORY = 8,
  VK_OBJECT_TYPE_BUFFER = 9,
  VK_OBJECT_TYPE_IMAGE = 10,
  VK_OBJECT_TYPE_EVENT = 11,
  VK_OBJECT_TYPE_QUERY_POOL = 12,
  VK_OBJECT_TYPE_BUFFER_VIEW = 13,
  VK_OBJECT_TYPE_IMAGE_VIEW = 14,
  VK_OBJECT_TYPE_SHADER_MODULE = 15,
  VK_OBJECT_TYPE_PIPELINE_CACHE = 16,
  VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17,
  VK_OBJECT_TYPE_RENDER_PASS = 18,
  VK_OBJECT_TYPE_PIPELINE = 19,
  VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
  VK_OBJECT_TYPE_SAMPLER = 21,
  VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22,
  VK_OBJECT_TYPE_DESCRIPTOR_SET = 23,
  VK_OBJECT_TYPE_FRAMEBUFFER = 24,
  VK_OBJECT_TYPE_COMMAND_POOL = 25,
  VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 1000156000,
  VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
  VK_OBJECT_TYPE_PRIVATE_DATA_SLOT = 1000295000,
  VK_OBJECT_TYPE_SURFACE_KHR = 1000000000,
  VK_OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000,
  VK_OBJECT_TYPE_DISPLAY_KHR = 1000002000,
  VK_OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001,
  VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000,
  VK_OBJECT_TYPE_VIDEO_SESSION_KHR = 1000023000,
  VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR = 1000023001,
  VK_OBJECT_TYPE_CU_MODULE_NVX = 1000029000,
  VK_OBJECT_TYPE_CU_FUNCTION_NVX = 1000029001,
  VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = 1000128000,
  VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR = 1000150000,
  VK_OBJECT_TYPE_VALIDATION_CACHE_EXT = 1000160000,
  VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000,
  VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL = 1000210000,
  VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR = 1000268000,
  VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV = 1000277000,
  VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA = 1000366000,
  VK_OBJECT_TYPE_MICROMAP_EXT = 1000396000,
  VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV = 1000464000,
  VK_OBJECT_TYPE_SHADER_EXT = 1000482000,
  VK_OBJECT_TYPE_SEMAPHORE_SCI_SYNC_POOL_NV = 1000489000,
}
export enum VkRayTracingInvocationReorderModeNV{
  VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV = 0,
  VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV = 1,
}
export enum VkDirectDriverLoadingModeLUNARG{
  VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG = 0,
  VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG = 1,
}
export enum VkSemaphoreType{
  VK_SEMAPHORE_TYPE_BINARY = 0,
  VK_SEMAPHORE_TYPE_TIMELINE = 1,
}
export enum VkPresentModeKHR{
  VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
  VK_PRESENT_MODE_MAILBOX_KHR = 1,
  VK_PRESENT_MODE_FIFO_KHR = 2,
  VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
  VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
  VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
}
export enum VkColorSpaceKHR{
  VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
  VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001,
  VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
  VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = 1000104003,
  VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004,
  VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005,
  VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006,
  VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007,
  VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008,
  VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
  VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010,
  VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
  VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
  VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013,
  VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
  VK_COLOR_SPACE_DISPLAY_NATIVE_AMD = 1000213000,
}
export enum VkTimeDomainEXT{
  VK_TIME_DOMAIN_DEVICE_EXT = 0,
  VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT = 1,
  VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT = 2,
  VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT = 3,
}
export enum VkDebugReportObjectTypeEXT{
  VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
  VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
  VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
  VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
  VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
  VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
  VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
  VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
  VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
  VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
  VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
  VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
  VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
  VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
  VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
  VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
  VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
  VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
  VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
  VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
  VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
  VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
  VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33,
  VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000,
  VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT = 1000029000,
  VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT = 1000029001,
  VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT = 1000150000,
  VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = 1000165000,
  VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT = 1000366000,
}
export enum VkDeviceMemoryReportEventTypeEXT{
  VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT = 0,
  VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT = 1,
  VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT = 2,
  VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT = 3,
  VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT = 4,
}
export enum VkRasterizationOrderAMD{
  VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
  VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
}
export enum VkValidationCheckEXT{
  VK_VALIDATION_CHECK_ALL_EXT = 0,
  VK_VALIDATION_CHECK_SHADERS_EXT = 1,
}
export enum VkValidationFeatureEnableEXT{
  VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = 0,
  VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1,
  VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT = 2,
  VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT = 3,
  VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT = 4,
}
export enum VkValidationFeatureDisableEXT{
  VK_VALIDATION_FEATURE_DISABLE_ALL_EXT = 0,
  VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 1,
  VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 2,
  VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 3,
  VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 4,
  VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 5,
  VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 6,
  VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT = 7,
}
export enum VkIndirectCommandsTokenTypeNV{
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV = 0,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV = 1,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV = 2,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV = 3,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV = 4,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV = 5,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV = 6,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV = 7,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV = 1000328000,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV = 1000428003,
  VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV = 1000428004,
}
export enum VkDisplayPowerStateEXT{
  VK_DISPLAY_POWER_STATE_OFF_EXT = 0,
  VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
  VK_DISPLAY_POWER_STATE_ON_EXT = 2,
}
export enum VkDeviceEventTypeEXT{
  VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0,
}
export enum VkDisplayEventTypeEXT{
  VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0,
}
export enum VkViewportCoordinateSwizzleNV{
  VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0,
  VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1,
  VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2,
  VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3,
  VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4,
  VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5,
  VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6,
  VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7,
}
export enum VkDiscardRectangleModeEXT{
  VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
  VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1,
}
export enum VkPointClippingBehavior{
  VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0,
  VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1,
}
export enum VkSamplerReductionMode{
  VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE = 0,
  VK_SAMPLER_REDUCTION_MODE_MIN = 1,
  VK_SAMPLER_REDUCTION_MODE_MAX = 2,
}
export enum VkTessellationDomainOrigin{
  VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0,
  VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1,
}
export enum VkSamplerYcbcrModelConversion{
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3,
  VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4,
}
export enum VkSamplerYcbcrRange{
  VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0,
  VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 1,
}
export enum VkChromaLocation{
  VK_CHROMA_LOCATION_COSITED_EVEN = 0,
  VK_CHROMA_LOCATION_MIDPOINT = 1,
}
export enum VkBlendOverlapEXT{
  VK_BLEND_OVERLAP_UNCORRELATED_EXT = 0,
  VK_BLEND_OVERLAP_DISJOINT_EXT = 1,
  VK_BLEND_OVERLAP_CONJOINT_EXT = 2,
}
export enum VkCoverageModulationModeNV{
  VK_COVERAGE_MODULATION_MODE_NONE_NV = 0,
  VK_COVERAGE_MODULATION_MODE_RGB_NV = 1,
  VK_COVERAGE_MODULATION_MODE_ALPHA_NV = 2,
  VK_COVERAGE_MODULATION_MODE_RGBA_NV = 3,
}
export enum VkCoverageReductionModeNV{
  VK_COVERAGE_REDUCTION_MODE_MERGE_NV = 0,
  VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV = 1,
}
export enum VkValidationCacheHeaderVersionEXT{
  VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 1,
}
export enum VkShaderInfoTypeAMD{
  VK_SHADER_INFO_TYPE_STATISTICS_AMD = 0,
  VK_SHADER_INFO_TYPE_BINARY_AMD = 1,
  VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD = 2,
}
export enum VkQueueGlobalPriorityKHR{
  VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR = 128,
  VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR = 256,
  VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR = 512,
  VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR = 1024,
}
export enum VkConservativeRasterizationModeEXT{
  VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = 0,
  VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = 1,
  VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = 2,
}
export enum VkVendorId{
  VK_VENDOR_ID_VIV = 0x10001,
  VK_VENDOR_ID_VSI = 0x10002,
  VK_VENDOR_ID_KAZAN = 0x10003,
  VK_VENDOR_ID_CODEPLAY = 0x10004,
  VK_VENDOR_ID_MESA = 0x10005,
  VK_VENDOR_ID_POCL = 0x10006,
  VK_VENDOR_ID_MOBILEYE = 0x10007,
}
export enum VkDriverId{
  VK_DRIVER_ID_AMD_PROPRIETARY = 1,
  VK_DRIVER_ID_AMD_OPEN_SOURCE = 2,
  VK_DRIVER_ID_MESA_RADV = 3,
  VK_DRIVER_ID_NVIDIA_PROPRIETARY = 4,
  VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = 5,
  VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA = 6,
  VK_DRIVER_ID_IMAGINATION_PROPRIETARY = 7,
  VK_DRIVER_ID_QUALCOMM_PROPRIETARY = 8,
  VK_DRIVER_ID_ARM_PROPRIETARY = 9,
  VK_DRIVER_ID_GOOGLE_SWIFTSHADER = 10,
  VK_DRIVER_ID_GGP_PROPRIETARY = 11,
  VK_DRIVER_ID_BROADCOM_PROPRIETARY = 12,
  VK_DRIVER_ID_MESA_LLVMPIPE = 13,
  VK_DRIVER_ID_MOLTENVK = 14,
  VK_DRIVER_ID_COREAVI_PROPRIETARY = 15,
  VK_DRIVER_ID_JUICE_PROPRIETARY = 16,
  VK_DRIVER_ID_VERISILICON_PROPRIETARY = 17,
  VK_DRIVER_ID_MESA_TURNIP = 18,
  VK_DRIVER_ID_MESA_V3DV = 19,
  VK_DRIVER_ID_MESA_PANVK = 20,
  VK_DRIVER_ID_SAMSUNG_PROPRIETARY = 21,
  VK_DRIVER_ID_MESA_VENUS = 22,
  VK_DRIVER_ID_MESA_DOZEN = 23,
  VK_DRIVER_ID_MESA_NVK = 24,
  VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA = 25,
}
export enum VkShadingRatePaletteEntryNV{
  VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV = 0,
  VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV = 1,
  VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV = 2,
  VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV = 3,
  VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV = 4,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV = 5,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV = 6,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV = 7,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV = 8,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV = 10,
  VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV = 11,
}
export enum VkCoarseSampleOrderTypeNV{
  VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV = 0,
  VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV = 1,
  VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV = 2,
  VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV = 3,
}
export enum VkCopyAccelerationStructureModeKHR{
  VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR = 0,
  VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR = 1,
  VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR = 2,
  VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR = 3,
}
export enum VkBuildAccelerationStructureModeKHR{
  VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR = 0,
  VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR = 1,
}
export enum VkAccelerationStructureTypeKHR{
  VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR = 0,
  VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR = 1,
  VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR = 2,
}
export enum VkGeometryTypeKHR{
  VK_GEOMETRY_TYPE_TRIANGLES_KHR = 0,
  VK_GEOMETRY_TYPE_AABBS_KHR = 1,
  VK_GEOMETRY_TYPE_INSTANCES_KHR = 2,
}
export enum VkAccelerationStructureMemoryRequirementsTypeNV{
  VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV = 0,
  VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV = 1,
  VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV = 2,
}
export enum VkAccelerationStructureBuildTypeKHR{
  VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR = 0,
  VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR = 1,
  VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR = 2,
}
export enum VkRayTracingShaderGroupTypeKHR{
  VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR = 0,
  VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR = 1,
  VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR = 2,
}
export enum VkAccelerationStructureCompatibilityKHR{
  VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR = 0,
  VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR = 1,
}
export enum VkShaderGroupShaderKHR{
  VK_SHADER_GROUP_SHADER_GENERAL_KHR = 0,
  VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR = 1,
  VK_SHADER_GROUP_SHADER_ANY_HIT_KHR = 2,
  VK_SHADER_GROUP_SHADER_INTERSECTION_KHR = 3,
}
export enum VkMemoryOverallocationBehaviorAMD{
  VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = 0,
  VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = 1,
  VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = 2,
}
export enum VkFullScreenExclusiveEXT{
  VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT = 0,
  VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT = 1,
  VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT = 2,
  VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT = 3,
}
export enum VkPerformanceCounterScopeKHR{
  VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR = 0,
  VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR = 1,
  VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR = 2,
}
export enum VkPerformanceCounterUnitKHR{
  VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = 0,
  VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = 1,
  VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = 2,
  VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR = 3,
  VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = 4,
  VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = 5,
  VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR = 6,
  VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = 7,
  VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR = 8,
  VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = 9,
  VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = 10,
}
export enum VkPerformanceCounterStorageKHR{
  VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0,
  VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 1,
  VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 2,
  VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 3,
  VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 4,
  VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 5,
}
export enum VkPerformanceConfigurationTypeINTEL{
  VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = 0,
}
export enum VkQueryPoolSamplingModeINTEL{
  VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL = 0,
}
export enum VkPerformanceOverrideTypeINTEL{
  VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL = 0,
  VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL = 1,
}
export enum VkPerformanceParameterTypeINTEL{
  VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL = 0,
  VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL = 1,
}
export enum VkPerformanceValueTypeINTEL{
  VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL = 0,
  VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL = 1,
  VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL = 2,
  VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL = 3,
  VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL = 4,
}
export enum VkShaderFloatControlsIndependence{
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY = 0,
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL = 1,
  VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE = 2,
}
export enum VkPipelineExecutableStatisticFormatKHR{
  VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR = 0,
  VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR = 1,
  VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR = 2,
  VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR = 3,
}
export enum VkLineRasterizationModeEXT{
  VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = 0,
  VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = 1,
  VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = 2,
  VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = 3,
}
export enum VkFaultLevel{
  VK_FAULT_LEVEL_UNASSIGNED = 0,
  VK_FAULT_LEVEL_CRITICAL = 1,
  VK_FAULT_LEVEL_RECOVERABLE = 2,
  VK_FAULT_LEVEL_WARNING = 3,
}
export enum VkFaultType{
  VK_FAULT_TYPE_INVALID = 0,
  VK_FAULT_TYPE_UNASSIGNED = 1,
  VK_FAULT_TYPE_IMPLEMENTATION = 2,
  VK_FAULT_TYPE_SYSTEM = 3,
  VK_FAULT_TYPE_PHYSICAL_DEVICE = 4,
  VK_FAULT_TYPE_COMMAND_BUFFER_FULL = 5,
  VK_FAULT_TYPE_INVALID_API_USAGE = 6,
}
export enum VkFaultQueryBehavior{
  VK_FAULT_QUERY_BEHAVIOR_GET_AND_CLEAR_ALL_FAULTS = 0,
}
export enum VkPipelineMatchControl{
  VK_PIPELINE_MATCH_CONTROL_APPLICATION_UUID_EXACT_MATCH = 0,
}
export enum VkFragmentShadingRateCombinerOpKHR{
  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR = 0,
  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR = 1,
  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR = 2,
  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR = 3,
  VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR = 4,
}
export enum VkFragmentShadingRateNV{
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = 0,
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = 1,
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = 4,
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = 5,
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = 6,
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = 9,
  VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = 10,
  VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = 11,
  VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = 12,
  VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = 13,
  VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = 14,
  VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV = 15,
}
export enum VkFragmentShadingRateTypeNV{
  VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV = 0,
  VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV = 1,
}
export enum VkSubpassMergeStatusEXT{
  VK_SUBPASS_MERGE_STATUS_MERGED_EXT = 0,
  VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT = 1,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT = 2,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT = 3,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT = 4,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT = 5,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT = 6,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT = 7,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT = 8,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT = 9,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT = 10,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT = 11,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT = 12,
  VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT = 13,
}
export enum VkSciSyncClientTypeNV{
  VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_NV = 0,
  VK_SCI_SYNC_CLIENT_TYPE_WAITER_NV = 1,
  VK_SCI_SYNC_CLIENT_TYPE_SIGNALER_WAITER_NV = 2,
}
export enum VkSciSyncPrimitiveTypeNV{
  VK_SCI_SYNC_PRIMITIVE_TYPE_FENCE_NV = 0,
  VK_SCI_SYNC_PRIMITIVE_TYPE_SEMAPHORE_NV = 1,
}
export enum VkProvokingVertexModeEXT{
  VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT = 0,
  VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT = 1,
}
export enum VkPipelineCacheValidationVersion{
  VK_PIPELINE_CACHE_VALIDATION_VERSION_SAFETY_CRITICAL_ONE = 1,
}
export enum VkAccelerationStructureMotionInstanceTypeNV{
  VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV = 0,
  VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV = 1,
  VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV = 2,
}
export enum VkDeviceAddressBindingTypeEXT{
  VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT = 0,
  VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT = 1,
}
export enum VkQueryResultStatusKHR{
  VK_QUERY_RESULT_STATUS_ERROR_KHR = -1,
  VK_QUERY_RESULT_STATUS_NOT_READY_KHR = 0,
  VK_QUERY_RESULT_STATUS_COMPLETE_KHR = 1,
}
export enum VkVideoEncodeTuningModeKHR{
  VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR = 0,
  VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR = 1,
  VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR = 2,
  VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR = 3,
  VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR = 4,
}
export enum VkPipelineRobustnessBufferBehaviorEXT{
  VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT = 0,
  VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT = 1,
  VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT = 2,
  VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT = 3,
}
export enum VkPipelineRobustnessImageBehaviorEXT{
  VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT = 0,
  VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT = 1,
  VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT = 2,
  VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT = 3,
}
export enum VkOpticalFlowPerformanceLevelNV{
  VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV = 0,
  VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV = 1,
  VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV = 2,
  VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV = 3,
}
export enum VkOpticalFlowSessionBindingPointNV{
  VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV = 0,
  VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV = 1,
  VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV = 2,
  VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV = 3,
  VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV = 4,
  VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV = 5,
  VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV = 6,
  VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV = 7,
  VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV = 8,
}
export enum VkMicromapTypeEXT{
  VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT = 0,
  VK_MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV = 1000397000,
}
export enum VkCopyMicromapModeEXT{
  VK_COPY_MICROMAP_MODE_CLONE_EXT = 0,
  VK_COPY_MICROMAP_MODE_SERIALIZE_EXT = 1,
  VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT = 2,
  VK_COPY_MICROMAP_MODE_COMPACT_EXT = 3,
}
export enum VkBuildMicromapModeEXT{
  VK_BUILD_MICROMAP_MODE_BUILD_EXT = 0,
}
export enum VkOpacityMicromapFormatEXT{
  VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT = 1,
  VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT = 2,
}
export enum VkOpacityMicromapSpecialIndexEXT{
  VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT = -1,
  VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT = -2,
  VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT = -3,
  VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT = -4,
}
export enum VkDepthBiasRepresentationEXT{
  VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT = 0,
  VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT = 1,
  VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT = 2,
}
export enum VkDeviceFaultAddressTypeEXT{
  VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT = 0,
  VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT = 1,
  VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT = 2,
  VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT = 3,
  VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT = 4,
  VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT = 5,
  VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT = 6,
}
export enum VkDeviceFaultVendorBinaryHeaderVersionEXT{
  VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT = 1,
}
export enum VkDisplacementMicromapFormatNV{
  VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV = 1,
  VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV = 2,
  VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV = 3,
}
export enum VkShaderCodeTypeEXT{
  VK_SHADER_CODE_TYPE_BINARY_EXT = 0,
  VK_SHADER_CODE_TYPE_SPIRV_EXT = 1,
}
export enum VkScopeKHR{
  VK_SCOPE_DEVICE_KHR = 1,
  VK_SCOPE_WORKGROUP_KHR = 2,
  VK_SCOPE_SUBGROUP_KHR = 3,
  VK_SCOPE_QUEUE_FAMILY_KHR = 5,
}
export enum VkComponentTypeKHR{
  VK_COMPONENT_TYPE_FLOAT16_KHR = 0,
  VK_COMPONENT_TYPE_FLOAT32_KHR = 1,
  VK_COMPONENT_TYPE_FLOAT64_KHR = 2,
  VK_COMPONENT_TYPE_SINT8_KHR = 3,
  VK_COMPONENT_TYPE_SINT16_KHR = 4,
  VK_COMPONENT_TYPE_SINT32_KHR = 5,
  VK_COMPONENT_TYPE_SINT64_KHR = 6,
  VK_COMPONENT_TYPE_UINT8_KHR = 7,
  VK_COMPONENT_TYPE_UINT16_KHR = 8,
  VK_COMPONENT_TYPE_UINT32_KHR = 9,
  VK_COMPONENT_TYPE_UINT64_KHR = 10,
}

export interface VkBaseOutStructureDeserialized {
    pNext?: VkBaseOutStructureDeserialized
}
export interface VkBaseInStructureDeserialized {
    pNext?: VkBaseInStructureDeserialized
}
export interface VkOffset2DDeserialized {
    x: number;
    y: number
}
export interface VkOffset3DDeserialized {
    x: number;
    y: number;
    z: number
}
export interface VkExtent2DDeserialized {
    width: number;
    height: number
}
export interface VkExtent3DDeserialized {
    width: number;
    height: number;
    depth: number
}
export interface VkViewportDeserialized {
    x: number;
    y: number;
    width: number;
    height: number;
    minDepth: number;
    maxDepth: number
}
export interface VkRect2DDeserialized {
    offset: VkOffset2DDeserialized[];
    extent: VkExtent2DDeserialized[]
}
export interface VkClearRectDeserialized {
    rect: VkRect2DDeserialized[];
    baseArrayLayer: number;
    layerCount: number
}
export interface VkComponentMappingDeserialized {
    r: number;
    g: number;
    b: number;
    a: number
}
export interface VkPhysicalDevicePropertiesDeserialized {
    apiVersion: number;
    driverVersion: number;
    vendorID: number;
    deviceID: number;
    deviceType: number;
    deviceName: string;
    pipelineCacheUUID: number;
    limits: VkPhysicalDeviceLimitsDeserialized[];
    sparseProperties: VkPhysicalDeviceSparsePropertiesDeserialized[]
}
export interface VkExtensionPropertiesDeserialized {
    extensionName: string;
    specVersion: number
}
export interface VkLayerPropertiesDeserialized {
    layerName: string;
    specVersion: number;
    implementationVersion: number;
    description: string
}
export interface VkApplicationInfoDeserialized {
    pNext?: ptr64_t;
    pApplicationName?: string;
    applicationVersion: number;
    pEngineName?: string;
    engineVersion: number;
    apiVersion: number
}
export interface VkAllocationCallbacksDeserialized {
    pUserData?: ptr64_t;
    pfnAllocation: ptr64_t;
    pfnReallocation: ptr64_t;
    pfnFree: ptr64_t;
    pfnInternalAllocation?: ptr64_t;
    pfnInternalFree?: ptr64_t
}
export interface VkDeviceQueueCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    queueFamilyIndex: number;
    queueCount: number;
    pQueuePriorities: number
}
export interface VkDeviceCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    queueCreateInfoCount: number;
    pQueueCreateInfos: VkDeviceQueueCreateInfoDeserialized;
    enabledExtensionCount?: number;
    ppEnabledExtensionNames: string[];
    pEnabledFeatures?: VkPhysicalDeviceFeaturesDeserialized
}
export interface VkInstanceCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    pApplicationInfo?: VkApplicationInfoDeserialized;
    enabledLayerCount?: number;
    ppEnabledLayerNames: string[];
    enabledExtensionCount?: number;
    ppEnabledExtensionNames: string[]
}
export interface VkQueueFamilyPropertiesDeserialized {
    queueFlags?: number;
    queueCount: number;
    timestampValidBits: number;
    minImageTransferGranularity: VkExtent3DDeserialized[]
}
export interface VkPhysicalDeviceMemoryPropertiesDeserialized {
    memoryTypeCount: number;
    memoryTypes: VkMemoryTypeDeserialized[];
    memoryHeapCount: number;
    memoryHeaps: VkMemoryHeapDeserialized[]
}
export interface VkMemoryAllocateInfoDeserialized {
    pNext?: ptr64_t;
    allocationSize: number;
    memoryTypeIndex: number
}
export interface VkMemoryRequirementsDeserialized {
    size: number;
    alignment: number;
    memoryTypeBits: number
}
export interface VkSparseImageFormatPropertiesDeserialized {
    aspectMask?: number;
    imageGranularity: VkExtent3DDeserialized[];
    flags?: number
}
export interface VkSparseImageMemoryRequirementsDeserialized {
    formatProperties: VkSparseImageFormatPropertiesDeserialized[];
    imageMipTailFirstLod: number;
    imageMipTailSize: number;
    imageMipTailOffset: number;
    imageMipTailStride: number
}
export interface VkMemoryTypeDeserialized {
    propertyFlags?: number;
    heapIndex: number
}
export interface VkMemoryHeapDeserialized {
    size: number;
    flags?: number
}
export interface VkMappedMemoryRangeDeserialized {
    pNext?: ptr64_t;
    memory: ptr64_t;
    offset: number;
    size: number
}
export interface VkFormatPropertiesDeserialized {
    linearTilingFeatures?: number;
    optimalTilingFeatures?: number;
    bufferFeatures?: number
}
export interface VkImageFormatPropertiesDeserialized {
    maxExtent: VkExtent3DDeserialized[];
    maxMipLevels: number;
    maxArrayLayers: number;
    sampleCounts?: number;
    maxResourceSize: number
}
export interface VkDescriptorBufferInfoDeserialized {
    buffer?: ptr64_t;
    offset: number;
    range: number
}
export interface VkDescriptorImageInfoDeserialized {
    sampler: ptr64_t;
    imageView: ptr64_t;
    imageLayout: number
}
export interface VkWriteDescriptorSetDeserialized {
    pNext?: ptr64_t;
    dstSet: ptr64_t;
    dstBinding: number;
    dstArrayElement: number;
    descriptorCount: number;
    descriptorType: number;
    pImageInfo: VkDescriptorImageInfoDeserialized;
    pBufferInfo: VkDescriptorBufferInfoDeserialized;
    pTexelBufferView: ptr64_t
}
export interface VkCopyDescriptorSetDeserialized {
    pNext?: ptr64_t;
    srcSet: ptr64_t;
    srcBinding: number;
    srcArrayElement: number;
    dstSet: ptr64_t;
    dstBinding: number;
    dstArrayElement: number;
    descriptorCount: number
}
export interface VkBufferCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    size: number;
    usage: number;
    sharingMode: number;
    queueFamilyIndexCount?: number;
    pQueueFamilyIndices: number
}
export interface VkBufferViewCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    buffer: ptr64_t;
    format: number;
    offset: number;
    range: number
}
export interface VkImageSubresourceDeserialized {
    aspectMask: number;
    mipLevel: number;
    arrayLayer: number
}
export interface VkImageSubresourceLayersDeserialized {
    aspectMask: number;
    mipLevel: number;
    baseArrayLayer: number;
    layerCount: number
}
export interface VkImageSubresourceRangeDeserialized {
    aspectMask: number;
    baseMipLevel: number;
    levelCount: number;
    baseArrayLayer: number;
    layerCount: number
}
export interface VkMemoryBarrierDeserialized {
    pNext?: ptr64_t;
    srcAccessMask?: number;
    dstAccessMask?: number
}
export interface VkBufferMemoryBarrierDeserialized {
    pNext?: ptr64_t;
    srcAccessMask: number;
    dstAccessMask: number;
    srcQueueFamilyIndex: number;
    dstQueueFamilyIndex: number;
    buffer: ptr64_t;
    offset: number;
    size: number
}
export interface VkImageMemoryBarrierDeserialized {
    pNext?: ptr64_t;
    srcAccessMask: number;
    dstAccessMask: number;
    oldLayout: number;
    newLayout: number;
    srcQueueFamilyIndex: number;
    dstQueueFamilyIndex: number;
    image: ptr64_t;
    subresourceRange: VkImageSubresourceRangeDeserialized[]
}
export interface VkImageCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    imageType: number;
    format: number;
    extent: VkExtent3DDeserialized[];
    mipLevels: number;
    arrayLayers: number;
    samples: number;
    tiling: number;
    usage: number;
    sharingMode: number;
    queueFamilyIndexCount?: number;
    pQueueFamilyIndices: number;
    initialLayout: number
}
export interface VkSubresourceLayoutDeserialized {
    offset: number;
    size: number;
    rowPitch: number;
    arrayPitch: number;
    depthPitch: number
}
export interface VkImageViewCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    image: ptr64_t;
    viewType: number;
    format: number;
    components: VkComponentMappingDeserialized[];
    subresourceRange: VkImageSubresourceRangeDeserialized[]
}
export interface VkBufferCopyDeserialized {
    srcOffset: number;
    dstOffset: number;
    size: number
}
export interface VkSparseMemoryBindDeserialized {
    resourceOffset: number;
    size: number;
    memory?: ptr64_t;
    memoryOffset: number;
    flags?: number
}
export interface VkSparseImageMemoryBindDeserialized {
    subresource: VkImageSubresourceDeserialized[];
    offset: VkOffset3DDeserialized[];
    extent: VkExtent3DDeserialized[];
    memory?: ptr64_t;
    memoryOffset: number;
    flags?: number
}
export interface VkSparseBufferMemoryBindInfoDeserialized {
    buffer: ptr64_t;
    bindCount: number;
    pBinds: VkSparseMemoryBindDeserialized
}
export interface VkSparseImageOpaqueMemoryBindInfoDeserialized {
    image: ptr64_t;
    bindCount: number;
    pBinds: VkSparseMemoryBindDeserialized
}
export interface VkSparseImageMemoryBindInfoDeserialized {
    image: ptr64_t;
    bindCount: number;
    pBinds: VkSparseImageMemoryBindDeserialized
}
export interface VkBindSparseInfoDeserialized {
    pNext?: ptr64_t;
    waitSemaphoreCount?: number;
    pWaitSemaphores: ptr64_t;
    bufferBindCount?: number;
    pBufferBinds: VkSparseBufferMemoryBindInfoDeserialized;
    imageOpaqueBindCount?: number;
    pImageOpaqueBinds: VkSparseImageOpaqueMemoryBindInfoDeserialized;
    imageBindCount?: number;
    pImageBinds: VkSparseImageMemoryBindInfoDeserialized;
    signalSemaphoreCount?: number;
    pSignalSemaphores: ptr64_t
}
export interface VkImageCopyDeserialized {
    srcSubresource: VkImageSubresourceLayersDeserialized[];
    srcOffset: VkOffset3DDeserialized[];
    dstSubresource: VkImageSubresourceLayersDeserialized[];
    dstOffset: VkOffset3DDeserialized[];
    extent: VkExtent3DDeserialized[]
}
export interface VkImageBlitDeserialized {
    srcSubresource: VkImageSubresourceLayersDeserialized[];
    srcOffsets: VkOffset3DDeserialized[];
    dstSubresource: VkImageSubresourceLayersDeserialized[];
    dstOffsets: VkOffset3DDeserialized[]
}
export interface VkBufferImageCopyDeserialized {
    bufferOffset: number;
    bufferRowLength: number;
    bufferImageHeight: number;
    imageSubresource: VkImageSubresourceLayersDeserialized[];
    imageOffset: VkOffset3DDeserialized[];
    imageExtent: VkExtent3DDeserialized[]
}
export interface VkImageResolveDeserialized {
    srcSubresource: VkImageSubresourceLayersDeserialized[];
    srcOffset: VkOffset3DDeserialized[];
    dstSubresource: VkImageSubresourceLayersDeserialized[];
    dstOffset: VkOffset3DDeserialized[];
    extent: VkExtent3DDeserialized[]
}
export interface VkShaderModuleCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    codeSize: number;
    pCode: number
}
export interface VkDescriptorSetLayoutBindingDeserialized {
    binding: number;
    descriptorType: number;
    descriptorCount?: number;
    stageFlags: number;
    pImmutableSamplers?: ptr64_t
}
export interface VkDescriptorSetLayoutCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    bindingCount?: number;
    pBindings: VkDescriptorSetLayoutBindingDeserialized
}
export interface VkDescriptorPoolSizeDeserialized {
    type: number;
    descriptorCount: number
}
export interface VkDescriptorPoolCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    maxSets: number;
    poolSizeCount?: number;
    pPoolSizes: VkDescriptorPoolSizeDeserialized
}
export interface VkDescriptorSetAllocateInfoDeserialized {
    pNext?: ptr64_t;
    descriptorPool: ptr64_t;
    descriptorSetCount: number;
    pSetLayouts: ptr64_t
}
export interface VkSpecializationMapEntryDeserialized {
    constantID: number;
    offset: number;
    size: number
}
export interface VkSpecializationInfoDeserialized {
    mapEntryCount?: number;
    pMapEntries: VkSpecializationMapEntryDeserialized;
    dataSize?: number;
    pData: ptr64_t
}
export interface VkPipelineShaderStageCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    stage: number;
    module?: ptr64_t;
    pName: string;
    pSpecializationInfo?: VkSpecializationInfoDeserialized
}
export interface VkComputePipelineCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    stage: VkPipelineShaderStageCreateInfoDeserialized[];
    layout: ptr64_t;
    basePipelineHandle?: ptr64_t;
    basePipelineIndex: number
}
export interface VkVertexInputBindingDescriptionDeserialized {
    binding: number;
    stride: number;
    inputRate: number
}
export interface VkVertexInputAttributeDescriptionDeserialized {
    location: number;
    binding: number;
    format: number;
    offset: number
}
export interface VkPipelineVertexInputStateCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    vertexBindingDescriptionCount?: number;
    pVertexBindingDescriptions: VkVertexInputBindingDescriptionDeserialized;
    vertexAttributeDescriptionCount?: number;
    pVertexAttributeDescriptions: VkVertexInputAttributeDescriptionDeserialized
}
export interface VkPipelineInputAssemblyStateCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    topology: number;
    primitiveRestartEnable: boolean
}
export interface VkPipelineTessellationStateCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    patchControlPoints: number
}
export interface VkPipelineViewportStateCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    viewportCount?: number;
    pViewports?: VkViewportDeserialized;
    scissorCount?: number;
    pScissors?: VkRect2DDeserialized
}
export interface VkPipelineRasterizationStateCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    depthClampEnable: boolean;
    rasterizerDiscardEnable: boolean;
    polygonMode: number;
    cullMode?: number;
    frontFace: number;
    depthBiasEnable: boolean;
    depthBiasConstantFactor: number;
    depthBiasClamp: number;
    depthBiasSlopeFactor: number;
    lineWidth: number
}
export interface VkPipelineMultisampleStateCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    rasterizationSamples: number;
    sampleShadingEnable: boolean;
    minSampleShading: number;
    pSampleMask?: number;
    alphaToCoverageEnable: boolean;
    alphaToOneEnable: boolean
}
export interface VkPipelineColorBlendAttachmentStateDeserialized {
    blendEnable: boolean;
    srcColorBlendFactor: number;
    dstColorBlendFactor: number;
    colorBlendOp: number;
    srcAlphaBlendFactor: number;
    dstAlphaBlendFactor: number;
    alphaBlendOp: number;
    colorWriteMask?: number
}
export interface VkPipelineColorBlendStateCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    logicOpEnable: boolean;
    logicOp: number;
    attachmentCount?: number;
    pAttachments?: VkPipelineColorBlendAttachmentStateDeserialized;
    blendConstants: number
}
export interface VkPipelineDynamicStateCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    dynamicStateCount?: number;
    pDynamicStates: number
}
export interface VkStencilOpStateDeserialized {
    failOp: number;
    passOp: number;
    depthFailOp: number;
    compareOp: number;
    compareMask: number;
    writeMask: number;
    reference: number
}
export interface VkPipelineDepthStencilStateCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    depthTestEnable: boolean;
    depthWriteEnable: boolean;
    depthCompareOp: number;
    depthBoundsTestEnable: boolean;
    stencilTestEnable: boolean;
    front: VkStencilOpStateDeserialized[];
    back: VkStencilOpStateDeserialized[];
    minDepthBounds: number;
    maxDepthBounds: number
}
export interface VkGraphicsPipelineCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    stageCount?: number;
    pStages?: VkPipelineShaderStageCreateInfoDeserialized;
    pVertexInputState?: VkPipelineVertexInputStateCreateInfoDeserialized;
    pInputAssemblyState?: VkPipelineInputAssemblyStateCreateInfoDeserialized;
    pTessellationState?: VkPipelineTessellationStateCreateInfoDeserialized;
    pViewportState?: VkPipelineViewportStateCreateInfoDeserialized;
    pRasterizationState?: VkPipelineRasterizationStateCreateInfoDeserialized;
    pMultisampleState?: VkPipelineMultisampleStateCreateInfoDeserialized;
    pDepthStencilState?: VkPipelineDepthStencilStateCreateInfoDeserialized;
    pColorBlendState?: VkPipelineColorBlendStateCreateInfoDeserialized;
    pDynamicState?: VkPipelineDynamicStateCreateInfoDeserialized;
    layout?: ptr64_t;
    renderPass?: ptr64_t;
    subpass: number;
    basePipelineHandle?: ptr64_t;
    basePipelineIndex: number
}
export interface VkPipelineCacheCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    initialDataSize?: number;
    pInitialData: ptr64_t
}
export interface VkPipelineCacheHeaderVersionOneDeserialized {
    headerSize: number;
    headerVersion: number;
    vendorID: number;
    deviceID: number;
    pipelineCacheUUID: number
}
export interface VkPushConstantRangeDeserialized {
    stageFlags: number;
    offset: number;
    size: number
}
export interface VkPipelineLayoutCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    setLayoutCount?: number;
    pSetLayouts: ptr64_t;
    pushConstantRangeCount?: number;
    pPushConstantRanges: VkPushConstantRangeDeserialized
}
export interface VkSamplerCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    magFilter: number;
    minFilter: number;
    mipmapMode: number;
    addressModeU: number;
    addressModeV: number;
    addressModeW: number;
    mipLodBias: number;
    anisotropyEnable: boolean;
    maxAnisotropy: number;
    compareEnable: boolean;
    compareOp: number;
    minLod: number;
    maxLod: number;
    borderColor: number;
    unnormalizedCoordinates: boolean
}
export interface VkCommandPoolCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    queueFamilyIndex: number
}
export interface VkCommandBufferAllocateInfoDeserialized {
    pNext?: ptr64_t;
    commandPool: ptr64_t;
    level: number;
    commandBufferCount: number
}
export interface VkCommandBufferInheritanceInfoDeserialized {
    pNext?: ptr64_t;
    renderPass?: ptr64_t;
    subpass: number;
    framebuffer?: ptr64_t;
    occlusionQueryEnable: boolean;
    queryFlags?: number;
    pipelineStatistics?: number
}
export interface VkCommandBufferBeginInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    pInheritanceInfo?: VkCommandBufferInheritanceInfoDeserialized
}
export interface VkRenderPassBeginInfoDeserialized {
    pNext?: ptr64_t;
    renderPass: ptr64_t;
    framebuffer: ptr64_t;
    renderArea: VkRect2DDeserialized[];
    clearValueCount?: number;
    pClearValues: VkClearValueDeserialized
}
export interface VkClearDepthStencilValueDeserialized {
    depth: number;
    stencil: number
}
export interface VkClearAttachmentDeserialized {
    aspectMask: number;
    colorAttachment: number;
    clearValue: VkClearValueDeserialized[]
}
export interface VkAttachmentDescriptionDeserialized {
    flags?: number;
    format: number;
    samples: number;
    loadOp: number;
    storeOp: number;
    stencilLoadOp: number;
    stencilStoreOp: number;
    initialLayout: number;
    finalLayout: number
}
export interface VkAttachmentReferenceDeserialized {
    attachment: number;
    layout: number
}
export interface VkSubpassDescriptionDeserialized {
    flags?: number;
    pipelineBindPoint: number;
    inputAttachmentCount?: number;
    pInputAttachments: VkAttachmentReferenceDeserialized;
    colorAttachmentCount?: number;
    pColorAttachments: VkAttachmentReferenceDeserialized;
    pResolveAttachments?: VkAttachmentReferenceDeserialized;
    pDepthStencilAttachment?: VkAttachmentReferenceDeserialized;
    preserveAttachmentCount?: number;
    pPreserveAttachments: number
}
export interface VkSubpassDependencyDeserialized {
    srcSubpass: number;
    dstSubpass: number;
    srcStageMask?: number;
    dstStageMask?: number;
    srcAccessMask?: number;
    dstAccessMask?: number;
    dependencyFlags?: number
}
export interface VkRenderPassCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    attachmentCount?: number;
    pAttachments: VkAttachmentDescriptionDeserialized;
    subpassCount: number;
    pSubpasses: VkSubpassDescriptionDeserialized;
    dependencyCount?: number;
    pDependencies: VkSubpassDependencyDeserialized
}
export interface VkEventCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number
}
export interface VkFenceCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number
}
export interface VkPhysicalDeviceFeaturesDeserialized {
    robustBufferAccess: boolean;
    fullDrawIndexUint32: boolean;
    imageCubeArray: boolean;
    independentBlend: boolean;
    geometryShader: boolean;
    tessellationShader: boolean;
    sampleRateShading: boolean;
    dualSrcBlend: boolean;
    logicOp: boolean;
    multiDrawIndirect: boolean;
    drawIndirectFirstInstance: boolean;
    depthClamp: boolean;
    depthBiasClamp: boolean;
    fillModeNonSolid: boolean;
    depthBounds: boolean;
    wideLines: boolean;
    largePoints: boolean;
    alphaToOne: boolean;
    multiViewport: boolean;
    samplerAnisotropy: boolean;
    textureCompressionETC2: boolean;
    textureCompressionASTC_LDR: boolean;
    textureCompressionBC: boolean;
    occlusionQueryPrecise: boolean;
    pipelineStatisticsQuery: boolean;
    vertexPipelineStoresAndAtomics: boolean;
    fragmentStoresAndAtomics: boolean;
    shaderTessellationAndGeometryPointSize: boolean;
    shaderImageGatherExtended: boolean;
    shaderStorageImageExtendedFormats: boolean;
    shaderStorageImageMultisample: boolean;
    shaderStorageImageReadWithoutFormat: boolean;
    shaderStorageImageWriteWithoutFormat: boolean;
    shaderUniformBufferArrayDynamicIndexing: boolean;
    shaderSampledImageArrayDynamicIndexing: boolean;
    shaderStorageBufferArrayDynamicIndexing: boolean;
    shaderStorageImageArrayDynamicIndexing: boolean;
    shaderClipDistance: boolean;
    shaderCullDistance: boolean;
    shaderFloat64: boolean;
    shaderInt64: boolean;
    shaderInt16: boolean;
    shaderResourceResidency: boolean;
    shaderResourceMinLod: boolean;
    sparseBinding: boolean;
    sparseResidencyBuffer: boolean;
    sparseResidencyImage2D: boolean;
    sparseResidencyImage3D: boolean;
    sparseResidency2Samples: boolean;
    sparseResidency4Samples: boolean;
    sparseResidency8Samples: boolean;
    sparseResidency16Samples: boolean;
    sparseResidencyAliased: boolean;
    variableMultisampleRate: boolean;
    inheritedQueries: boolean
}
export interface VkPhysicalDeviceSparsePropertiesDeserialized {
    residencyStandard2DBlockShape: boolean;
    residencyStandard2DMultisampleBlockShape: boolean;
    residencyStandard3DBlockShape: boolean;
    residencyAlignedMipSize: boolean;
    residencyNonResidentStrict: boolean
}
export interface VkPhysicalDeviceLimitsDeserialized {
    maxImageDimension1D: number;
    maxImageDimension2D: number;
    maxImageDimension3D: number;
    maxImageDimensionCube: number;
    maxImageArrayLayers: number;
    maxTexelBufferElements: number;
    maxUniformBufferRange: number;
    maxStorageBufferRange: number;
    maxPushConstantsSize: number;
    maxMemoryAllocationCount: number;
    maxSamplerAllocationCount: number;
    bufferImageGranularity: number;
    sparseAddressSpaceSize: number;
    maxBoundDescriptorSets: number;
    maxPerStageDescriptorSamplers: number;
    maxPerStageDescriptorUniformBuffers: number;
    maxPerStageDescriptorStorageBuffers: number;
    maxPerStageDescriptorSampledImages: number;
    maxPerStageDescriptorStorageImages: number;
    maxPerStageDescriptorInputAttachments: number;
    maxPerStageResources: number;
    maxDescriptorSetSamplers: number;
    maxDescriptorSetUniformBuffers: number;
    maxDescriptorSetUniformBuffersDynamic: number;
    maxDescriptorSetStorageBuffers: number;
    maxDescriptorSetStorageBuffersDynamic: number;
    maxDescriptorSetSampledImages: number;
    maxDescriptorSetStorageImages: number;
    maxDescriptorSetInputAttachments: number;
    maxVertexInputAttributes: number;
    maxVertexInputBindings: number;
    maxVertexInputAttributeOffset: number;
    maxVertexInputBindingStride: number;
    maxVertexOutputComponents: number;
    maxTessellationGenerationLevel: number;
    maxTessellationPatchSize: number;
    maxTessellationControlPerVertexInputComponents: number;
    maxTessellationControlPerVertexOutputComponents: number;
    maxTessellationControlPerPatchOutputComponents: number;
    maxTessellationControlTotalOutputComponents: number;
    maxTessellationEvaluationInputComponents: number;
    maxTessellationEvaluationOutputComponents: number;
    maxGeometryShaderInvocations: number;
    maxGeometryInputComponents: number;
    maxGeometryOutputComponents: number;
    maxGeometryOutputVertices: number;
    maxGeometryTotalOutputComponents: number;
    maxFragmentInputComponents: number;
    maxFragmentOutputAttachments: number;
    maxFragmentDualSrcAttachments: number;
    maxFragmentCombinedOutputResources: number;
    maxComputeSharedMemorySize: number;
    maxComputeWorkGroupCount: number;
    maxComputeWorkGroupInvocations: number;
    maxComputeWorkGroupSize: number;
    subPixelPrecisionBits: number;
    subTexelPrecisionBits: number;
    mipmapPrecisionBits: number;
    maxDrawIndexedIndexValue: number;
    maxDrawIndirectCount: number;
    maxSamplerLodBias: number;
    maxSamplerAnisotropy: number;
    maxViewports: number;
    maxViewportDimensions: number;
    viewportBoundsRange: number;
    viewportSubPixelBits: number;
    minMemoryMapAlignment: number;
    minTexelBufferOffsetAlignment: number;
    minUniformBufferOffsetAlignment: number;
    minStorageBufferOffsetAlignment: number;
    minTexelOffset: number;
    maxTexelOffset: number;
    minTexelGatherOffset: number;
    maxTexelGatherOffset: number;
    minInterpolationOffset: number;
    maxInterpolationOffset: number;
    subPixelInterpolationOffsetBits: number;
    maxFramebufferWidth: number;
    maxFramebufferHeight: number;
    maxFramebufferLayers: number;
    framebufferColorSampleCounts?: number;
    framebufferDepthSampleCounts?: number;
    framebufferStencilSampleCounts?: number;
    framebufferNoAttachmentsSampleCounts?: number;
    maxColorAttachments: number;
    sampledImageColorSampleCounts?: number;
    sampledImageIntegerSampleCounts?: number;
    sampledImageDepthSampleCounts?: number;
    sampledImageStencilSampleCounts?: number;
    storageImageSampleCounts?: number;
    maxSampleMaskWords: number;
    timestampComputeAndGraphics: boolean;
    timestampPeriod: number;
    maxClipDistances: number;
    maxCullDistances: number;
    maxCombinedClipAndCullDistances: number;
    discreteQueuePriorities: number;
    pointSizeRange: number;
    lineWidthRange: number;
    pointSizeGranularity: number;
    lineWidthGranularity: number;
    strictLines: boolean;
    standardSampleLocations: boolean;
    optimalBufferCopyOffsetAlignment: number;
    optimalBufferCopyRowPitchAlignment: number;
    nonCoherentAtomSize: number
}
export interface VkSemaphoreCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number
}
export interface VkQueryPoolCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    queryType: number;
    queryCount: number;
    pipelineStatistics?: number
}
export interface VkFramebufferCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    renderPass: ptr64_t;
    attachmentCount?: number;
    pAttachments: ptr64_t;
    width: number;
    height: number;
    layers: number
}
export interface VkDrawIndirectCommandDeserialized {
    vertexCount: number;
    instanceCount: number;
    firstVertex: number;
    firstInstance: number
}
export interface VkDrawIndexedIndirectCommandDeserialized {
    indexCount: number;
    instanceCount: number;
    firstIndex: number;
    vertexOffset: number;
    firstInstance: number
}
export interface VkDispatchIndirectCommandDeserialized {
    x: number;
    y: number;
    z: number
}
export interface VkMultiDrawInfoEXTDeserialized {
    firstVertex: number;
    vertexCount: number
}
export interface VkMultiDrawIndexedInfoEXTDeserialized {
    firstIndex: number;
    indexCount: number;
    vertexOffset: number
}
export interface VkSubmitInfoDeserialized {
    pNext?: ptr64_t;
    waitSemaphoreCount?: number;
    pWaitSemaphores: ptr64_t;
    pWaitDstStageMask: number;
    commandBufferCount?: number;
    pCommandBuffers: ptr64_t;
    signalSemaphoreCount?: number;
    pSignalSemaphores: ptr64_t
}
export interface VkDisplayPropertiesKHRDeserialized {
    display: ptr64_t;
    displayName: string;
    physicalDimensions: VkExtent2DDeserialized[];
    physicalResolution: VkExtent2DDeserialized[];
    supportedTransforms?: number;
    planeReorderPossible: boolean;
    persistentContent: boolean
}
export interface VkDisplayPlanePropertiesKHRDeserialized {
    currentDisplay: ptr64_t;
    currentStackIndex: number
}
export interface VkDisplayModeParametersKHRDeserialized {
    visibleRegion: VkExtent2DDeserialized[];
    refreshRate: number
}
export interface VkDisplayModePropertiesKHRDeserialized {
    displayMode: ptr64_t;
    parameters: VkDisplayModeParametersKHRDeserialized[]
}
export interface VkDisplayModeCreateInfoKHRDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    parameters: VkDisplayModeParametersKHRDeserialized[]
}
export interface VkDisplayPlaneCapabilitiesKHRDeserialized {
    supportedAlpha?: number;
    minSrcPosition: VkOffset2DDeserialized[];
    maxSrcPosition: VkOffset2DDeserialized[];
    minSrcExtent: VkExtent2DDeserialized[];
    maxSrcExtent: VkExtent2DDeserialized[];
    minDstPosition: VkOffset2DDeserialized[];
    maxDstPosition: VkOffset2DDeserialized[];
    minDstExtent: VkExtent2DDeserialized[];
    maxDstExtent: VkExtent2DDeserialized[]
}
export interface VkDisplaySurfaceCreateInfoKHRDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    displayMode: ptr64_t;
    planeIndex: number;
    planeStackIndex: number;
    transform: number;
    globalAlpha: number;
    alphaMode: number;
    imageExtent: VkExtent2DDeserialized[]
}
export interface VkDisplayPresentInfoKHRDeserialized {
    pNext?: ptr64_t;
    srcRect: VkRect2DDeserialized[];
    dstRect: VkRect2DDeserialized[];
    persistent: boolean
}
export interface VkSurfaceCapabilitiesKHRDeserialized {
    minImageCount: number;
    maxImageCount: number;
    currentExtent: VkExtent2DDeserialized[];
    minImageExtent: VkExtent2DDeserialized[];
    maxImageExtent: VkExtent2DDeserialized[];
    maxImageArrayLayers: number;
    supportedTransforms: number;
    currentTransform: number;
    supportedCompositeAlpha: number;
    supportedUsageFlags: number
}
export interface VkSurfaceFormatKHRDeserialized {
    format: number;
    colorSpace: number
}
export interface VkSwapchainCreateInfoKHRDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    surface: ptr64_t;
    minImageCount: number;
    imageFormat: number;
    imageColorSpace: number;
    imageExtent: VkExtent2DDeserialized[];
    imageArrayLayers: number;
    imageUsage: number;
    imageSharingMode: number;
    queueFamilyIndexCount?: number;
    pQueueFamilyIndices: number;
    preTransform: number;
    compositeAlpha: number;
    presentMode: number;
    clipped: boolean;
    oldSwapchain?: ptr64_t
}
export interface VkPresentInfoKHRDeserialized {
    pNext?: ptr64_t;
    waitSemaphoreCount?: number;
    pWaitSemaphores: ptr64_t;
    swapchainCount: number;
    pSwapchains: ptr64_t;
    pImageIndices: number;
    pResults?: number
}
export interface VkValidationFlagsEXTDeserialized {
    pNext?: ptr64_t;
    disabledValidationCheckCount: number;
    pDisabledValidationChecks: number
}
export interface VkValidationFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    enabledValidationFeatureCount?: number;
    pEnabledValidationFeatures: number;
    disabledValidationFeatureCount?: number;
    pDisabledValidationFeatures: number
}
export interface VkDevicePrivateDataCreateInfoDeserialized {
    pNext?: ptr64_t;
    privateDataSlotRequestCount: number
}
export interface VkDevicePrivateDataCreateInfoEXTDeserialized {

}
export interface VkPrivateDataSlotCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags: number
}
export interface VkPrivateDataSlotCreateInfoEXTDeserialized {

}
export interface VkPhysicalDevicePrivateDataFeaturesDeserialized {
    pNext?: ptr64_t;
    privateData: boolean
}
export interface VkPhysicalDevicePrivateDataFeaturesEXTDeserialized {

}
export interface VkPhysicalDeviceMultiDrawPropertiesEXTDeserialized {
    pNext?: ptr64_t;
    maxMultiDrawCount: number
}
export interface VkPhysicalDeviceFeatures2Deserialized {
    pNext?: ptr64_t;
    features: VkPhysicalDeviceFeaturesDeserialized[]
}
export interface VkPhysicalDeviceFeatures2KHRDeserialized {

}
export interface VkPhysicalDeviceProperties2Deserialized {
    pNext?: ptr64_t;
    properties: VkPhysicalDevicePropertiesDeserialized[]
}
export interface VkPhysicalDeviceProperties2KHRDeserialized {

}
export interface VkFormatProperties2Deserialized {
    pNext?: ptr64_t;
    formatProperties: VkFormatPropertiesDeserialized[]
}
export interface VkFormatProperties2KHRDeserialized {

}
export interface VkImageFormatProperties2Deserialized {
    pNext?: ptr64_t;
    imageFormatProperties: VkImageFormatPropertiesDeserialized[]
}
export interface VkImageFormatProperties2KHRDeserialized {

}
export interface VkPhysicalDeviceImageFormatInfo2Deserialized {
    pNext?: ptr64_t;
    format: number;
    type: number;
    tiling: number;
    usage: number;
    flags?: number
}
export interface VkPhysicalDeviceImageFormatInfo2KHRDeserialized {

}
export interface VkQueueFamilyProperties2Deserialized {
    pNext?: ptr64_t;
    queueFamilyProperties: VkQueueFamilyPropertiesDeserialized[]
}
export interface VkQueueFamilyProperties2KHRDeserialized {

}
export interface VkPhysicalDeviceMemoryProperties2Deserialized {
    pNext?: ptr64_t;
    memoryProperties: VkPhysicalDeviceMemoryPropertiesDeserialized[]
}
export interface VkPhysicalDeviceMemoryProperties2KHRDeserialized {

}
export interface VkSparseImageFormatProperties2Deserialized {
    pNext?: ptr64_t;
    properties: VkSparseImageFormatPropertiesDeserialized[]
}
export interface VkSparseImageFormatProperties2KHRDeserialized {

}
export interface VkPhysicalDeviceSparseImageFormatInfo2Deserialized {
    pNext?: ptr64_t;
    format: number;
    type: number;
    samples: number;
    usage: number;
    tiling: number
}
export interface VkPhysicalDeviceSparseImageFormatInfo2KHRDeserialized {

}
export interface VkPhysicalDevicePushDescriptorPropertiesKHRDeserialized {
    pNext?: ptr64_t;
    maxPushDescriptors: number
}
export interface VkConformanceVersionDeserialized {
    major: number;
    minor: number;
    subminor: number;
    patch: number
}
export interface VkConformanceVersionKHRDeserialized {

}
export interface VkPhysicalDeviceDriverPropertiesDeserialized {
    pNext?: ptr64_t;
    driverID: number;
    driverName: string;
    driverInfo: string;
    conformanceVersion: VkConformanceVersionDeserialized[]
}
export interface VkPhysicalDeviceDriverPropertiesKHRDeserialized {

}
export interface VkPresentRegionsKHRDeserialized {
    pNext?: ptr64_t;
    swapchainCount: number;
    pRegions?: VkPresentRegionKHRDeserialized
}
export interface VkPresentRegionKHRDeserialized {
    rectangleCount?: number;
    pRectangles?: VkRectLayerKHRDeserialized
}
export interface VkRectLayerKHRDeserialized {
    offset: VkOffset2DDeserialized[];
    extent: VkExtent2DDeserialized[];
    layer: number
}
export interface VkPhysicalDeviceVariablePointersFeaturesDeserialized {
    pNext?: ptr64_t;
    variablePointersStorageBuffer: boolean;
    variablePointers: boolean
}
export interface VkPhysicalDeviceVariablePointersFeaturesKHRDeserialized {

}
export interface VkPhysicalDeviceVariablePointerFeaturesKHRDeserialized {

}
export interface VkPhysicalDeviceVariablePointerFeaturesDeserialized {

}
export interface VkExternalMemoryPropertiesDeserialized {
    externalMemoryFeatures: number;
    exportFromImportedHandleTypes?: number;
    compatibleHandleTypes: number
}
export interface VkPhysicalDeviceExternalImageFormatInfoDeserialized {
    pNext?: ptr64_t;
    handleType?: number
}
export interface VkExternalImageFormatPropertiesDeserialized {
    pNext?: ptr64_t;
    externalMemoryProperties: VkExternalMemoryPropertiesDeserialized[]
}
export interface VkPhysicalDeviceExternalBufferInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    usage: number;
    handleType: number
}
export interface VkExternalBufferPropertiesDeserialized {
    pNext?: ptr64_t;
    externalMemoryProperties: VkExternalMemoryPropertiesDeserialized[]
}
export interface VkPhysicalDeviceIDPropertiesDeserialized {
    pNext?: ptr64_t;
    deviceUUID: number;
    driverUUID: number;
    deviceLUID: number;
    deviceNodeMask: number;
    deviceLUIDValid: boolean
}
export interface VkExternalMemoryImageCreateInfoDeserialized {
    pNext?: ptr64_t;
    handleTypes?: number
}
export interface VkExternalMemoryBufferCreateInfoDeserialized {
    pNext?: ptr64_t;
    handleTypes?: number
}
export interface VkExportMemoryAllocateInfoDeserialized {
    pNext?: ptr64_t;
    handleTypes?: number
}
export interface VkPhysicalDeviceExternalSemaphoreInfoDeserialized {
    pNext?: ptr64_t;
    handleType: number
}
export interface VkExternalSemaphorePropertiesDeserialized {
    pNext?: ptr64_t;
    exportFromImportedHandleTypes: number;
    compatibleHandleTypes: number;
    externalSemaphoreFeatures?: number
}
export interface VkExportSemaphoreCreateInfoDeserialized {
    pNext?: ptr64_t;
    handleTypes?: number
}
export interface VkPhysicalDeviceExternalFenceInfoDeserialized {
    pNext?: ptr64_t;
    handleType: number
}
export interface VkExternalFencePropertiesDeserialized {
    pNext?: ptr64_t;
    exportFromImportedHandleTypes: number;
    compatibleHandleTypes: number;
    externalFenceFeatures?: number
}
export interface VkExportFenceCreateInfoDeserialized {
    pNext?: ptr64_t;
    handleTypes?: number
}
export interface VkPhysicalDeviceMultiviewFeaturesDeserialized {
    pNext?: ptr64_t;
    multiview: boolean;
    multiviewGeometryShader: boolean;
    multiviewTessellationShader: boolean
}
export interface VkPhysicalDeviceMultiviewFeaturesKHRDeserialized {

}
export interface VkPhysicalDeviceMultiviewPropertiesDeserialized {
    pNext?: ptr64_t;
    maxMultiviewViewCount: number;
    maxMultiviewInstanceIndex: number
}
export interface VkPhysicalDeviceMultiviewPropertiesKHRDeserialized {

}
export interface VkRenderPassMultiviewCreateInfoDeserialized {
    pNext?: ptr64_t;
    subpassCount?: number;
    pViewMasks: number;
    dependencyCount?: number;
    pViewOffsets: number;
    correlationMaskCount?: number;
    pCorrelationMasks: number
}
export interface VkRenderPassMultiviewCreateInfoKHRDeserialized {

}
export interface VkPhysicalDeviceGroupPropertiesDeserialized {
    pNext?: ptr64_t;
    physicalDeviceCount: number;
    physicalDevices: ptr64_t;
    subsetAllocation: boolean
}
export interface VkPhysicalDeviceGroupPropertiesKHRDeserialized {

}
export interface VkMemoryAllocateFlagsInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    deviceMask: number
}
export interface VkMemoryAllocateFlagsInfoKHRDeserialized {

}
export interface VkBindBufferMemoryInfoDeserialized {
    pNext?: ptr64_t;
    buffer: ptr64_t;
    memory: ptr64_t;
    memoryOffset: number
}
export interface VkBindBufferMemoryInfoKHRDeserialized {

}
export interface VkBindBufferMemoryDeviceGroupInfoDeserialized {
    pNext?: ptr64_t;
    deviceIndexCount?: number;
    pDeviceIndices: number
}
export interface VkBindBufferMemoryDeviceGroupInfoKHRDeserialized {

}
export interface VkBindImageMemoryInfoDeserialized {
    pNext?: ptr64_t;
    image: ptr64_t;
    memory: ptr64_t;
    memoryOffset: number
}
export interface VkBindImageMemoryInfoKHRDeserialized {

}
export interface VkBindImageMemoryDeviceGroupInfoDeserialized {
    pNext?: ptr64_t;
    deviceIndexCount?: number;
    pDeviceIndices: number;
    splitInstanceBindRegionCount?: number;
    pSplitInstanceBindRegions: VkRect2DDeserialized
}
export interface VkBindImageMemoryDeviceGroupInfoKHRDeserialized {

}
export interface VkDeviceGroupRenderPassBeginInfoDeserialized {
    pNext?: ptr64_t;
    deviceMask: number;
    deviceRenderAreaCount?: number;
    pDeviceRenderAreas: VkRect2DDeserialized
}
export interface VkDeviceGroupRenderPassBeginInfoKHRDeserialized {

}
export interface VkDeviceGroupCommandBufferBeginInfoDeserialized {
    pNext?: ptr64_t;
    deviceMask: number
}
export interface VkDeviceGroupCommandBufferBeginInfoKHRDeserialized {

}
export interface VkDeviceGroupSubmitInfoDeserialized {
    pNext?: ptr64_t;
    waitSemaphoreCount?: number;
    pWaitSemaphoreDeviceIndices: number;
    commandBufferCount?: number;
    pCommandBufferDeviceMasks: number;
    signalSemaphoreCount?: number;
    pSignalSemaphoreDeviceIndices: number
}
export interface VkDeviceGroupSubmitInfoKHRDeserialized {

}
export interface VkDeviceGroupBindSparseInfoDeserialized {
    pNext?: ptr64_t;
    resourceDeviceIndex: number;
    memoryDeviceIndex: number
}
export interface VkDeviceGroupBindSparseInfoKHRDeserialized {

}
export interface VkDeviceGroupPresentCapabilitiesKHRDeserialized {
    pNext?: ptr64_t;
    presentMask: number;
    modes: number
}
export interface VkImageSwapchainCreateInfoKHRDeserialized {
    pNext?: ptr64_t;
    swapchain?: ptr64_t
}
export interface VkBindImageMemorySwapchainInfoKHRDeserialized {
    pNext?: ptr64_t;
    swapchain: ptr64_t;
    imageIndex: number
}
export interface VkAcquireNextImageInfoKHRDeserialized {
    pNext?: ptr64_t;
    swapchain: ptr64_t;
    timeout: number;
    semaphore?: ptr64_t;
    fence?: ptr64_t;
    deviceMask: number
}
export interface VkDeviceGroupPresentInfoKHRDeserialized {
    pNext?: ptr64_t;
    swapchainCount?: number;
    pDeviceMasks: number;
    mode: number
}
export interface VkDeviceGroupDeviceCreateInfoDeserialized {
    pNext?: ptr64_t;
    physicalDeviceCount?: number;
    pPhysicalDevices: ptr64_t
}
export interface VkDeviceGroupDeviceCreateInfoKHRDeserialized {

}
export interface VkDeviceGroupSwapchainCreateInfoKHRDeserialized {
    pNext?: ptr64_t;
    modes: number
}
export interface VkDescriptorUpdateTemplateEntryDeserialized {
    dstBinding: number;
    dstArrayElement: number;
    descriptorCount: number;
    descriptorType: number;
    offset: number;
    stride: number
}
export interface VkDescriptorUpdateTemplateEntryKHRDeserialized {

}
export interface VkDescriptorUpdateTemplateCreateInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    descriptorUpdateEntryCount: number;
    pDescriptorUpdateEntries: VkDescriptorUpdateTemplateEntryDeserialized;
    templateType: number;
    descriptorSetLayout: ptr64_t;
    pipelineBindPoint: number;
    pipelineLayout: ptr64_t;
    set: number
}
export interface VkDescriptorUpdateTemplateCreateInfoKHRDeserialized {

}
export interface VkXYColorEXTDeserialized {
    x: number;
    y: number
}
export interface VkPhysicalDevicePresentIdFeaturesKHRDeserialized {
    pNext?: ptr64_t;
    presentId: boolean
}
export interface VkPresentIdKHRDeserialized {
    pNext?: ptr64_t;
    swapchainCount: number;
    pPresentIds?: number
}
export interface VkPhysicalDevicePresentWaitFeaturesKHRDeserialized {
    pNext?: ptr64_t;
    presentWait: boolean
}
export interface VkHdrMetadataEXTDeserialized {
    pNext?: ptr64_t;
    displayPrimaryRed: VkXYColorEXTDeserialized[];
    displayPrimaryGreen: VkXYColorEXTDeserialized[];
    displayPrimaryBlue: VkXYColorEXTDeserialized[];
    whitePoint: VkXYColorEXTDeserialized[];
    maxLuminance: number;
    minLuminance: number;
    maxContentLightLevel: number;
    maxFrameAverageLightLevel: number
}
export interface VkInputAttachmentAspectReferenceDeserialized {
    subpass: number;
    inputAttachmentIndex: number;
    aspectMask: number
}
export interface VkRenderPassInputAttachmentAspectCreateInfoDeserialized {
    pNext?: ptr64_t;
    aspectReferenceCount: number;
    pAspectReferences: VkInputAttachmentAspectReferenceDeserialized
}
export interface VkPhysicalDeviceSurfaceInfo2KHRDeserialized {
    pNext?: ptr64_t;
    surface?: ptr64_t
}
export interface VkSurfaceCapabilities2KHRDeserialized {
    pNext?: ptr64_t;
    surfaceCapabilities: VkSurfaceCapabilitiesKHRDeserialized[]
}
export interface VkSurfaceFormat2KHRDeserialized {
    pNext?: ptr64_t;
    surfaceFormat: VkSurfaceFormatKHRDeserialized[]
}
export interface VkDisplayProperties2KHRDeserialized {
    pNext?: ptr64_t;
    displayProperties: VkDisplayPropertiesKHRDeserialized[]
}
export interface VkDisplayPlaneProperties2KHRDeserialized {
    pNext?: ptr64_t;
    displayPlaneProperties: VkDisplayPlanePropertiesKHRDeserialized[]
}
export interface VkDisplayModeProperties2KHRDeserialized {
    pNext?: ptr64_t;
    displayModeProperties: VkDisplayModePropertiesKHRDeserialized[]
}
export interface VkDisplayPlaneInfo2KHRDeserialized {
    pNext?: ptr64_t;
    mode: ptr64_t;
    planeIndex: number
}
export interface VkDisplayPlaneCapabilities2KHRDeserialized {
    pNext?: ptr64_t;
    capabilities: VkDisplayPlaneCapabilitiesKHRDeserialized[]
}
export interface VkSharedPresentSurfaceCapabilitiesKHRDeserialized {
    pNext?: ptr64_t;
    sharedPresentSupportedUsageFlags?: number
}
export interface VkPhysicalDevice16BitStorageFeaturesDeserialized {
    pNext?: ptr64_t;
    storageBuffer16BitAccess: boolean;
    uniformAndStorageBuffer16BitAccess: boolean;
    storagePushConstant16: boolean;
    storageInputOutput16: boolean
}
export interface VkPhysicalDevice16BitStorageFeaturesKHRDeserialized {

}
export interface VkPhysicalDeviceSubgroupPropertiesDeserialized {
    pNext?: ptr64_t;
    subgroupSize: number;
    supportedStages: number;
    supportedOperations: number;
    quadOperationsInAllStages: boolean
}
export interface VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesDeserialized {
    pNext?: ptr64_t;
    shaderSubgroupExtendedTypes: boolean
}
export interface VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHRDeserialized {

}
export interface VkBufferMemoryRequirementsInfo2Deserialized {
    pNext?: ptr64_t;
    buffer: ptr64_t
}
export interface VkBufferMemoryRequirementsInfo2KHRDeserialized {

}
export interface VkDeviceBufferMemoryRequirementsDeserialized {
    pNext?: ptr64_t;
    pCreateInfo: VkBufferCreateInfoDeserialized
}
export interface VkImageMemoryRequirementsInfo2Deserialized {
    pNext?: ptr64_t;
    image: ptr64_t
}
export interface VkImageMemoryRequirementsInfo2KHRDeserialized {

}
export interface VkImageSparseMemoryRequirementsInfo2Deserialized {
    pNext?: ptr64_t;
    image: ptr64_t
}
export interface VkImageSparseMemoryRequirementsInfo2KHRDeserialized {

}
export interface VkDeviceImageMemoryRequirementsDeserialized {
    pNext?: ptr64_t;
    pCreateInfo: VkImageCreateInfoDeserialized;
    planeAspect?: number
}
export interface VkMemoryRequirements2Deserialized {
    pNext?: ptr64_t;
    memoryRequirements: VkMemoryRequirementsDeserialized[]
}
export interface VkSparseImageMemoryRequirements2Deserialized {
    pNext?: ptr64_t;
    memoryRequirements: VkSparseImageMemoryRequirementsDeserialized[]
}
export interface VkSparseImageMemoryRequirements2KHRDeserialized {

}
export interface VkPhysicalDevicePointClippingPropertiesDeserialized {
    pNext?: ptr64_t;
    pointClippingBehavior: number
}
export interface VkMemoryDedicatedRequirementsDeserialized {
    pNext?: ptr64_t;
    prefersDedicatedAllocation: boolean;
    requiresDedicatedAllocation: boolean
}
export interface VkMemoryDedicatedRequirementsKHRDeserialized {

}
export interface VkMemoryDedicatedAllocateInfoDeserialized {
    pNext?: ptr64_t;
    image?: ptr64_t;
    buffer?: ptr64_t
}
export interface VkMemoryDedicatedAllocateInfoKHRDeserialized {

}
export interface VkImageViewUsageCreateInfoDeserialized {
    pNext?: ptr64_t;
    usage: number
}
export interface VkPipelineTessellationDomainOriginStateCreateInfoDeserialized {
    pNext?: ptr64_t;
    domainOrigin: number
}
export interface VkSamplerYcbcrConversionInfoDeserialized {
    pNext?: ptr64_t;
    conversion: ptr64_t
}
export interface VkSamplerYcbcrConversionInfoKHRDeserialized {

}
export interface VkSamplerYcbcrConversionCreateInfoDeserialized {
    pNext?: ptr64_t;
    format: number;
    ycbcrModel: number;
    ycbcrRange: number;
    components: VkComponentMappingDeserialized[];
    xChromaOffset: number;
    yChromaOffset: number;
    chromaFilter: number;
    forceExplicitReconstruction: boolean
}
export interface VkSamplerYcbcrConversionCreateInfoKHRDeserialized {

}
export interface VkBindImagePlaneMemoryInfoDeserialized {
    pNext?: ptr64_t;
    planeAspect: number
}
export interface VkBindImagePlaneMemoryInfoKHRDeserialized {

}
export interface VkImagePlaneMemoryRequirementsInfoDeserialized {
    pNext?: ptr64_t;
    planeAspect: number
}
export interface VkImagePlaneMemoryRequirementsInfoKHRDeserialized {

}
export interface VkPhysicalDeviceSamplerYcbcrConversionFeaturesDeserialized {
    pNext?: ptr64_t;
    samplerYcbcrConversion: boolean
}
export interface VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHRDeserialized {

}
export interface VkSamplerYcbcrConversionImageFormatPropertiesDeserialized {
    pNext?: ptr64_t;
    combinedImageSamplerDescriptorCount: number
}
export interface VkSamplerYcbcrConversionImageFormatPropertiesKHRDeserialized {

}
export interface VkProtectedSubmitInfoDeserialized {
    pNext?: ptr64_t;
    protectedSubmit: boolean
}
export interface VkPhysicalDeviceProtectedMemoryFeaturesDeserialized {
    pNext?: ptr64_t;
    protectedMemory: boolean
}
export interface VkPhysicalDeviceProtectedMemoryPropertiesDeserialized {
    pNext?: ptr64_t;
    protectedNoFault: boolean
}
export interface VkDeviceQueueInfo2Deserialized {
    pNext?: ptr64_t;
    flags?: number;
    queueFamilyIndex: number;
    queueIndex: number
}
export interface VkPhysicalDeviceSamplerFilterMinmaxPropertiesDeserialized {
    pNext?: ptr64_t;
    filterMinmaxSingleComponentFormats: boolean;
    filterMinmaxImageComponentMapping: boolean
}
export interface VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXTDeserialized {

}
export interface VkSampleLocationEXTDeserialized {
    x: number;
    y: number
}
export interface VkSampleLocationsInfoEXTDeserialized {
    pNext?: ptr64_t;
    sampleLocationsPerPixel: number;
    sampleLocationGridSize: VkExtent2DDeserialized[];
    sampleLocationsCount?: number;
    pSampleLocations: VkSampleLocationEXTDeserialized
}
export interface VkAttachmentSampleLocationsEXTDeserialized {
    attachmentIndex: number;
    sampleLocationsInfo: VkSampleLocationsInfoEXTDeserialized[]
}
export interface VkSubpassSampleLocationsEXTDeserialized {
    subpassIndex: number;
    sampleLocationsInfo: VkSampleLocationsInfoEXTDeserialized[]
}
export interface VkRenderPassSampleLocationsBeginInfoEXTDeserialized {
    pNext?: ptr64_t;
    attachmentInitialSampleLocationsCount?: number;
    pAttachmentInitialSampleLocations: VkAttachmentSampleLocationsEXTDeserialized;
    postSubpassSampleLocationsCount?: number;
    pPostSubpassSampleLocations: VkSubpassSampleLocationsEXTDeserialized
}
export interface VkPipelineSampleLocationsStateCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    sampleLocationsEnable: boolean;
    sampleLocationsInfo: VkSampleLocationsInfoEXTDeserialized[]
}
export interface VkPhysicalDeviceSampleLocationsPropertiesEXTDeserialized {
    pNext?: ptr64_t;
    sampleLocationSampleCounts: number;
    maxSampleLocationGridSize: VkExtent2DDeserialized[];
    sampleLocationCoordinateRange: number;
    sampleLocationSubPixelBits: number;
    variableSampleLocations: boolean
}
export interface VkMultisamplePropertiesEXTDeserialized {
    pNext?: ptr64_t;
    maxSampleLocationGridSize: VkExtent2DDeserialized[]
}
export interface VkSamplerReductionModeCreateInfoDeserialized {
    pNext?: ptr64_t;
    reductionMode: number
}
export interface VkSamplerReductionModeCreateInfoEXTDeserialized {

}
export interface VkPhysicalDeviceMultiDrawFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    multiDraw: boolean
}
export interface VkPhysicalDeviceInlineUniformBlockFeaturesDeserialized {
    pNext?: ptr64_t;
    inlineUniformBlock: boolean;
    descriptorBindingInlineUniformBlockUpdateAfterBind: boolean
}
export interface VkPhysicalDeviceInlineUniformBlockFeaturesEXTDeserialized {

}
export interface VkPhysicalDeviceInlineUniformBlockPropertiesDeserialized {
    pNext?: ptr64_t;
    maxInlineUniformBlockSize: number;
    maxPerStageDescriptorInlineUniformBlocks: number;
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: number;
    maxDescriptorSetInlineUniformBlocks: number;
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks: number
}
export interface VkPhysicalDeviceInlineUniformBlockPropertiesEXTDeserialized {

}
export interface VkWriteDescriptorSetInlineUniformBlockDeserialized {
    pNext?: ptr64_t;
    dataSize: number;
    pData: ptr64_t
}
export interface VkWriteDescriptorSetInlineUniformBlockEXTDeserialized {

}
export interface VkDescriptorPoolInlineUniformBlockCreateInfoDeserialized {
    pNext?: ptr64_t;
    maxInlineUniformBlockBindings: number
}
export interface VkDescriptorPoolInlineUniformBlockCreateInfoEXTDeserialized {

}
export interface VkImageFormatListCreateInfoDeserialized {
    pNext?: ptr64_t;
    viewFormatCount?: number;
    pViewFormats: number
}
export interface VkImageFormatListCreateInfoKHRDeserialized {

}
export interface VkValidationCacheCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    initialDataSize?: number;
    pInitialData: ptr64_t
}
export interface VkShaderModuleValidationCacheCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    validationCache: ptr64_t
}
export interface VkPhysicalDeviceMaintenance3PropertiesDeserialized {
    pNext?: ptr64_t;
    maxPerSetDescriptors: number;
    maxMemoryAllocationSize: number
}
export interface VkPhysicalDeviceMaintenance4FeaturesDeserialized {
    pNext?: ptr64_t;
    maintenance4: boolean
}
export interface VkPhysicalDeviceMaintenance4PropertiesDeserialized {
    pNext?: ptr64_t;
    maxBufferSize: number
}
export interface VkDescriptorSetLayoutSupportDeserialized {
    pNext?: ptr64_t;
    supported: boolean
}
export interface VkPhysicalDeviceShaderDrawParametersFeaturesDeserialized {
    pNext?: ptr64_t;
    shaderDrawParameters: boolean
}
export interface VkPhysicalDeviceShaderDrawParameterFeaturesDeserialized {

}
export interface VkPhysicalDeviceShaderFloat16Int8FeaturesDeserialized {
    pNext?: ptr64_t;
    shaderFloat16: boolean;
    shaderInt8: boolean
}
export interface VkPhysicalDeviceShaderFloat16Int8FeaturesKHRDeserialized {

}
export interface VkPhysicalDeviceFloat16Int8FeaturesKHRDeserialized {

}
export interface VkPhysicalDeviceFloatControlsPropertiesDeserialized {
    pNext?: ptr64_t;
    denormBehaviorIndependence: number;
    roundingModeIndependence: number;
    shaderSignedZeroInfNanPreserveFloat16: boolean;
    shaderSignedZeroInfNanPreserveFloat32: boolean;
    shaderSignedZeroInfNanPreserveFloat64: boolean;
    shaderDenormPreserveFloat16: boolean;
    shaderDenormPreserveFloat32: boolean;
    shaderDenormPreserveFloat64: boolean;
    shaderDenormFlushToZeroFloat16: boolean;
    shaderDenormFlushToZeroFloat32: boolean;
    shaderDenormFlushToZeroFloat64: boolean;
    shaderRoundingModeRTEFloat16: boolean;
    shaderRoundingModeRTEFloat32: boolean;
    shaderRoundingModeRTEFloat64: boolean;
    shaderRoundingModeRTZFloat16: boolean;
    shaderRoundingModeRTZFloat32: boolean;
    shaderRoundingModeRTZFloat64: boolean
}
export interface VkPhysicalDeviceFloatControlsPropertiesKHRDeserialized {

}
export interface VkPhysicalDeviceHostQueryResetFeaturesDeserialized {
    pNext?: ptr64_t;
    hostQueryReset: boolean
}
export interface VkPhysicalDeviceHostQueryResetFeaturesEXTDeserialized {

}
export interface VkDeviceQueueGlobalPriorityCreateInfoKHRDeserialized {
    pNext?: ptr64_t;
    globalPriority: number
}
export interface VkDeviceQueueGlobalPriorityCreateInfoEXTDeserialized {

}
export interface VkPhysicalDeviceGlobalPriorityQueryFeaturesKHRDeserialized {
    pNext?: ptr64_t;
    globalPriorityQuery: boolean
}
export interface VkPhysicalDeviceGlobalPriorityQueryFeaturesEXTDeserialized {

}
export interface VkQueueFamilyGlobalPriorityPropertiesKHRDeserialized {
    pNext?: ptr64_t;
    priorityCount: number;
    priorities: number
}
export interface VkQueueFamilyGlobalPriorityPropertiesEXTDeserialized {

}
export interface VkImportMemoryHostPointerInfoEXTDeserialized {
    pNext?: ptr64_t;
    handleType: number;
    pHostPointer: ptr64_t
}
export interface VkMemoryHostPointerPropertiesEXTDeserialized {
    pNext?: ptr64_t;
    memoryTypeBits: number
}
export interface VkPhysicalDeviceExternalMemoryHostPropertiesEXTDeserialized {
    pNext?: ptr64_t;
    minImportedHostPointerAlignment: number
}
export interface VkPhysicalDeviceDescriptorIndexingFeaturesDeserialized {
    pNext?: ptr64_t;
    shaderInputAttachmentArrayDynamicIndexing: boolean;
    shaderUniformTexelBufferArrayDynamicIndexing: boolean;
    shaderStorageTexelBufferArrayDynamicIndexing: boolean;
    shaderUniformBufferArrayNonUniformIndexing: boolean;
    shaderSampledImageArrayNonUniformIndexing: boolean;
    shaderStorageBufferArrayNonUniformIndexing: boolean;
    shaderStorageImageArrayNonUniformIndexing: boolean;
    shaderInputAttachmentArrayNonUniformIndexing: boolean;
    shaderUniformTexelBufferArrayNonUniformIndexing: boolean;
    shaderStorageTexelBufferArrayNonUniformIndexing: boolean;
    descriptorBindingUniformBufferUpdateAfterBind: boolean;
    descriptorBindingSampledImageUpdateAfterBind: boolean;
    descriptorBindingStorageImageUpdateAfterBind: boolean;
    descriptorBindingStorageBufferUpdateAfterBind: boolean;
    descriptorBindingUniformTexelBufferUpdateAfterBind: boolean;
    descriptorBindingStorageTexelBufferUpdateAfterBind: boolean;
    descriptorBindingUpdateUnusedWhilePending: boolean;
    descriptorBindingPartiallyBound: boolean;
    descriptorBindingVariableDescriptorCount: boolean;
    runtimeDescriptorArray: boolean
}
export interface VkPhysicalDeviceDescriptorIndexingPropertiesDeserialized {
    pNext?: ptr64_t;
    maxUpdateAfterBindDescriptorsInAllPools: number;
    shaderUniformBufferArrayNonUniformIndexingNative: boolean;
    shaderSampledImageArrayNonUniformIndexingNative: boolean;
    shaderStorageBufferArrayNonUniformIndexingNative: boolean;
    shaderStorageImageArrayNonUniformIndexingNative: boolean;
    shaderInputAttachmentArrayNonUniformIndexingNative: boolean;
    robustBufferAccessUpdateAfterBind: boolean;
    quadDivergentImplicitLod: boolean;
    maxPerStageDescriptorUpdateAfterBindSamplers: number;
    maxPerStageDescriptorUpdateAfterBindUniformBuffers: number;
    maxPerStageDescriptorUpdateAfterBindStorageBuffers: number;
    maxPerStageDescriptorUpdateAfterBindSampledImages: number;
    maxPerStageDescriptorUpdateAfterBindStorageImages: number;
    maxPerStageDescriptorUpdateAfterBindInputAttachments: number;
    maxPerStageUpdateAfterBindResources: number;
    maxDescriptorSetUpdateAfterBindSamplers: number;
    maxDescriptorSetUpdateAfterBindUniformBuffers: number;
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: number;
    maxDescriptorSetUpdateAfterBindStorageBuffers: number;
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: number;
    maxDescriptorSetUpdateAfterBindSampledImages: number;
    maxDescriptorSetUpdateAfterBindStorageImages: number;
    maxDescriptorSetUpdateAfterBindInputAttachments: number
}
export interface VkDescriptorSetLayoutBindingFlagsCreateInfoDeserialized {
    pNext?: ptr64_t;
    bindingCount?: number;
    pBindingFlags: number
}
export interface VkDescriptorSetVariableDescriptorCountAllocateInfoDeserialized {
    pNext?: ptr64_t;
    descriptorSetCount?: number;
    pDescriptorCounts: number
}
export interface VkDescriptorSetVariableDescriptorCountLayoutSupportDeserialized {
    pNext?: ptr64_t;
    maxVariableDescriptorCount: number
}
export interface VkAttachmentDescription2Deserialized {
    pNext?: ptr64_t;
    flags?: number;
    format: number;
    samples: number;
    loadOp: number;
    storeOp: number;
    stencilLoadOp: number;
    stencilStoreOp: number;
    initialLayout: number;
    finalLayout: number
}
export interface VkAttachmentDescription2KHRDeserialized {

}
export interface VkAttachmentReference2Deserialized {
    pNext?: ptr64_t;
    attachment: number;
    layout: number;
    aspectMask: number
}
export interface VkAttachmentReference2KHRDeserialized {

}
export interface VkSubpassDescription2Deserialized {
    pNext?: ptr64_t;
    flags?: number;
    pipelineBindPoint: number;
    viewMask: number;
    inputAttachmentCount?: number;
    pInputAttachments: VkAttachmentReference2Deserialized;
    colorAttachmentCount?: number;
    pColorAttachments: VkAttachmentReference2Deserialized;
    pResolveAttachments?: VkAttachmentReference2Deserialized;
    pDepthStencilAttachment?: VkAttachmentReference2Deserialized;
    preserveAttachmentCount?: number;
    pPreserveAttachments: number
}
export interface VkSubpassDescription2KHRDeserialized {

}
export interface VkSubpassDependency2Deserialized {
    pNext?: ptr64_t;
    srcSubpass: number;
    dstSubpass: number;
    srcStageMask?: number;
    dstStageMask?: number;
    srcAccessMask?: number;
    dstAccessMask?: number;
    dependencyFlags?: number;
    viewOffset: number
}
export interface VkSubpassDependency2KHRDeserialized {

}
export interface VkRenderPassCreateInfo2Deserialized {
    pNext?: ptr64_t;
    flags?: number;
    attachmentCount?: number;
    pAttachments: VkAttachmentDescription2Deserialized;
    subpassCount: number;
    pSubpasses: VkSubpassDescription2Deserialized;
    dependencyCount?: number;
    pDependencies: VkSubpassDependency2Deserialized;
    correlatedViewMaskCount?: number;
    pCorrelatedViewMasks: number
}
export interface VkRenderPassCreateInfo2KHRDeserialized {

}
export interface VkSubpassBeginInfoDeserialized {
    pNext?: ptr64_t;
    contents: number
}
export interface VkSubpassBeginInfoKHRDeserialized {

}
export interface VkSubpassEndInfoDeserialized {
    pNext?: ptr64_t
}
export interface VkSubpassEndInfoKHRDeserialized {

}
export interface VkPhysicalDeviceTimelineSemaphoreFeaturesDeserialized {
    pNext?: ptr64_t;
    timelineSemaphore: boolean
}
export interface VkPhysicalDeviceTimelineSemaphoreFeaturesKHRDeserialized {

}
export interface VkPhysicalDeviceTimelineSemaphorePropertiesDeserialized {
    pNext?: ptr64_t;
    maxTimelineSemaphoreValueDifference: number
}
export interface VkPhysicalDeviceTimelineSemaphorePropertiesKHRDeserialized {

}
export interface VkSemaphoreTypeCreateInfoDeserialized {
    pNext?: ptr64_t;
    semaphoreType: number;
    initialValue: number
}
export interface VkSemaphoreTypeCreateInfoKHRDeserialized {

}
export interface VkTimelineSemaphoreSubmitInfoDeserialized {
    pNext?: ptr64_t;
    waitSemaphoreValueCount?: number;
    pWaitSemaphoreValues?: number;
    signalSemaphoreValueCount?: number;
    pSignalSemaphoreValues?: number
}
export interface VkTimelineSemaphoreSubmitInfoKHRDeserialized {

}
export interface VkSemaphoreWaitInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    semaphoreCount: number;
    pSemaphores: ptr64_t;
    pValues: number
}
export interface VkSemaphoreWaitInfoKHRDeserialized {

}
export interface VkSemaphoreSignalInfoDeserialized {
    pNext?: ptr64_t;
    semaphore: ptr64_t;
    value: number
}
export interface VkSemaphoreSignalInfoKHRDeserialized {

}
export interface VkVertexInputBindingDivisorDescriptionEXTDeserialized {
    binding: number;
    divisor: number
}
export interface VkPipelineVertexInputDivisorStateCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    vertexBindingDivisorCount: number;
    pVertexBindingDivisors: VkVertexInputBindingDivisorDescriptionEXTDeserialized
}
export interface VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTDeserialized {
    pNext?: ptr64_t;
    maxVertexAttribDivisor: number
}
export interface VkPhysicalDevicePCIBusInfoPropertiesEXTDeserialized {
    pNext?: ptr64_t;
    pciDomain: number;
    pciBus: number;
    pciDevice: number;
    pciFunction: number
}
export interface VkPhysicalDevice8BitStorageFeaturesDeserialized {
    pNext?: ptr64_t;
    storageBuffer8BitAccess: boolean;
    uniformAndStorageBuffer8BitAccess: boolean;
    storagePushConstant8: boolean
}
export interface VkPhysicalDevice8BitStorageFeaturesKHRDeserialized {

}
export interface VkPhysicalDeviceVulkanMemoryModelFeaturesDeserialized {
    pNext?: ptr64_t;
    vulkanMemoryModel: boolean;
    vulkanMemoryModelDeviceScope: boolean;
    vulkanMemoryModelAvailabilityVisibilityChains: boolean
}
export interface VkPhysicalDeviceVulkanMemoryModelFeaturesKHRDeserialized {

}
export interface VkPhysicalDeviceShaderAtomicInt64FeaturesDeserialized {
    pNext?: ptr64_t;
    shaderBufferInt64Atomics: boolean;
    shaderSharedInt64Atomics: boolean
}
export interface VkPhysicalDeviceShaderAtomicInt64FeaturesKHRDeserialized {

}
export interface VkPhysicalDeviceShaderAtomicFloatFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    shaderBufferFloat32Atomics: boolean;
    shaderBufferFloat32AtomicAdd: boolean;
    shaderBufferFloat64Atomics: boolean;
    shaderBufferFloat64AtomicAdd: boolean;
    shaderSharedFloat32Atomics: boolean;
    shaderSharedFloat32AtomicAdd: boolean;
    shaderSharedFloat64Atomics: boolean;
    shaderSharedFloat64AtomicAdd: boolean;
    shaderImageFloat32Atomics: boolean;
    shaderImageFloat32AtomicAdd: boolean;
    sparseImageFloat32Atomics: boolean;
    sparseImageFloat32AtomicAdd: boolean
}
export interface VkPhysicalDeviceShaderAtomicFloat2FeaturesEXTDeserialized {
    pNext?: ptr64_t;
    shaderBufferFloat16Atomics: boolean;
    shaderBufferFloat16AtomicAdd: boolean;
    shaderBufferFloat16AtomicMinMax: boolean;
    shaderBufferFloat32AtomicMinMax: boolean;
    shaderBufferFloat64AtomicMinMax: boolean;
    shaderSharedFloat16Atomics: boolean;
    shaderSharedFloat16AtomicAdd: boolean;
    shaderSharedFloat16AtomicMinMax: boolean;
    shaderSharedFloat32AtomicMinMax: boolean;
    shaderSharedFloat64AtomicMinMax: boolean;
    shaderImageFloat32AtomicMinMax: boolean;
    sparseImageFloat32AtomicMinMax: boolean
}
export interface VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    vertexAttributeInstanceRateDivisor: boolean;
    vertexAttributeInstanceRateZeroDivisor: boolean
}
export interface VkPhysicalDeviceDepthStencilResolvePropertiesDeserialized {
    pNext?: ptr64_t;
    supportedDepthResolveModes: number;
    supportedStencilResolveModes: number;
    independentResolveNone: boolean;
    independentResolve: boolean
}
export interface VkPhysicalDeviceDepthStencilResolvePropertiesKHRDeserialized {

}
export interface VkSubpassDescriptionDepthStencilResolveDeserialized {
    pNext?: ptr64_t;
    depthResolveMode: number;
    stencilResolveMode: number;
    pDepthStencilResolveAttachment?: VkAttachmentReference2Deserialized
}
export interface VkSubpassDescriptionDepthStencilResolveKHRDeserialized {

}
export interface VkPhysicalDeviceTransformFeedbackFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    transformFeedback: boolean;
    geometryStreams: boolean
}
export interface VkPhysicalDeviceTransformFeedbackPropertiesEXTDeserialized {
    pNext?: ptr64_t;
    maxTransformFeedbackStreams: number;
    maxTransformFeedbackBuffers: number;
    maxTransformFeedbackBufferSize: number;
    maxTransformFeedbackStreamDataSize: number;
    maxTransformFeedbackBufferDataSize: number;
    maxTransformFeedbackBufferDataStride: number;
    transformFeedbackQueries: boolean;
    transformFeedbackStreamsLinesTriangles: boolean;
    transformFeedbackRasterizationStreamSelect: boolean;
    transformFeedbackDraw: boolean
}
export interface VkPipelineRasterizationStateStreamCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    rasterizationStream: number
}
export interface VkPhysicalDeviceMeshShaderFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    taskShader: boolean;
    meshShader: boolean;
    multiviewMeshShader: boolean;
    primitiveFragmentShadingRateMeshShader: boolean;
    meshShaderQueries: boolean
}
export interface VkPhysicalDeviceMeshShaderPropertiesEXTDeserialized {
    pNext?: ptr64_t;
    maxTaskWorkGroupTotalCount: number;
    maxTaskWorkGroupCount: number;
    maxTaskWorkGroupInvocations: number;
    maxTaskWorkGroupSize: number;
    maxTaskPayloadSize: number;
    maxTaskSharedMemorySize: number;
    maxTaskPayloadAndSharedMemorySize: number;
    maxMeshWorkGroupTotalCount: number;
    maxMeshWorkGroupCount: number;
    maxMeshWorkGroupInvocations: number;
    maxMeshWorkGroupSize: number;
    maxMeshSharedMemorySize: number;
    maxMeshPayloadAndSharedMemorySize: number;
    maxMeshOutputMemorySize: number;
    maxMeshPayloadAndOutputMemorySize: number;
    maxMeshOutputComponents: number;
    maxMeshOutputVertices: number;
    maxMeshOutputPrimitives: number;
    maxMeshOutputLayers: number;
    maxMeshMultiviewViewCount: number;
    meshOutputPerVertexGranularity: number;
    meshOutputPerPrimitiveGranularity: number;
    maxPreferredTaskWorkGroupInvocations: number;
    maxPreferredMeshWorkGroupInvocations: number;
    prefersLocalInvocationVertexOutput: boolean;
    prefersLocalInvocationPrimitiveOutput: boolean;
    prefersCompactVertexOutput: boolean;
    prefersCompactPrimitiveOutput: boolean
}
export interface VkDrawMeshTasksIndirectCommandEXTDeserialized {
    groupCountX: number;
    groupCountY: number;
    groupCountZ: number
}
export interface VkRayTracingShaderGroupCreateInfoKHRDeserialized {
    pNext?: ptr64_t;
    type: number;
    generalShader: number;
    closestHitShader: number;
    anyHitShader: number;
    intersectionShader: number;
    pShaderGroupCaptureReplayHandle?: ptr64_t
}
export interface VkRayTracingPipelineCreateInfoKHRDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    stageCount?: number;
    pStages: VkPipelineShaderStageCreateInfoDeserialized;
    groupCount?: number;
    pGroups: VkRayTracingShaderGroupCreateInfoKHRDeserialized;
    maxPipelineRayRecursionDepth: number;
    pLibraryInfo?: VkPipelineLibraryCreateInfoKHRDeserialized;
    pLibraryInterface?: VkRayTracingPipelineInterfaceCreateInfoKHRDeserialized;
    pDynamicState?: VkPipelineDynamicStateCreateInfoDeserialized;
    layout: ptr64_t;
    basePipelineHandle?: ptr64_t;
    basePipelineIndex: number
}
export interface VkPhysicalDeviceRayTracingPipelineFeaturesKHRDeserialized {
    pNext?: ptr64_t;
    rayTracingPipeline: boolean;
    rayTracingPipelineShaderGroupHandleCaptureReplay: boolean;
    rayTracingPipelineShaderGroupHandleCaptureReplayMixed: boolean;
    rayTracingPipelineTraceRaysIndirect: boolean;
    rayTraversalPrimitiveCulling: boolean
}
export interface VkPhysicalDeviceRayQueryFeaturesKHRDeserialized {
    pNext?: ptr64_t;
    rayQuery: boolean
}
export interface VkPhysicalDeviceRayTracingPipelinePropertiesKHRDeserialized {
    pNext?: ptr64_t;
    shaderGroupHandleSize: number;
    maxRayRecursionDepth: number;
    maxShaderGroupStride: number;
    shaderGroupBaseAlignment: number;
    shaderGroupHandleCaptureReplaySize: number;
    maxRayDispatchInvocationCount: number;
    shaderGroupHandleAlignment: number;
    maxRayHitAttributeSize: number
}
export interface VkStridedDeviceAddressRegionKHRDeserialized {
    deviceAddress?: ptr64_t;
    stride: number;
    size: number
}
export interface VkTraceRaysIndirectCommandKHRDeserialized {
    width: number;
    height: number;
    depth: number
}
export interface VkTraceRaysIndirectCommand2KHRDeserialized {
    raygenShaderRecordAddress: ptr64_t;
    raygenShaderRecordSize: number;
    missShaderBindingTableAddress: ptr64_t;
    missShaderBindingTableSize: number;
    missShaderBindingTableStride: number;
    hitShaderBindingTableAddress: ptr64_t;
    hitShaderBindingTableSize: number;
    hitShaderBindingTableStride: number;
    callableShaderBindingTableAddress: ptr64_t;
    callableShaderBindingTableSize: number;
    callableShaderBindingTableStride: number;
    width: number;
    height: number;
    depth: number
}
export interface VkPhysicalDeviceRayTracingMaintenance1FeaturesKHRDeserialized {
    pNext?: ptr64_t;
    rayTracingMaintenance1: boolean;
    rayTracingPipelineTraceRaysIndirect2: boolean
}
export interface VkDrmFormatModifierPropertiesListEXTDeserialized {
    pNext?: ptr64_t;
    drmFormatModifierCount?: number;
    pDrmFormatModifierProperties?: VkDrmFormatModifierPropertiesEXTDeserialized
}
export interface VkDrmFormatModifierPropertiesEXTDeserialized {
    drmFormatModifier: number;
    drmFormatModifierPlaneCount: number;
    drmFormatModifierTilingFeatures: number
}
export interface VkPhysicalDeviceImageDrmFormatModifierInfoEXTDeserialized {
    pNext?: ptr64_t;
    drmFormatModifier: number;
    sharingMode: number;
    queueFamilyIndexCount?: number;
    pQueueFamilyIndices: number
}
export interface VkImageDrmFormatModifierListCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    drmFormatModifierCount: number;
    pDrmFormatModifiers: number
}
export interface VkImageDrmFormatModifierExplicitCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    drmFormatModifier: number;
    drmFormatModifierPlaneCount: number;
    pPlaneLayouts: VkSubresourceLayoutDeserialized
}
export interface VkImageDrmFormatModifierPropertiesEXTDeserialized {
    pNext?: ptr64_t;
    drmFormatModifier: number
}
export interface VkImageStencilUsageCreateInfoDeserialized {
    pNext?: ptr64_t;
    stencilUsage: number
}
export interface VkImageStencilUsageCreateInfoEXTDeserialized {

}
export interface VkPhysicalDeviceFragmentDensityMapFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    fragmentDensityMap: boolean;
    fragmentDensityMapDynamic: boolean;
    fragmentDensityMapNonSubsampledImages: boolean
}
export interface VkPhysicalDeviceFragmentDensityMap2FeaturesEXTDeserialized {
    pNext?: ptr64_t;
    fragmentDensityMapDeferred: boolean
}
export interface VkPhysicalDeviceFragmentDensityMapPropertiesEXTDeserialized {
    pNext?: ptr64_t;
    minFragmentDensityTexelSize: VkExtent2DDeserialized[];
    maxFragmentDensityTexelSize: VkExtent2DDeserialized[];
    fragmentDensityInvocations: boolean
}
export interface VkPhysicalDeviceFragmentDensityMap2PropertiesEXTDeserialized {
    pNext?: ptr64_t;
    subsampledLoads: boolean;
    subsampledCoarseReconstructionEarlyAccess: boolean;
    maxSubsampledArrayLayers: number;
    maxDescriptorSetSubsampledSamplers: number
}
export interface VkRenderPassFragmentDensityMapCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    fragmentDensityMapAttachment: VkAttachmentReferenceDeserialized[]
}
export interface VkPhysicalDeviceScalarBlockLayoutFeaturesDeserialized {
    pNext?: ptr64_t;
    scalarBlockLayout: boolean
}
export interface VkPhysicalDeviceScalarBlockLayoutFeaturesEXTDeserialized {

}
export interface VkSurfaceProtectedCapabilitiesKHRDeserialized {
    pNext?: ptr64_t;
    supportsProtected: boolean
}
export interface VkPhysicalDeviceUniformBufferStandardLayoutFeaturesDeserialized {
    pNext?: ptr64_t;
    uniformBufferStandardLayout: boolean
}
export interface VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHRDeserialized {

}
export interface VkPhysicalDeviceMemoryBudgetPropertiesEXTDeserialized {
    pNext?: ptr64_t;
    heapBudget: number;
    heapUsage: number
}
export interface VkPhysicalDeviceMemoryPriorityFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    memoryPriority: boolean
}
export interface VkMemoryPriorityAllocateInfoEXTDeserialized {
    pNext?: ptr64_t;
    priority: number
}
export interface VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    pageableDeviceLocalMemory: boolean
}
export interface VkPhysicalDeviceBufferDeviceAddressFeaturesDeserialized {
    pNext?: ptr64_t;
    bufferDeviceAddress: boolean;
    bufferDeviceAddressCaptureReplay: boolean;
    bufferDeviceAddressMultiDevice: boolean
}
export interface VkPhysicalDeviceBufferDeviceAddressFeaturesKHRDeserialized {

}
export interface VkBufferDeviceAddressInfoDeserialized {
    pNext?: ptr64_t;
    buffer: ptr64_t
}
export interface VkBufferDeviceAddressInfoKHRDeserialized {

}
export interface VkBufferOpaqueCaptureAddressCreateInfoDeserialized {
    pNext?: ptr64_t;
    opaqueCaptureAddress: number
}
export interface VkBufferOpaqueCaptureAddressCreateInfoKHRDeserialized {

}
export interface VkPhysicalDeviceImageViewImageFormatInfoEXTDeserialized {
    pNext?: ptr64_t;
    imageViewType: number
}
export interface VkFilterCubicImageViewImageFormatPropertiesEXTDeserialized {
    pNext?: ptr64_t;
    filterCubic: boolean;
    filterCubicMinmax: boolean
}
export interface VkPhysicalDeviceImagelessFramebufferFeaturesDeserialized {
    pNext?: ptr64_t;
    imagelessFramebuffer: boolean
}
export interface VkPhysicalDeviceImagelessFramebufferFeaturesKHRDeserialized {

}
export interface VkFramebufferAttachmentsCreateInfoDeserialized {
    pNext?: ptr64_t;
    attachmentImageInfoCount?: number;
    pAttachmentImageInfos: VkFramebufferAttachmentImageInfoDeserialized
}
export interface VkFramebufferAttachmentsCreateInfoKHRDeserialized {

}
export interface VkFramebufferAttachmentImageInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    usage: number;
    width: number;
    height: number;
    layerCount: number;
    viewFormatCount?: number;
    pViewFormats: number
}
export interface VkFramebufferAttachmentImageInfoKHRDeserialized {

}
export interface VkRenderPassAttachmentBeginInfoDeserialized {
    pNext?: ptr64_t;
    attachmentCount?: number;
    pAttachments: ptr64_t
}
export interface VkRenderPassAttachmentBeginInfoKHRDeserialized {

}
export interface VkPhysicalDeviceTextureCompressionASTCHDRFeaturesDeserialized {
    pNext?: ptr64_t;
    textureCompressionASTC_HDR: boolean
}
export interface VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTDeserialized {

}
export interface VkPhysicalDeviceYcbcrImageArraysFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    ycbcrImageArrays: boolean
}
export interface VkPipelineCreationFeedbackDeserialized {
    flags: number;
    duration: number
}
export interface VkPipelineCreationFeedbackEXTDeserialized {

}
export interface VkPipelineCreationFeedbackCreateInfoDeserialized {
    pNext?: ptr64_t;
    pPipelineCreationFeedback: VkPipelineCreationFeedbackDeserialized;
    pipelineStageCreationFeedbackCount?: number;
    pPipelineStageCreationFeedbacks: VkPipelineCreationFeedbackDeserialized
}
export interface VkPipelineCreationFeedbackCreateInfoEXTDeserialized {

}
export interface VkHeadlessSurfaceCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    flags?: number
}
export interface VkPhysicalDeviceShaderClockFeaturesKHRDeserialized {
    pNext?: ptr64_t;
    shaderSubgroupClock: boolean;
    shaderDeviceClock: boolean
}
export interface VkPhysicalDeviceIndexTypeUint8FeaturesEXTDeserialized {
    pNext?: ptr64_t;
    indexTypeUint8: boolean
}
export interface VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    fragmentShaderSampleInterlock: boolean;
    fragmentShaderPixelInterlock: boolean;
    fragmentShaderShadingRateInterlock: boolean
}
export interface VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesDeserialized {
    pNext?: ptr64_t;
    separateDepthStencilLayouts: boolean
}
export interface VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHRDeserialized {

}
export interface VkAttachmentReferenceStencilLayoutDeserialized {
    pNext?: ptr64_t;
    stencilLayout: number
}
export interface VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    primitiveTopologyListRestart: boolean;
    primitiveTopologyPatchListRestart: boolean
}
export interface VkAttachmentReferenceStencilLayoutKHRDeserialized {

}
export interface VkAttachmentDescriptionStencilLayoutDeserialized {
    pNext?: ptr64_t;
    stencilInitialLayout: number;
    stencilFinalLayout: number
}
export interface VkAttachmentDescriptionStencilLayoutKHRDeserialized {

}
export interface VkPipelineInfoEXTDeserialized {

}
export interface VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesDeserialized {
    pNext?: ptr64_t;
    shaderDemoteToHelperInvocation: boolean
}
export interface VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTDeserialized {

}
export interface VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    texelBufferAlignment: boolean
}
export interface VkPhysicalDeviceTexelBufferAlignmentPropertiesDeserialized {
    pNext?: ptr64_t;
    storageTexelBufferOffsetAlignmentBytes: number;
    storageTexelBufferOffsetSingleTexelAlignment: boolean;
    uniformTexelBufferOffsetAlignmentBytes: number;
    uniformTexelBufferOffsetSingleTexelAlignment: boolean
}
export interface VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTDeserialized {

}
export interface VkPhysicalDeviceSubgroupSizeControlFeaturesDeserialized {
    pNext?: ptr64_t;
    subgroupSizeControl: boolean;
    computeFullSubgroups: boolean
}
export interface VkPhysicalDeviceSubgroupSizeControlFeaturesEXTDeserialized {

}
export interface VkPhysicalDeviceSubgroupSizeControlPropertiesDeserialized {
    pNext?: ptr64_t;
    minSubgroupSize: number;
    maxSubgroupSize: number;
    maxComputeWorkgroupSubgroups: number;
    requiredSubgroupSizeStages: number
}
export interface VkPhysicalDeviceSubgroupSizeControlPropertiesEXTDeserialized {

}
export interface VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTDeserialized {

}
export interface VkMemoryOpaqueCaptureAddressAllocateInfoDeserialized {
    pNext?: ptr64_t;
    opaqueCaptureAddress: number
}
export interface VkMemoryOpaqueCaptureAddressAllocateInfoKHRDeserialized {

}
export interface VkDeviceMemoryOpaqueCaptureAddressInfoDeserialized {
    pNext?: ptr64_t;
    memory: ptr64_t
}
export interface VkDeviceMemoryOpaqueCaptureAddressInfoKHRDeserialized {

}
export interface VkPhysicalDeviceLineRasterizationFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    rectangularLines: boolean;
    bresenhamLines: boolean;
    smoothLines: boolean;
    stippledRectangularLines: boolean;
    stippledBresenhamLines: boolean;
    stippledSmoothLines: boolean
}
export interface VkPhysicalDeviceLineRasterizationPropertiesEXTDeserialized {
    pNext?: ptr64_t;
    lineSubPixelPrecisionBits: number
}
export interface VkPipelineRasterizationLineStateCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    lineRasterizationMode: number;
    stippledLineEnable: boolean;
    lineStippleFactor: number;
    lineStipplePattern: number
}
export interface VkPhysicalDevicePipelineCreationCacheControlFeaturesDeserialized {
    pNext?: ptr64_t;
    pipelineCreationCacheControl: boolean
}
export interface VkPhysicalDevicePipelineCreationCacheControlFeaturesEXTDeserialized {

}
export interface VkPhysicalDeviceVulkan11FeaturesDeserialized {
    pNext?: ptr64_t;
    storageBuffer16BitAccess: boolean;
    uniformAndStorageBuffer16BitAccess: boolean;
    storagePushConstant16: boolean;
    storageInputOutput16: boolean;
    multiview: boolean;
    multiviewGeometryShader: boolean;
    multiviewTessellationShader: boolean;
    variablePointersStorageBuffer: boolean;
    variablePointers: boolean;
    protectedMemory: boolean;
    samplerYcbcrConversion: boolean;
    shaderDrawParameters: boolean
}
export interface VkPhysicalDeviceVulkan11PropertiesDeserialized {
    pNext?: ptr64_t;
    deviceUUID: number;
    driverUUID: number;
    deviceLUID: number;
    deviceNodeMask: number;
    deviceLUIDValid: boolean;
    subgroupSize: number;
    subgroupSupportedStages: number;
    subgroupSupportedOperations: number;
    subgroupQuadOperationsInAllStages: boolean;
    pointClippingBehavior: number;
    maxMultiviewViewCount: number;
    maxMultiviewInstanceIndex: number;
    protectedNoFault: boolean;
    maxPerSetDescriptors: number;
    maxMemoryAllocationSize: number
}
export interface VkPhysicalDeviceVulkan12FeaturesDeserialized {
    pNext?: ptr64_t;
    samplerMirrorClampToEdge: boolean;
    drawIndirectCount: boolean;
    storageBuffer8BitAccess: boolean;
    uniformAndStorageBuffer8BitAccess: boolean;
    storagePushConstant8: boolean;
    shaderBufferInt64Atomics: boolean;
    shaderSharedInt64Atomics: boolean;
    shaderFloat16: boolean;
    shaderInt8: boolean;
    descriptorIndexing: boolean;
    shaderInputAttachmentArrayDynamicIndexing: boolean;
    shaderUniformTexelBufferArrayDynamicIndexing: boolean;
    shaderStorageTexelBufferArrayDynamicIndexing: boolean;
    shaderUniformBufferArrayNonUniformIndexing: boolean;
    shaderSampledImageArrayNonUniformIndexing: boolean;
    shaderStorageBufferArrayNonUniformIndexing: boolean;
    shaderStorageImageArrayNonUniformIndexing: boolean;
    shaderInputAttachmentArrayNonUniformIndexing: boolean;
    shaderUniformTexelBufferArrayNonUniformIndexing: boolean;
    shaderStorageTexelBufferArrayNonUniformIndexing: boolean;
    descriptorBindingUniformBufferUpdateAfterBind: boolean;
    descriptorBindingSampledImageUpdateAfterBind: boolean;
    descriptorBindingStorageImageUpdateAfterBind: boolean;
    descriptorBindingStorageBufferUpdateAfterBind: boolean;
    descriptorBindingUniformTexelBufferUpdateAfterBind: boolean;
    descriptorBindingStorageTexelBufferUpdateAfterBind: boolean;
    descriptorBindingUpdateUnusedWhilePending: boolean;
    descriptorBindingPartiallyBound: boolean;
    descriptorBindingVariableDescriptorCount: boolean;
    runtimeDescriptorArray: boolean;
    samplerFilterMinmax: boolean;
    scalarBlockLayout: boolean;
    imagelessFramebuffer: boolean;
    uniformBufferStandardLayout: boolean;
    shaderSubgroupExtendedTypes: boolean;
    separateDepthStencilLayouts: boolean;
    hostQueryReset: boolean;
    timelineSemaphore: boolean;
    bufferDeviceAddress: boolean;
    bufferDeviceAddressCaptureReplay: boolean;
    bufferDeviceAddressMultiDevice: boolean;
    vulkanMemoryModel: boolean;
    vulkanMemoryModelDeviceScope: boolean;
    vulkanMemoryModelAvailabilityVisibilityChains: boolean;
    shaderOutputViewportIndex: boolean;
    shaderOutputLayer: boolean;
    subgroupBroadcastDynamicId: boolean
}
export interface VkPhysicalDeviceVulkan12PropertiesDeserialized {
    pNext?: ptr64_t;
    driverID: number;
    driverName: string;
    driverInfo: string;
    conformanceVersion: VkConformanceVersionDeserialized[];
    denormBehaviorIndependence: number;
    roundingModeIndependence: number;
    shaderSignedZeroInfNanPreserveFloat16: boolean;
    shaderSignedZeroInfNanPreserveFloat32: boolean;
    shaderSignedZeroInfNanPreserveFloat64: boolean;
    shaderDenormPreserveFloat16: boolean;
    shaderDenormPreserveFloat32: boolean;
    shaderDenormPreserveFloat64: boolean;
    shaderDenormFlushToZeroFloat16: boolean;
    shaderDenormFlushToZeroFloat32: boolean;
    shaderDenormFlushToZeroFloat64: boolean;
    shaderRoundingModeRTEFloat16: boolean;
    shaderRoundingModeRTEFloat32: boolean;
    shaderRoundingModeRTEFloat64: boolean;
    shaderRoundingModeRTZFloat16: boolean;
    shaderRoundingModeRTZFloat32: boolean;
    shaderRoundingModeRTZFloat64: boolean;
    maxUpdateAfterBindDescriptorsInAllPools: number;
    shaderUniformBufferArrayNonUniformIndexingNative: boolean;
    shaderSampledImageArrayNonUniformIndexingNative: boolean;
    shaderStorageBufferArrayNonUniformIndexingNative: boolean;
    shaderStorageImageArrayNonUniformIndexingNative: boolean;
    shaderInputAttachmentArrayNonUniformIndexingNative: boolean;
    robustBufferAccessUpdateAfterBind: boolean;
    quadDivergentImplicitLod: boolean;
    maxPerStageDescriptorUpdateAfterBindSamplers: number;
    maxPerStageDescriptorUpdateAfterBindUniformBuffers: number;
    maxPerStageDescriptorUpdateAfterBindStorageBuffers: number;
    maxPerStageDescriptorUpdateAfterBindSampledImages: number;
    maxPerStageDescriptorUpdateAfterBindStorageImages: number;
    maxPerStageDescriptorUpdateAfterBindInputAttachments: number;
    maxPerStageUpdateAfterBindResources: number;
    maxDescriptorSetUpdateAfterBindSamplers: number;
    maxDescriptorSetUpdateAfterBindUniformBuffers: number;
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: number;
    maxDescriptorSetUpdateAfterBindStorageBuffers: number;
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: number;
    maxDescriptorSetUpdateAfterBindSampledImages: number;
    maxDescriptorSetUpdateAfterBindStorageImages: number;
    maxDescriptorSetUpdateAfterBindInputAttachments: number;
    supportedDepthResolveModes: number;
    supportedStencilResolveModes: number;
    independentResolveNone: boolean;
    independentResolve: boolean;
    filterMinmaxSingleComponentFormats: boolean;
    filterMinmaxImageComponentMapping: boolean;
    maxTimelineSemaphoreValueDifference: number;
    framebufferIntegerColorSampleCounts?: number
}
export interface VkPhysicalDeviceVulkan13FeaturesDeserialized {
    pNext?: ptr64_t;
    robustImageAccess: boolean;
    inlineUniformBlock: boolean;
    descriptorBindingInlineUniformBlockUpdateAfterBind: boolean;
    pipelineCreationCacheControl: boolean;
    privateData: boolean;
    shaderDemoteToHelperInvocation: boolean;
    shaderTerminateInvocation: boolean;
    subgroupSizeControl: boolean;
    computeFullSubgroups: boolean;
    synchronization2: boolean;
    textureCompressionASTC_HDR: boolean;
    shaderZeroInitializeWorkgroupMemory: boolean;
    dynamicRendering: boolean;
    shaderIntegerDotProduct: boolean;
    maintenance4: boolean
}
export interface VkPhysicalDeviceVulkan13PropertiesDeserialized {
    pNext?: ptr64_t;
    minSubgroupSize: number;
    maxSubgroupSize: number;
    maxComputeWorkgroupSubgroups: number;
    requiredSubgroupSizeStages: number;
    maxInlineUniformBlockSize: number;
    maxPerStageDescriptorInlineUniformBlocks: number;
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: number;
    maxDescriptorSetInlineUniformBlocks: number;
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks: number;
    maxInlineUniformTotalSize: number;
    integerDotProduct8BitUnsignedAccelerated: boolean;
    integerDotProduct8BitSignedAccelerated: boolean;
    integerDotProduct8BitMixedSignednessAccelerated: boolean;
    integerDotProduct4x8BitPackedUnsignedAccelerated: boolean;
    integerDotProduct4x8BitPackedSignedAccelerated: boolean;
    integerDotProduct4x8BitPackedMixedSignednessAccelerated: boolean;
    integerDotProduct16BitUnsignedAccelerated: boolean;
    integerDotProduct16BitSignedAccelerated: boolean;
    integerDotProduct16BitMixedSignednessAccelerated: boolean;
    integerDotProduct32BitUnsignedAccelerated: boolean;
    integerDotProduct32BitSignedAccelerated: boolean;
    integerDotProduct32BitMixedSignednessAccelerated: boolean;
    integerDotProduct64BitUnsignedAccelerated: boolean;
    integerDotProduct64BitSignedAccelerated: boolean;
    integerDotProduct64BitMixedSignednessAccelerated: boolean;
    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating8BitSignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: boolean;
    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: boolean;
    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating16BitSignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: boolean;
    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating32BitSignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: boolean;
    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating64BitSignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: boolean;
    storageTexelBufferOffsetAlignmentBytes: number;
    storageTexelBufferOffsetSingleTexelAlignment: boolean;
    uniformTexelBufferOffsetAlignmentBytes: number;
    uniformTexelBufferOffsetSingleTexelAlignment: boolean;
    maxBufferSize: number
}
export interface VkPhysicalDeviceToolPropertiesDeserialized {
    pNext?: ptr64_t;
    name: string;
    version: string;
    purposes: number;
    description: string;
    layer: string
}
export interface VkPhysicalDeviceToolPropertiesEXTDeserialized {

}
export interface VkRayTracingPipelineInterfaceCreateInfoKHRDeserialized {
    pNext?: ptr64_t;
    maxPipelineRayPayloadSize: number;
    maxPipelineRayHitAttributeSize: number
}
export interface VkPipelineLibraryCreateInfoKHRDeserialized {
    pNext?: ptr64_t;
    libraryCount?: number;
    pLibraries: ptr64_t
}
export interface VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesDeserialized {
    pNext?: ptr64_t;
    shaderZeroInitializeWorkgroupMemory: boolean
}
export interface VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHRDeserialized {

}
export interface VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRDeserialized {
    pNext?: ptr64_t;
    shaderSubgroupUniformControlFlow: boolean
}
export interface VkPhysicalDeviceRobustness2FeaturesEXTDeserialized {
    pNext?: ptr64_t;
    robustBufferAccess2: boolean;
    robustImageAccess2: boolean;
    nullDescriptor: boolean
}
export interface VkPhysicalDeviceRobustness2PropertiesEXTDeserialized {
    pNext?: ptr64_t;
    robustStorageBufferAccessSizeAlignment: number;
    robustUniformBufferAccessSizeAlignment: number
}
export interface VkPhysicalDeviceImageRobustnessFeaturesDeserialized {
    pNext?: ptr64_t;
    robustImageAccess: boolean
}
export interface VkPhysicalDeviceImageRobustnessFeaturesEXTDeserialized {

}
export interface VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRDeserialized {
    pNext?: ptr64_t;
    workgroupMemoryExplicitLayout: boolean;
    workgroupMemoryExplicitLayoutScalarBlockLayout: boolean;
    workgroupMemoryExplicitLayout8BitAccess: boolean;
    workgroupMemoryExplicitLayout16BitAccess: boolean
}
export interface VkBufferCopy2Deserialized {
    pNext?: ptr64_t;
    srcOffset: number;
    dstOffset: number;
    size: number
}
export interface VkBufferCopy2KHRDeserialized {

}
export interface VkImageCopy2Deserialized {
    pNext?: ptr64_t;
    srcSubresource: VkImageSubresourceLayersDeserialized[];
    srcOffset: VkOffset3DDeserialized[];
    dstSubresource: VkImageSubresourceLayersDeserialized[];
    dstOffset: VkOffset3DDeserialized[];
    extent: VkExtent3DDeserialized[]
}
export interface VkImageCopy2KHRDeserialized {

}
export interface VkImageBlit2Deserialized {
    pNext?: ptr64_t;
    srcSubresource: VkImageSubresourceLayersDeserialized[];
    srcOffsets: VkOffset3DDeserialized[];
    dstSubresource: VkImageSubresourceLayersDeserialized[];
    dstOffsets: VkOffset3DDeserialized[]
}
export interface VkImageBlit2KHRDeserialized {

}
export interface VkBufferImageCopy2Deserialized {
    pNext?: ptr64_t;
    bufferOffset: number;
    bufferRowLength: number;
    bufferImageHeight: number;
    imageSubresource: VkImageSubresourceLayersDeserialized[];
    imageOffset: VkOffset3DDeserialized[];
    imageExtent: VkExtent3DDeserialized[]
}
export interface VkBufferImageCopy2KHRDeserialized {

}
export interface VkImageResolve2Deserialized {
    pNext?: ptr64_t;
    srcSubresource: VkImageSubresourceLayersDeserialized[];
    srcOffset: VkOffset3DDeserialized[];
    dstSubresource: VkImageSubresourceLayersDeserialized[];
    dstOffset: VkOffset3DDeserialized[];
    extent: VkExtent3DDeserialized[]
}
export interface VkImageResolve2KHRDeserialized {

}
export interface VkCopyBufferInfo2Deserialized {
    pNext?: ptr64_t;
    srcBuffer: ptr64_t;
    dstBuffer: ptr64_t;
    regionCount: number;
    pRegions: VkBufferCopy2Deserialized
}
export interface VkCopyBufferInfo2KHRDeserialized {

}
export interface VkCopyImageInfo2Deserialized {
    pNext?: ptr64_t;
    srcImage: ptr64_t;
    srcImageLayout: number;
    dstImage: ptr64_t;
    dstImageLayout: number;
    regionCount: number;
    pRegions: VkImageCopy2Deserialized
}
export interface VkCopyImageInfo2KHRDeserialized {

}
export interface VkBlitImageInfo2Deserialized {
    pNext?: ptr64_t;
    srcImage: ptr64_t;
    srcImageLayout: number;
    dstImage: ptr64_t;
    dstImageLayout: number;
    regionCount: number;
    pRegions: VkImageBlit2Deserialized;
    filter: number
}
export interface VkBlitImageInfo2KHRDeserialized {

}
export interface VkCopyBufferToImageInfo2Deserialized {
    pNext?: ptr64_t;
    srcBuffer: ptr64_t;
    dstImage: ptr64_t;
    dstImageLayout: number;
    regionCount: number;
    pRegions: VkBufferImageCopy2Deserialized
}
export interface VkCopyBufferToImageInfo2KHRDeserialized {

}
export interface VkCopyImageToBufferInfo2Deserialized {
    pNext?: ptr64_t;
    srcImage: ptr64_t;
    srcImageLayout: number;
    dstBuffer: ptr64_t;
    regionCount: number;
    pRegions: VkBufferImageCopy2Deserialized
}
export interface VkCopyImageToBufferInfo2KHRDeserialized {

}
export interface VkResolveImageInfo2Deserialized {
    pNext?: ptr64_t;
    srcImage: ptr64_t;
    srcImageLayout: number;
    dstImage: ptr64_t;
    dstImageLayout: number;
    regionCount: number;
    pRegions: VkImageResolve2Deserialized
}
export interface VkResolveImageInfo2KHRDeserialized {

}
export interface VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTDeserialized {
    pNext?: ptr64_t;
    shaderImageInt64Atomics: boolean;
    sparseImageInt64Atomics: boolean
}
export interface VkFragmentShadingRateAttachmentInfoKHRDeserialized {
    pNext?: ptr64_t;
    pFragmentShadingRateAttachment?: VkAttachmentReference2Deserialized;
    shadingRateAttachmentTexelSize: VkExtent2DDeserialized[]
}
export interface VkPipelineFragmentShadingRateStateCreateInfoKHRDeserialized {
    pNext?: ptr64_t;
    fragmentSize: VkExtent2DDeserialized[];
    combinerOps: number
}
export interface VkPhysicalDeviceFragmentShadingRateFeaturesKHRDeserialized {
    pNext?: ptr64_t;
    pipelineFragmentShadingRate: boolean;
    primitiveFragmentShadingRate: boolean;
    attachmentFragmentShadingRate: boolean
}
export interface VkPhysicalDeviceFragmentShadingRatePropertiesKHRDeserialized {
    pNext?: ptr64_t;
    minFragmentShadingRateAttachmentTexelSize: VkExtent2DDeserialized[];
    maxFragmentShadingRateAttachmentTexelSize: VkExtent2DDeserialized[];
    maxFragmentShadingRateAttachmentTexelSizeAspectRatio: number;
    primitiveFragmentShadingRateWithMultipleViewports: boolean;
    layeredShadingRateAttachments: boolean;
    fragmentShadingRateNonTrivialCombinerOps: boolean;
    maxFragmentSize: VkExtent2DDeserialized[];
    maxFragmentSizeAspectRatio: number;
    maxFragmentShadingRateCoverageSamples: number;
    maxFragmentShadingRateRasterizationSamples: number;
    fragmentShadingRateWithShaderDepthStencilWrites: boolean;
    fragmentShadingRateWithSampleMask: boolean;
    fragmentShadingRateWithShaderSampleMask: boolean;
    fragmentShadingRateWithConservativeRasterization: boolean;
    fragmentShadingRateWithFragmentShaderInterlock: boolean;
    fragmentShadingRateWithCustomSampleLocations: boolean;
    fragmentShadingRateStrictMultiplyCombiner: boolean
}
export interface VkPhysicalDeviceFragmentShadingRateKHRDeserialized {
    pNext?: ptr64_t;
    sampleCounts: number;
    fragmentSize: VkExtent2DDeserialized[]
}
export interface VkPhysicalDeviceShaderTerminateInvocationFeaturesDeserialized {
    pNext?: ptr64_t;
    shaderTerminateInvocation: boolean
}
export interface VkPhysicalDeviceShaderTerminateInvocationFeaturesKHRDeserialized {

}
export interface VkPhysicalDeviceImage2DViewOf3DFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    image2DViewOf3D: boolean;
    sampler2DViewOf3D: boolean
}
export interface VkPhysicalDeviceMutableDescriptorTypeFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    mutableDescriptorType: boolean
}
export interface VkMutableDescriptorTypeListEXTDeserialized {
    descriptorTypeCount?: number;
    pDescriptorTypes: number
}
export interface VkMutableDescriptorTypeCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    mutableDescriptorTypeListCount?: number;
    pMutableDescriptorTypeLists: VkMutableDescriptorTypeListEXTDeserialized
}
export interface VkPhysicalDeviceVertexInputDynamicStateFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    vertexInputDynamicState: boolean
}
export interface VkMemoryBarrier2Deserialized {
    pNext?: ptr64_t;
    srcStageMask?: number;
    srcAccessMask?: number;
    dstStageMask?: number;
    dstAccessMask?: number
}
export interface VkMemoryBarrier2KHRDeserialized {

}
export interface VkImageMemoryBarrier2Deserialized {
    pNext?: ptr64_t;
    srcStageMask?: number;
    srcAccessMask?: number;
    dstStageMask?: number;
    dstAccessMask?: number;
    oldLayout: number;
    newLayout: number;
    srcQueueFamilyIndex: number;
    dstQueueFamilyIndex: number;
    image: ptr64_t;
    subresourceRange: VkImageSubresourceRangeDeserialized[]
}
export interface VkImageMemoryBarrier2KHRDeserialized {

}
export interface VkBufferMemoryBarrier2Deserialized {
    pNext?: ptr64_t;
    srcStageMask?: number;
    srcAccessMask?: number;
    dstStageMask?: number;
    dstAccessMask?: number;
    srcQueueFamilyIndex: number;
    dstQueueFamilyIndex: number;
    buffer: ptr64_t;
    offset: number;
    size: number
}
export interface VkBufferMemoryBarrier2KHRDeserialized {

}
export interface VkDependencyInfoDeserialized {
    pNext?: ptr64_t;
    dependencyFlags?: number;
    memoryBarrierCount?: number;
    pMemoryBarriers: VkMemoryBarrier2Deserialized;
    bufferMemoryBarrierCount?: number;
    pBufferMemoryBarriers: VkBufferMemoryBarrier2Deserialized;
    imageMemoryBarrierCount?: number;
    pImageMemoryBarriers: VkImageMemoryBarrier2Deserialized
}
export interface VkDependencyInfoKHRDeserialized {

}
export interface VkSemaphoreSubmitInfoDeserialized {
    pNext?: ptr64_t;
    semaphore: ptr64_t;
    value: number;
    stageMask?: number;
    deviceIndex: number
}
export interface VkSemaphoreSubmitInfoKHRDeserialized {

}
export interface VkCommandBufferSubmitInfoDeserialized {
    pNext?: ptr64_t;
    commandBuffer: ptr64_t;
    deviceMask: number
}
export interface VkCommandBufferSubmitInfoKHRDeserialized {

}
export interface VkSubmitInfo2Deserialized {
    pNext?: ptr64_t;
    flags?: number;
    waitSemaphoreInfoCount?: number;
    pWaitSemaphoreInfos: VkSemaphoreSubmitInfoDeserialized;
    commandBufferInfoCount?: number;
    pCommandBufferInfos: VkCommandBufferSubmitInfoDeserialized;
    signalSemaphoreInfoCount?: number;
    pSignalSemaphoreInfos: VkSemaphoreSubmitInfoDeserialized
}
export interface VkSubmitInfo2KHRDeserialized {

}
export interface VkQueueFamilyCheckpointProperties2NVDeserialized {
    pNext?: ptr64_t;
    checkpointExecutionStageMask: number
}
export interface VkCheckpointData2NVDeserialized {
    pNext?: ptr64_t;
    stage: number;
    pCheckpointMarker: ptr64_t
}
export interface VkPhysicalDeviceSynchronization2FeaturesDeserialized {
    pNext?: ptr64_t;
    synchronization2: boolean
}
export interface VkPhysicalDeviceSynchronization2FeaturesKHRDeserialized {

}
export interface VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    primitivesGeneratedQuery: boolean;
    primitivesGeneratedQueryWithRasterizerDiscard: boolean;
    primitivesGeneratedQueryWithNonZeroStreams: boolean
}
export interface VkPhysicalDeviceLegacyDitheringFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    legacyDithering: boolean
}
export interface VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    multisampledRenderToSingleSampled: boolean
}
export interface VkSubpassResolvePerformanceQueryEXTDeserialized {
    pNext?: ptr64_t;
    optimal: boolean
}
export interface VkMultisampledRenderToSingleSampledInfoEXTDeserialized {
    pNext?: ptr64_t;
    multisampledRenderToSingleSampledEnable: boolean;
    rasterizationSamples: number
}
export interface VkPhysicalDevicePipelineProtectedAccessFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    pipelineProtectedAccess: boolean
}
export interface VkQueueFamilyVideoPropertiesKHRDeserialized {
    pNext?: ptr64_t;
    videoCodecOperations: number
}
export interface VkQueueFamilyQueryResultStatusPropertiesKHRDeserialized {
    pNext?: ptr64_t;
    queryResultStatusSupport: boolean
}
export interface VkVideoProfileListInfoKHRDeserialized {
    pNext?: ptr64_t;
    profileCount?: number;
    pProfiles: VkVideoProfileInfoKHRDeserialized
}
export interface VkPhysicalDeviceVideoFormatInfoKHRDeserialized {
    pNext?: ptr64_t;
    imageUsage: number
}
export interface VkVideoFormatPropertiesKHRDeserialized {
    pNext?: ptr64_t;
    format: number;
    componentMapping: VkComponentMappingDeserialized[];
    imageCreateFlags: number;
    imageType: number;
    imageTiling: number;
    imageUsageFlags: number
}
export interface VkVideoProfileInfoKHRDeserialized {
    pNext?: ptr64_t;
    videoCodecOperation: number;
    chromaSubsampling: number;
    lumaBitDepth: number;
    chromaBitDepth?: number
}
export interface VkVideoCapabilitiesKHRDeserialized {
    pNext?: ptr64_t;
    flags: number;
    minBitstreamBufferOffsetAlignment: number;
    minBitstreamBufferSizeAlignment: number;
    pictureAccessGranularity: VkExtent2DDeserialized[];
    minCodedExtent: VkExtent2DDeserialized[];
    maxCodedExtent: VkExtent2DDeserialized[];
    maxDpbSlots: number;
    maxActiveReferencePictures: number;
    stdHeaderVersion: VkExtensionPropertiesDeserialized[]
}
export interface VkVideoSessionMemoryRequirementsKHRDeserialized {
    pNext?: ptr64_t;
    memoryBindIndex: number;
    memoryRequirements: VkMemoryRequirementsDeserialized[]
}
export interface VkBindVideoSessionMemoryInfoKHRDeserialized {
    pNext?: ptr64_t;
    memoryBindIndex: number;
    memory: ptr64_t;
    memoryOffset: number;
    memorySize: number
}
export interface VkVideoPictureResourceInfoKHRDeserialized {
    pNext?: ptr64_t;
    codedOffset: VkOffset2DDeserialized[];
    codedExtent: VkExtent2DDeserialized[];
    baseArrayLayer: number;
    imageViewBinding: ptr64_t
}
export interface VkVideoReferenceSlotInfoKHRDeserialized {
    pNext?: ptr64_t;
    slotIndex: number;
    pPictureResource?: VkVideoPictureResourceInfoKHRDeserialized
}
export interface VkVideoSessionCreateInfoKHRDeserialized {
    pNext?: ptr64_t;
    queueFamilyIndex: number;
    flags?: number;
    pVideoProfile: VkVideoProfileInfoKHRDeserialized;
    pictureFormat: number;
    maxCodedExtent: VkExtent2DDeserialized[];
    referencePictureFormat: number;
    maxDpbSlots: number;
    maxActiveReferencePictures: number;
    pStdHeaderVersion: VkExtensionPropertiesDeserialized
}
export interface VkVideoSessionParametersCreateInfoKHRDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    videoSessionParametersTemplate?: ptr64_t;
    videoSession: ptr64_t
}
export interface VkVideoSessionParametersUpdateInfoKHRDeserialized {
    pNext?: ptr64_t;
    updateSequenceCount: number
}
export interface VkVideoBeginCodingInfoKHRDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    videoSession: ptr64_t;
    videoSessionParameters?: ptr64_t;
    referenceSlotCount?: number;
    pReferenceSlots: VkVideoReferenceSlotInfoKHRDeserialized
}
export interface VkVideoEndCodingInfoKHRDeserialized {
    pNext?: ptr64_t;
    flags?: number
}
export interface VkVideoCodingControlInfoKHRDeserialized {
    pNext?: ptr64_t;
    flags: number
}
export interface VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    ycbcr2plane444Formats: boolean
}
export interface VkPhysicalDeviceProvokingVertexFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    provokingVertexLast: boolean;
    transformFeedbackPreservesProvokingVertex: boolean
}
export interface VkPhysicalDeviceProvokingVertexPropertiesEXTDeserialized {
    pNext?: ptr64_t;
    provokingVertexModePerPipeline: boolean;
    transformFeedbackPreservesTriangleFanProvokingVertex: boolean
}
export interface VkPipelineRasterizationProvokingVertexStateCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    provokingVertexMode: number
}
export interface VkPhysicalDeviceShaderIntegerDotProductFeaturesDeserialized {
    pNext?: ptr64_t;
    shaderIntegerDotProduct: boolean
}
export interface VkPhysicalDeviceShaderIntegerDotProductFeaturesKHRDeserialized {

}
export interface VkPhysicalDeviceShaderIntegerDotProductPropertiesDeserialized {
    pNext?: ptr64_t;
    integerDotProduct8BitUnsignedAccelerated: boolean;
    integerDotProduct8BitSignedAccelerated: boolean;
    integerDotProduct8BitMixedSignednessAccelerated: boolean;
    integerDotProduct4x8BitPackedUnsignedAccelerated: boolean;
    integerDotProduct4x8BitPackedSignedAccelerated: boolean;
    integerDotProduct4x8BitPackedMixedSignednessAccelerated: boolean;
    integerDotProduct16BitUnsignedAccelerated: boolean;
    integerDotProduct16BitSignedAccelerated: boolean;
    integerDotProduct16BitMixedSignednessAccelerated: boolean;
    integerDotProduct32BitUnsignedAccelerated: boolean;
    integerDotProduct32BitSignedAccelerated: boolean;
    integerDotProduct32BitMixedSignednessAccelerated: boolean;
    integerDotProduct64BitUnsignedAccelerated: boolean;
    integerDotProduct64BitSignedAccelerated: boolean;
    integerDotProduct64BitMixedSignednessAccelerated: boolean;
    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating8BitSignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: boolean;
    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: boolean;
    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating16BitSignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: boolean;
    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating32BitSignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: boolean;
    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating64BitSignedAccelerated: boolean;
    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: boolean
}
export interface VkPhysicalDeviceShaderIntegerDotProductPropertiesKHRDeserialized {

}
export interface VkPhysicalDeviceDrmPropertiesEXTDeserialized {
    pNext?: ptr64_t;
    hasPrimary: boolean;
    hasRender: boolean;
    primaryMajor: number;
    primaryMinor: number;
    renderMajor: number;
    renderMinor: number
}
export interface VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHRDeserialized {
    pNext?: ptr64_t;
    fragmentShaderBarycentric: boolean
}
export interface VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHRDeserialized {
    pNext?: ptr64_t;
    triStripVertexOrderIndependentOfProvokingVertex: boolean
}
export interface VkPhysicalDeviceRGBA10X6FormatsFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    formatRgba10x6WithoutYCbCrSampler: boolean
}
export interface VkFormatProperties3Deserialized {
    pNext?: ptr64_t;
    linearTilingFeatures?: number;
    optimalTilingFeatures?: number;
    bufferFeatures?: number
}
export interface VkFormatProperties3KHRDeserialized {

}
export interface VkDrmFormatModifierPropertiesList2EXTDeserialized {
    pNext?: ptr64_t;
    drmFormatModifierCount?: number;
    pDrmFormatModifierProperties?: VkDrmFormatModifierProperties2EXTDeserialized
}
export interface VkDrmFormatModifierProperties2EXTDeserialized {
    drmFormatModifier: number;
    drmFormatModifierPlaneCount: number;
    drmFormatModifierTilingFeatures: number
}
export interface VkPipelineRenderingCreateInfoDeserialized {
    pNext?: ptr64_t;
    viewMask: number;
    colorAttachmentCount?: number;
    pColorAttachmentFormats: number;
    depthAttachmentFormat: number;
    stencilAttachmentFormat: number
}
export interface VkPipelineRenderingCreateInfoKHRDeserialized {

}
export interface VkRenderingInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    renderArea: VkRect2DDeserialized[];
    layerCount: number;
    viewMask: number;
    colorAttachmentCount?: number;
    pColorAttachments: VkRenderingAttachmentInfoDeserialized;
    pDepthAttachment?: VkRenderingAttachmentInfoDeserialized;
    pStencilAttachment?: VkRenderingAttachmentInfoDeserialized
}
export interface VkRenderingAttachmentInfoDeserialized {
    pNext?: ptr64_t;
    imageView?: ptr64_t;
    imageLayout: number;
    resolveMode?: number;
    resolveImageView?: ptr64_t;
    resolveImageLayout: number;
    loadOp: number;
    storeOp: number;
    clearValue: VkClearValueDeserialized[]
}
export interface VkRenderingAttachmentInfoKHRDeserialized {

}
export interface VkRenderingFragmentShadingRateAttachmentInfoKHRDeserialized {
    pNext?: ptr64_t;
    imageView?: ptr64_t;
    imageLayout: number;
    shadingRateAttachmentTexelSize: VkExtent2DDeserialized[]
}
export interface VkRenderingFragmentDensityMapAttachmentInfoEXTDeserialized {
    pNext?: ptr64_t;
    imageView: ptr64_t;
    imageLayout: number
}
export interface VkPhysicalDeviceDynamicRenderingFeaturesDeserialized {
    pNext?: ptr64_t;
    dynamicRendering: boolean
}
export interface VkPhysicalDeviceDynamicRenderingFeaturesKHRDeserialized {

}
export interface VkCommandBufferInheritanceRenderingInfoDeserialized {
    pNext?: ptr64_t;
    flags?: number;
    viewMask: number;
    colorAttachmentCount?: number;
    pColorAttachmentFormats: number;
    depthAttachmentFormat: number;
    stencilAttachmentFormat: number;
    rasterizationSamples?: number
}
export interface VkCommandBufferInheritanceRenderingInfoKHRDeserialized {

}
export interface VkAttachmentSampleCountInfoAMDDeserialized {
    pNext?: ptr64_t;
    colorAttachmentCount?: number;
    pColorAttachmentSamples: number;
    depthStencilAttachmentSamples?: number
}
export interface VkAttachmentSampleCountInfoNVDeserialized {

}
export interface VkMultiviewPerViewAttributesInfoNVXDeserialized {
    pNext?: ptr64_t;
    perViewAttributes: boolean;
    perViewAttributesPositionXOnly: boolean
}
export interface VkPhysicalDeviceImageViewMinLodFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    minLod: boolean
}
export interface VkImageViewMinLodCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    minLod: number
}
export interface VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    rasterizationOrderColorAttachmentAccess: boolean;
    rasterizationOrderDepthAttachmentAccess: boolean;
    rasterizationOrderStencilAttachmentAccess: boolean
}
export interface VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    graphicsPipelineLibrary: boolean
}
export interface VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXTDeserialized {
    pNext?: ptr64_t;
    graphicsPipelineLibraryFastLinking: boolean;
    graphicsPipelineLibraryIndependentInterpolationDecoration: boolean
}
export interface VkGraphicsPipelineLibraryCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    flags: number
}
export interface VkPhysicalDeviceShaderModuleIdentifierFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    shaderModuleIdentifier: boolean
}
export interface VkPhysicalDeviceShaderModuleIdentifierPropertiesEXTDeserialized {
    pNext?: ptr64_t;
    shaderModuleIdentifierAlgorithmUUID: number
}
export interface VkPipelineShaderStageModuleIdentifierCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    identifierSize?: number;
    pIdentifier: number
}
export interface VkShaderModuleIdentifierEXTDeserialized {
    pNext?: ptr64_t;
    identifierSize: number;
    identifier: number
}
export interface VkImageCompressionControlEXTDeserialized {
    pNext?: ptr64_t;
    flags: number;
    compressionControlPlaneCount?: number;
    pFixedRateFlags: number
}
export interface VkPhysicalDeviceImageCompressionControlFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    imageCompressionControl: boolean
}
export interface VkImageCompressionPropertiesEXTDeserialized {
    pNext?: ptr64_t;
    imageCompressionFlags: number;
    imageCompressionFixedRateFlags: number
}
export interface VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    imageCompressionControlSwapchain: boolean
}
export interface VkRenderPassCreationControlEXTDeserialized {
    pNext?: ptr64_t;
    disallowMerging: boolean
}
export interface VkRenderPassCreationFeedbackInfoEXTDeserialized {
    postMergeSubpassCount: number
}
export interface VkRenderPassCreationFeedbackCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    pRenderPassFeedback: VkRenderPassCreationFeedbackInfoEXTDeserialized
}
export interface VkRenderPassSubpassFeedbackInfoEXTDeserialized {
    subpassMergeStatus: number;
    description: string;
    postMergeIndex: number
}
export interface VkRenderPassSubpassFeedbackCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    pSubpassFeedback: VkRenderPassSubpassFeedbackInfoEXTDeserialized
}
export interface VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    subpassMergeFeedback: boolean
}
export interface VkPipelinePropertiesIdentifierEXTDeserialized {
    pNext?: ptr64_t;
    pipelineIdentifier: number
}
export interface VkPhysicalDevicePipelinePropertiesFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    pipelinePropertiesIdentifier: boolean
}
export interface VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    nonSeamlessCubeMap: boolean
}
export interface VkPhysicalDevicePipelineRobustnessFeaturesEXTDeserialized {
    pNext?: ptr64_t;
    pipelineRobustness: boolean
}
export interface VkPipelineRobustnessCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    storageBuffers: number;
    uniformBuffers: number;
    vertexInputs: number;
    images: number
}
export interface VkPhysicalDevicePipelineRobustnessPropertiesEXTDeserialized {
    pNext?: ptr64_t;
    defaultRobustnessStorageBuffers: number;
    defaultRobustnessUniformBuffers: number;
    defaultRobustnessVertexInputs: number;
    defaultRobustnessImages: number
}
export interface VkSurfacePresentModeEXTDeserialized {
    pNext?: ptr64_t;
    presentMode: number
}
export interface VkSurfacePresentScalingCapabilitiesEXTDeserialized {
    pNext?: ptr64_t;
    supportedPresentScaling?: number;
    supportedPresentGravityX?: number;
    supportedPresentGravityY?: number;
    minScaledImageExtent?: VkExtent2DDeserialized[];
    maxScaledImageExtent?: VkExtent2DDeserialized[]
}
export interface VkSurfacePresentModeCompatibilityEXTDeserialized {
    pNext?: ptr64_t;
    presentModeCount?: number;
    pPresentModes?: number
}
export interface VkPhysicalDeviceSwapchainMaintenance1FeaturesEXTDeserialized {
    pNext?: ptr64_t;
    swapchainMaintenance1: boolean
}
export interface VkSwapchainPresentFenceInfoEXTDeserialized {
    pNext?: ptr64_t;
    swapchainCount: number;
    pFences: ptr64_t
}
export interface VkSwapchainPresentModesCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    presentModeCount: number;
    pPresentModes: number
}
export interface VkSwapchainPresentModeInfoEXTDeserialized {
    pNext?: ptr64_t;
    swapchainCount: number;
    pPresentModes: number
}
export interface VkSwapchainPresentScalingCreateInfoEXTDeserialized {
    pNext?: ptr64_t;
    scalingBehavior?: number;
    presentGravityX?: number;
    presentGravityY?: number
}
export interface VkReleaseSwapchainImagesInfoEXTDeserialized {
    pNext?: ptr64_t;
    swapchain: ptr64_t;
    imageIndexCount: number;
    pImageIndices: number
}
export interface VkBaseOutStructureInput {
    pNext?: VkBaseOutStructure| null | Membuf
}
export interface VkBaseInStructureInput {
    pNext?: VkBaseInStructure| null | Membuf
}
export interface VkOffset2DInput {
    x: int32_t | number | Membuf;
    y: int32_t | number | Membuf
}
export interface VkOffset3DInput {
    x: int32_t | number | Membuf;
    y: int32_t | number | Membuf;
    z: int32_t | number | Membuf
}
export interface VkExtent2DInput {
    width: uint32_t | number | Membuf;
    height: uint32_t | number | Membuf
}
export interface VkExtent3DInput {
    width: uint32_t | number | Membuf;
    height: uint32_t | number | Membuf;
    depth: uint32_t | number | Membuf
}
export interface VkViewportInput {
    x: float | number | Membuf;
    y: float | number | Membuf;
    width: float | number | Membuf;
    height: float | number | Membuf;
    minDepth: float | number | Membuf;
    maxDepth: float | number | Membuf
}
export interface VkRect2DInput {
    offset: VkOffset2D[] | Membuf;
    extent: VkExtent2D[] | Membuf
}
export interface VkClearRectInput {
    rect: VkRect2D[] | Membuf;
    baseArrayLayer: uint32_t | number | Membuf;
    layerCount: uint32_t | number | Membuf
}
export interface VkComponentMappingInput {
    r: int32_t | number | Membuf;
    g: int32_t | number | Membuf;
    b: int32_t | number | Membuf;
    a: int32_t | number | Membuf
}
export interface VkPhysicalDevicePropertiesInput {
    apiVersion: uint32_t | number | Membuf;
    driverVersion: uint32_t | number | Membuf;
    vendorID: uint32_t | number | Membuf;
    deviceID: uint32_t | number | Membuf;
    deviceType: int32_t | number | Membuf;
    deviceName: char[] | null | Membuf;
    pipelineCacheUUID: uint8_t[] | null | Membuf;
    limits: VkPhysicalDeviceLimits[] | Membuf;
    sparseProperties: VkPhysicalDeviceSparseProperties[] | Membuf
}
export interface VkExtensionPropertiesInput {
    extensionName: char[] | null | Membuf;
    specVersion: uint32_t | number | Membuf
}
export interface VkLayerPropertiesInput {
    layerName: char[] | null | Membuf;
    specVersion: uint32_t | number | Membuf;
    implementationVersion: uint32_t | number | Membuf;
    description: char[] | null | Membuf
}
export interface VkApplicationInfoInput {
    pNext?: ptr64_t| null | Membuf;
    pApplicationName?: string | Membuf;
    applicationVersion: uint32_t | number | Membuf;
    pEngineName?: string | Membuf;
    engineVersion: uint32_t | number | Membuf;
    apiVersion: uint32_t | number | Membuf
}
export interface VkAllocationCallbacksInput {
    pUserData?: ptr64_t| null | Membuf;
    pfnAllocation: ptr64_t | Membuf;
    pfnReallocation: ptr64_t | Membuf;
    pfnFree: ptr64_t | Membuf;
    pfnInternalAllocation?: ptr64_t | Membuf;
    pfnInternalFree?: ptr64_t | Membuf
}
export interface VkDeviceQueueCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    queueFamilyIndex: uint32_t | number | Membuf;
    queueCount: uint32_t | number | Membuf;
    pQueuePriorities: float[] | null | Membuf
}
export interface VkDeviceCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: int32_t | number | Membuf;
    queueCreateInfoCount: uint32_t | number | Membuf;
    pQueueCreateInfos: VkDeviceQueueCreateInfo[] | null | Membuf;
    enabledExtensionCount?: uint32_t | number | Membuf;
    ppEnabledExtensionNames: string[] | Membuf;
    pEnabledFeatures?: VkPhysicalDeviceFeatures| null | Membuf
}
export interface VkInstanceCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    pApplicationInfo?: VkApplicationInfo| null | Membuf;
    enabledLayerCount?: uint32_t | number | Membuf;
    ppEnabledLayerNames: string[] | Membuf;
    enabledExtensionCount?: uint32_t | number | Membuf;
    ppEnabledExtensionNames: string[] | Membuf
}
export interface VkQueueFamilyPropertiesInput {
    queueFlags?: uint32_t | number | Membuf;
    queueCount: uint32_t | number | Membuf;
    timestampValidBits: uint32_t | number | Membuf;
    minImageTransferGranularity: VkExtent3D[] | Membuf
}
export interface VkPhysicalDeviceMemoryPropertiesInput {
    memoryTypeCount: uint32_t | number | Membuf;
    memoryTypes: VkMemoryType[] | Membuf;
    memoryHeapCount: uint32_t | number | Membuf;
    memoryHeaps: VkMemoryHeap[] | Membuf
}
export interface VkMemoryAllocateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    allocationSize: uint64_t | number | Membuf;
    memoryTypeIndex: uint32_t | number | Membuf
}
export interface VkMemoryRequirementsInput {
    size: uint64_t | number | Membuf;
    alignment: uint64_t | number | Membuf;
    memoryTypeBits: uint32_t | number | Membuf
}
export interface VkSparseImageFormatPropertiesInput {
    aspectMask?: uint32_t | number | Membuf;
    imageGranularity: VkExtent3D[] | Membuf;
    flags?: uint32_t | number | Membuf
}
export interface VkSparseImageMemoryRequirementsInput {
    formatProperties: VkSparseImageFormatProperties[] | Membuf;
    imageMipTailFirstLod: uint32_t | number | Membuf;
    imageMipTailSize: uint64_t | number | Membuf;
    imageMipTailOffset: uint64_t | number | Membuf;
    imageMipTailStride: uint64_t | number | Membuf
}
export interface VkMemoryTypeInput {
    propertyFlags?: uint32_t | number | Membuf;
    heapIndex: uint32_t | number | Membuf
}
export interface VkMemoryHeapInput {
    size: uint64_t | number | Membuf;
    flags?: uint32_t | number | Membuf
}
export interface VkMappedMemoryRangeInput {
    pNext?: ptr64_t| null | Membuf;
    memory: ptr64_t | Membuf;
    offset: uint64_t | number | Membuf;
    size: uint64_t | number | Membuf
}
export interface VkFormatPropertiesInput {
    linearTilingFeatures?: uint32_t | number | Membuf;
    optimalTilingFeatures?: uint32_t | number | Membuf;
    bufferFeatures?: uint32_t | number | Membuf
}
export interface VkImageFormatPropertiesInput {
    maxExtent: VkExtent3D[] | Membuf;
    maxMipLevels: uint32_t | number | Membuf;
    maxArrayLayers: uint32_t | number | Membuf;
    sampleCounts?: uint32_t | number | Membuf;
    maxResourceSize: uint64_t | number | Membuf
}
export interface VkDescriptorBufferInfoInput {
    buffer?: ptr64_t | Membuf;
    offset: uint64_t | number | Membuf;
    range: uint64_t | number | Membuf
}
export interface VkDescriptorImageInfoInput {
    sampler: ptr64_t | Membuf;
    imageView: ptr64_t | Membuf;
    imageLayout: int32_t | number | Membuf
}
export interface VkWriteDescriptorSetInput {
    pNext?: ptr64_t| null | Membuf;
    dstSet: ptr64_t | Membuf;
    dstBinding: uint32_t | number | Membuf;
    dstArrayElement: uint32_t | number | Membuf;
    descriptorCount: uint32_t | number | Membuf;
    descriptorType: int32_t | number | Membuf;
    pImageInfo: VkDescriptorImageInfo[] | null | Membuf;
    pBufferInfo: VkDescriptorBufferInfo[] | null | Membuf;
    pTexelBufferView: ptr64_t[] | null | Membuf
}
export interface VkCopyDescriptorSetInput {
    pNext?: ptr64_t| null | Membuf;
    srcSet: ptr64_t | Membuf;
    srcBinding: uint32_t | number | Membuf;
    srcArrayElement: uint32_t | number | Membuf;
    dstSet: ptr64_t | Membuf;
    dstBinding: uint32_t | number | Membuf;
    dstArrayElement: uint32_t | number | Membuf;
    descriptorCount: uint32_t | number | Membuf
}
export interface VkBufferCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    size: uint64_t | number | Membuf;
    usage: uint32_t | number | Membuf;
    sharingMode: int32_t | number | Membuf;
    queueFamilyIndexCount?: uint32_t | number | Membuf;
    pQueueFamilyIndices: uint32_t[] | null | Membuf
}
export interface VkBufferViewCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: int32_t | number | Membuf;
    buffer: ptr64_t | Membuf;
    format: int32_t | number | Membuf;
    offset: uint64_t | number | Membuf;
    range: uint64_t | number | Membuf
}
export interface VkImageSubresourceInput {
    aspectMask: uint32_t | number | Membuf;
    mipLevel: uint32_t | number | Membuf;
    arrayLayer: uint32_t | number | Membuf
}
export interface VkImageSubresourceLayersInput {
    aspectMask: uint32_t | number | Membuf;
    mipLevel: uint32_t | number | Membuf;
    baseArrayLayer: uint32_t | number | Membuf;
    layerCount: uint32_t | number | Membuf
}
export interface VkImageSubresourceRangeInput {
    aspectMask: uint32_t | number | Membuf;
    baseMipLevel: uint32_t | number | Membuf;
    levelCount: uint32_t | number | Membuf;
    baseArrayLayer: uint32_t | number | Membuf;
    layerCount: uint32_t | number | Membuf
}
export interface VkMemoryBarrierInput {
    pNext?: ptr64_t| null | Membuf;
    srcAccessMask?: uint32_t | number | Membuf;
    dstAccessMask?: uint32_t | number | Membuf
}
export interface VkBufferMemoryBarrierInput {
    pNext?: ptr64_t| null | Membuf;
    srcAccessMask: uint32_t | number | Membuf;
    dstAccessMask: uint32_t | number | Membuf;
    srcQueueFamilyIndex: uint32_t | number | Membuf;
    dstQueueFamilyIndex: uint32_t | number | Membuf;
    buffer: ptr64_t | Membuf;
    offset: uint64_t | number | Membuf;
    size: uint64_t | number | Membuf
}
export interface VkImageMemoryBarrierInput {
    pNext?: ptr64_t| null | Membuf;
    srcAccessMask: uint32_t | number | Membuf;
    dstAccessMask: uint32_t | number | Membuf;
    oldLayout: int32_t | number | Membuf;
    newLayout: int32_t | number | Membuf;
    srcQueueFamilyIndex: uint32_t | number | Membuf;
    dstQueueFamilyIndex: uint32_t | number | Membuf;
    image: ptr64_t | Membuf;
    subresourceRange: VkImageSubresourceRange[] | Membuf
}
export interface VkImageCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    imageType: int32_t | number | Membuf;
    format: int32_t | number | Membuf;
    extent: VkExtent3D[] | Membuf;
    mipLevels: uint32_t | number | Membuf;
    arrayLayers: uint32_t | number | Membuf;
    samples: uint32_t | number | Membuf;
    tiling: int32_t | number | Membuf;
    usage: uint32_t | number | Membuf;
    sharingMode: int32_t | number | Membuf;
    queueFamilyIndexCount?: uint32_t | number | Membuf;
    pQueueFamilyIndices: uint32_t[] | null | Membuf;
    initialLayout: int32_t | number | Membuf
}
export interface VkSubresourceLayoutInput {
    offset: uint64_t | number | Membuf;
    size: uint64_t | number | Membuf;
    rowPitch: uint64_t | number | Membuf;
    arrayPitch: uint64_t | number | Membuf;
    depthPitch: uint64_t | number | Membuf
}
export interface VkImageViewCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    image: ptr64_t | Membuf;
    viewType: int32_t | number | Membuf;
    format: int32_t | number | Membuf;
    components: VkComponentMapping[] | Membuf;
    subresourceRange: VkImageSubresourceRange[] | Membuf
}
export interface VkBufferCopyInput {
    srcOffset: uint64_t | number | Membuf;
    dstOffset: uint64_t | number | Membuf;
    size: uint64_t | number | Membuf
}
export interface VkSparseMemoryBindInput {
    resourceOffset: uint64_t | number | Membuf;
    size: uint64_t | number | Membuf;
    memory?: ptr64_t | Membuf;
    memoryOffset: uint64_t | number | Membuf;
    flags?: uint32_t | number | Membuf
}
export interface VkSparseImageMemoryBindInput {
    subresource: VkImageSubresource[] | Membuf;
    offset: VkOffset3D[] | Membuf;
    extent: VkExtent3D[] | Membuf;
    memory?: ptr64_t | Membuf;
    memoryOffset: uint64_t | number | Membuf;
    flags?: uint32_t | number | Membuf
}
export interface VkSparseBufferMemoryBindInfoInput {
    buffer: ptr64_t | Membuf;
    bindCount: uint32_t | number | Membuf;
    pBinds: VkSparseMemoryBind[] | null | Membuf
}
export interface VkSparseImageOpaqueMemoryBindInfoInput {
    image: ptr64_t | Membuf;
    bindCount: uint32_t | number | Membuf;
    pBinds: VkSparseMemoryBind[] | null | Membuf
}
export interface VkSparseImageMemoryBindInfoInput {
    image: ptr64_t | Membuf;
    bindCount: uint32_t | number | Membuf;
    pBinds: VkSparseImageMemoryBind[] | null | Membuf
}
export interface VkBindSparseInfoInput {
    pNext?: ptr64_t| null | Membuf;
    waitSemaphoreCount?: uint32_t | number | Membuf;
    pWaitSemaphores: ptr64_t[] | null | Membuf;
    bufferBindCount?: uint32_t | number | Membuf;
    pBufferBinds: VkSparseBufferMemoryBindInfo[] | null | Membuf;
    imageOpaqueBindCount?: uint32_t | number | Membuf;
    pImageOpaqueBinds: VkSparseImageOpaqueMemoryBindInfo[] | null | Membuf;
    imageBindCount?: uint32_t | number | Membuf;
    pImageBinds: VkSparseImageMemoryBindInfo[] | null | Membuf;
    signalSemaphoreCount?: uint32_t | number | Membuf;
    pSignalSemaphores: ptr64_t[] | null | Membuf
}
export interface VkImageCopyInput {
    srcSubresource: VkImageSubresourceLayers[] | Membuf;
    srcOffset: VkOffset3D[] | Membuf;
    dstSubresource: VkImageSubresourceLayers[] | Membuf;
    dstOffset: VkOffset3D[] | Membuf;
    extent: VkExtent3D[] | Membuf
}
export interface VkImageBlitInput {
    srcSubresource: VkImageSubresourceLayers[] | Membuf;
    srcOffsets: VkOffset3D[] | Membuf;
    dstSubresource: VkImageSubresourceLayers[] | Membuf;
    dstOffsets: VkOffset3D[] | Membuf
}
export interface VkBufferImageCopyInput {
    bufferOffset: uint64_t | number | Membuf;
    bufferRowLength: uint32_t | number | Membuf;
    bufferImageHeight: uint32_t | number | Membuf;
    imageSubresource: VkImageSubresourceLayers[] | Membuf;
    imageOffset: VkOffset3D[] | Membuf;
    imageExtent: VkExtent3D[] | Membuf
}
export interface VkImageResolveInput {
    srcSubresource: VkImageSubresourceLayers[] | Membuf;
    srcOffset: VkOffset3D[] | Membuf;
    dstSubresource: VkImageSubresourceLayers[] | Membuf;
    dstOffset: VkOffset3D[] | Membuf;
    extent: VkExtent3D[] | Membuf
}
export interface VkShaderModuleCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    codeSize: size_t | number | Membuf;
    pCode: uint32_t[] | null | Membuf
}
export interface VkDescriptorSetLayoutBindingInput {
    binding: uint32_t | number | Membuf;
    descriptorType: int32_t | number | Membuf;
    descriptorCount?: uint32_t | number | Membuf;
    stageFlags: uint32_t | number | Membuf;
    pImmutableSamplers?: ptr64_t[] | null | Membuf
}
export interface VkDescriptorSetLayoutCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    bindingCount?: uint32_t | number | Membuf;
    pBindings: VkDescriptorSetLayoutBinding[] | null | Membuf
}
export interface VkDescriptorPoolSizeInput {
    type: int32_t | number | Membuf;
    descriptorCount: uint32_t | number | Membuf
}
export interface VkDescriptorPoolCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    maxSets: uint32_t | number | Membuf;
    poolSizeCount?: uint32_t | number | Membuf;
    pPoolSizes: VkDescriptorPoolSize[] | null | Membuf
}
export interface VkDescriptorSetAllocateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    descriptorPool: ptr64_t | Membuf;
    descriptorSetCount: uint32_t | number | Membuf;
    pSetLayouts: ptr64_t[] | null | Membuf
}
export interface VkSpecializationMapEntryInput {
    constantID: uint32_t | number | Membuf;
    offset: uint32_t | number | Membuf;
    size: size_t | number | Membuf
}
export interface VkSpecializationInfoInput {
    mapEntryCount?: uint32_t | number | Membuf;
    pMapEntries: VkSpecializationMapEntry[] | null | Membuf;
    dataSize?: size_t | number | Membuf;
    pData: ptr64_t[] | null | Membuf
}
export interface VkPipelineShaderStageCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    stage: uint32_t | number | Membuf;
    module?: ptr64_t | Membuf;
    pName: string | Membuf;
    pSpecializationInfo?: VkSpecializationInfo| null | Membuf
}
export interface VkComputePipelineCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    stage: VkPipelineShaderStageCreateInfo[] | Membuf;
    layout: ptr64_t | Membuf;
    basePipelineHandle?: ptr64_t | Membuf;
    basePipelineIndex: int32_t | number | Membuf
}
export interface VkVertexInputBindingDescriptionInput {
    binding: uint32_t | number | Membuf;
    stride: uint32_t | number | Membuf;
    inputRate: int32_t | number | Membuf
}
export interface VkVertexInputAttributeDescriptionInput {
    location: uint32_t | number | Membuf;
    binding: uint32_t | number | Membuf;
    format: int32_t | number | Membuf;
    offset: uint32_t | number | Membuf
}
export interface VkPipelineVertexInputStateCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: int32_t | number | Membuf;
    vertexBindingDescriptionCount?: uint32_t | number | Membuf;
    pVertexBindingDescriptions: VkVertexInputBindingDescription[] | null | Membuf;
    vertexAttributeDescriptionCount?: uint32_t | number | Membuf;
    pVertexAttributeDescriptions: VkVertexInputAttributeDescription[] | null | Membuf
}
export interface VkPipelineInputAssemblyStateCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: int32_t | number | Membuf;
    topology: int32_t | number | Membuf;
    primitiveRestartEnable: uint32_t | boolean | Membuf
}
export interface VkPipelineTessellationStateCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: int32_t | number | Membuf;
    patchControlPoints: uint32_t | number | Membuf
}
export interface VkPipelineViewportStateCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: int32_t | number | Membuf;
    viewportCount?: uint32_t | number | Membuf;
    pViewports?: VkViewport[] | null | Membuf;
    scissorCount?: uint32_t | number | Membuf;
    pScissors?: VkRect2D[] | null | Membuf
}
export interface VkPipelineRasterizationStateCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: int32_t | number | Membuf;
    depthClampEnable: uint32_t | boolean | Membuf;
    rasterizerDiscardEnable: uint32_t | boolean | Membuf;
    polygonMode: int32_t | number | Membuf;
    cullMode?: uint32_t | number | Membuf;
    frontFace: int32_t | number | Membuf;
    depthBiasEnable: uint32_t | boolean | Membuf;
    depthBiasConstantFactor: float | number | Membuf;
    depthBiasClamp: float | number | Membuf;
    depthBiasSlopeFactor: float | number | Membuf;
    lineWidth: float | number | Membuf
}
export interface VkPipelineMultisampleStateCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: int32_t | number | Membuf;
    rasterizationSamples: uint32_t | number | Membuf;
    sampleShadingEnable: uint32_t | boolean | Membuf;
    minSampleShading: float | number | Membuf;
    pSampleMask?: uint32_t[] | null | Membuf;
    alphaToCoverageEnable: uint32_t | boolean | Membuf;
    alphaToOneEnable: uint32_t | boolean | Membuf
}
export interface VkPipelineColorBlendAttachmentStateInput {
    blendEnable: uint32_t | boolean | Membuf;
    srcColorBlendFactor: int32_t | number | Membuf;
    dstColorBlendFactor: int32_t | number | Membuf;
    colorBlendOp: int32_t | number | Membuf;
    srcAlphaBlendFactor: int32_t | number | Membuf;
    dstAlphaBlendFactor: int32_t | number | Membuf;
    alphaBlendOp: int32_t | number | Membuf;
    colorWriteMask?: uint32_t | number | Membuf
}
export interface VkPipelineColorBlendStateCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    logicOpEnable: uint32_t | boolean | Membuf;
    logicOp: int32_t | number | Membuf;
    attachmentCount?: uint32_t | number | Membuf;
    pAttachments?: VkPipelineColorBlendAttachmentState[] | null | Membuf;
    blendConstants: float[] | null | Membuf
}
export interface VkPipelineDynamicStateCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: int32_t | number | Membuf;
    dynamicStateCount?: uint32_t | number | Membuf;
    pDynamicStates: int32_t[] | null | Membuf
}
export interface VkStencilOpStateInput {
    failOp: int32_t | number | Membuf;
    passOp: int32_t | number | Membuf;
    depthFailOp: int32_t | number | Membuf;
    compareOp: int32_t | number | Membuf;
    compareMask: uint32_t | number | Membuf;
    writeMask: uint32_t | number | Membuf;
    reference: uint32_t | number | Membuf
}
export interface VkPipelineDepthStencilStateCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    depthTestEnable: uint32_t | boolean | Membuf;
    depthWriteEnable: uint32_t | boolean | Membuf;
    depthCompareOp: int32_t | number | Membuf;
    depthBoundsTestEnable: uint32_t | boolean | Membuf;
    stencilTestEnable: uint32_t | boolean | Membuf;
    front: VkStencilOpState[] | Membuf;
    back: VkStencilOpState[] | Membuf;
    minDepthBounds: float | number | Membuf;
    maxDepthBounds: float | number | Membuf
}
export interface VkGraphicsPipelineCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    stageCount?: uint32_t | number | Membuf;
    pStages?: VkPipelineShaderStageCreateInfo[] | null | Membuf;
    pVertexInputState?: VkPipelineVertexInputStateCreateInfo| null | Membuf;
    pInputAssemblyState?: VkPipelineInputAssemblyStateCreateInfo| null | Membuf;
    pTessellationState?: VkPipelineTessellationStateCreateInfo| null | Membuf;
    pViewportState?: VkPipelineViewportStateCreateInfo| null | Membuf;
    pRasterizationState?: VkPipelineRasterizationStateCreateInfo| null | Membuf;
    pMultisampleState?: VkPipelineMultisampleStateCreateInfo| null | Membuf;
    pDepthStencilState?: VkPipelineDepthStencilStateCreateInfo| null | Membuf;
    pColorBlendState?: VkPipelineColorBlendStateCreateInfo| null | Membuf;
    pDynamicState?: VkPipelineDynamicStateCreateInfo| null | Membuf;
    layout?: ptr64_t | Membuf;
    renderPass?: ptr64_t | Membuf;
    subpass: uint32_t | number | Membuf;
    basePipelineHandle?: ptr64_t | Membuf;
    basePipelineIndex: int32_t | number | Membuf
}
export interface VkPipelineCacheCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    initialDataSize?: size_t | number | Membuf;
    pInitialData: ptr64_t[] | null | Membuf
}
export interface VkPipelineCacheHeaderVersionOneInput {
    headerSize: uint32_t | number | Membuf;
    headerVersion: int32_t | number | Membuf;
    vendorID: uint32_t | number | Membuf;
    deviceID: uint32_t | number | Membuf;
    pipelineCacheUUID: uint8_t[] | null | Membuf
}
export interface VkPushConstantRangeInput {
    stageFlags: uint32_t | number | Membuf;
    offset: uint32_t | number | Membuf;
    size: uint32_t | number | Membuf
}
export interface VkPipelineLayoutCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    setLayoutCount?: uint32_t | number | Membuf;
    pSetLayouts: ptr64_t[] | null | Membuf;
    pushConstantRangeCount?: uint32_t | number | Membuf;
    pPushConstantRanges: VkPushConstantRange[] | null | Membuf
}
export interface VkSamplerCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    magFilter: int32_t | number | Membuf;
    minFilter: int32_t | number | Membuf;
    mipmapMode: int32_t | number | Membuf;
    addressModeU: int32_t | number | Membuf;
    addressModeV: int32_t | number | Membuf;
    addressModeW: int32_t | number | Membuf;
    mipLodBias: float | number | Membuf;
    anisotropyEnable: uint32_t | boolean | Membuf;
    maxAnisotropy: float | number | Membuf;
    compareEnable: uint32_t | boolean | Membuf;
    compareOp: int32_t | number | Membuf;
    minLod: float | number | Membuf;
    maxLod: float | number | Membuf;
    borderColor: int32_t | number | Membuf;
    unnormalizedCoordinates: uint32_t | boolean | Membuf
}
export interface VkCommandPoolCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    queueFamilyIndex: uint32_t | number | Membuf
}
export interface VkCommandBufferAllocateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    commandPool: ptr64_t | Membuf;
    level: int32_t | number | Membuf;
    commandBufferCount: uint32_t | number | Membuf
}
export interface VkCommandBufferInheritanceInfoInput {
    pNext?: ptr64_t| null | Membuf;
    renderPass?: ptr64_t | Membuf;
    subpass: uint32_t | number | Membuf;
    framebuffer?: ptr64_t | Membuf;
    occlusionQueryEnable: uint32_t | boolean | Membuf;
    queryFlags?: uint32_t | number | Membuf;
    pipelineStatistics?: uint32_t | number | Membuf
}
export interface VkCommandBufferBeginInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    pInheritanceInfo?: VkCommandBufferInheritanceInfo| null | Membuf
}
export interface VkRenderPassBeginInfoInput {
    pNext?: ptr64_t| null | Membuf;
    renderPass: ptr64_t | Membuf;
    framebuffer: ptr64_t | Membuf;
    renderArea: VkRect2D[] | Membuf;
    clearValueCount?: uint32_t | number | Membuf;
    pClearValues: VkClearValue[] | null | Membuf
}
export interface VkClearDepthStencilValueInput {
    depth: float | number | Membuf;
    stencil: uint32_t | number | Membuf
}
export interface VkClearAttachmentInput {
    aspectMask: uint32_t | number | Membuf;
    colorAttachment: uint32_t | number | Membuf;
    clearValue: VkClearValue[] | Membuf
}
export interface VkAttachmentDescriptionInput {
    flags?: uint32_t | number | Membuf;
    format: int32_t | number | Membuf;
    samples: uint32_t | number | Membuf;
    loadOp: int32_t | number | Membuf;
    storeOp: int32_t | number | Membuf;
    stencilLoadOp: int32_t | number | Membuf;
    stencilStoreOp: int32_t | number | Membuf;
    initialLayout: int32_t | number | Membuf;
    finalLayout: int32_t | number | Membuf
}
export interface VkAttachmentReferenceInput {
    attachment: uint32_t | number | Membuf;
    layout: int32_t | number | Membuf
}
export interface VkSubpassDescriptionInput {
    flags?: uint32_t | number | Membuf;
    pipelineBindPoint: int32_t | number | Membuf;
    inputAttachmentCount?: uint32_t | number | Membuf;
    pInputAttachments: VkAttachmentReference[] | null | Membuf;
    colorAttachmentCount?: uint32_t | number | Membuf;
    pColorAttachments: VkAttachmentReference[] | null | Membuf;
    pResolveAttachments?: VkAttachmentReference[] | null | Membuf;
    pDepthStencilAttachment?: VkAttachmentReference| null | Membuf;
    preserveAttachmentCount?: uint32_t | number | Membuf;
    pPreserveAttachments: uint32_t[] | null | Membuf
}
export interface VkSubpassDependencyInput {
    srcSubpass: uint32_t | number | Membuf;
    dstSubpass: uint32_t | number | Membuf;
    srcStageMask?: uint32_t | number | Membuf;
    dstStageMask?: uint32_t | number | Membuf;
    srcAccessMask?: uint32_t | number | Membuf;
    dstAccessMask?: uint32_t | number | Membuf;
    dependencyFlags?: uint32_t | number | Membuf
}
export interface VkRenderPassCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    attachmentCount?: uint32_t | number | Membuf;
    pAttachments: VkAttachmentDescription[] | null | Membuf;
    subpassCount: uint32_t | number | Membuf;
    pSubpasses: VkSubpassDescription[] | null | Membuf;
    dependencyCount?: uint32_t | number | Membuf;
    pDependencies: VkSubpassDependency[] | null | Membuf
}
export interface VkEventCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf
}
export interface VkFenceCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceFeaturesInput {
    robustBufferAccess: uint32_t | boolean | Membuf;
    fullDrawIndexUint32: uint32_t | boolean | Membuf;
    imageCubeArray: uint32_t | boolean | Membuf;
    independentBlend: uint32_t | boolean | Membuf;
    geometryShader: uint32_t | boolean | Membuf;
    tessellationShader: uint32_t | boolean | Membuf;
    sampleRateShading: uint32_t | boolean | Membuf;
    dualSrcBlend: uint32_t | boolean | Membuf;
    logicOp: uint32_t | boolean | Membuf;
    multiDrawIndirect: uint32_t | boolean | Membuf;
    drawIndirectFirstInstance: uint32_t | boolean | Membuf;
    depthClamp: uint32_t | boolean | Membuf;
    depthBiasClamp: uint32_t | boolean | Membuf;
    fillModeNonSolid: uint32_t | boolean | Membuf;
    depthBounds: uint32_t | boolean | Membuf;
    wideLines: uint32_t | boolean | Membuf;
    largePoints: uint32_t | boolean | Membuf;
    alphaToOne: uint32_t | boolean | Membuf;
    multiViewport: uint32_t | boolean | Membuf;
    samplerAnisotropy: uint32_t | boolean | Membuf;
    textureCompressionETC2: uint32_t | boolean | Membuf;
    textureCompressionASTC_LDR: uint32_t | boolean | Membuf;
    textureCompressionBC: uint32_t | boolean | Membuf;
    occlusionQueryPrecise: uint32_t | boolean | Membuf;
    pipelineStatisticsQuery: uint32_t | boolean | Membuf;
    vertexPipelineStoresAndAtomics: uint32_t | boolean | Membuf;
    fragmentStoresAndAtomics: uint32_t | boolean | Membuf;
    shaderTessellationAndGeometryPointSize: uint32_t | boolean | Membuf;
    shaderImageGatherExtended: uint32_t | boolean | Membuf;
    shaderStorageImageExtendedFormats: uint32_t | boolean | Membuf;
    shaderStorageImageMultisample: uint32_t | boolean | Membuf;
    shaderStorageImageReadWithoutFormat: uint32_t | boolean | Membuf;
    shaderStorageImageWriteWithoutFormat: uint32_t | boolean | Membuf;
    shaderUniformBufferArrayDynamicIndexing: uint32_t | boolean | Membuf;
    shaderSampledImageArrayDynamicIndexing: uint32_t | boolean | Membuf;
    shaderStorageBufferArrayDynamicIndexing: uint32_t | boolean | Membuf;
    shaderStorageImageArrayDynamicIndexing: uint32_t | boolean | Membuf;
    shaderClipDistance: uint32_t | boolean | Membuf;
    shaderCullDistance: uint32_t | boolean | Membuf;
    shaderFloat64: uint32_t | boolean | Membuf;
    shaderInt64: uint32_t | boolean | Membuf;
    shaderInt16: uint32_t | boolean | Membuf;
    shaderResourceResidency: uint32_t | boolean | Membuf;
    shaderResourceMinLod: uint32_t | boolean | Membuf;
    sparseBinding: uint32_t | boolean | Membuf;
    sparseResidencyBuffer: uint32_t | boolean | Membuf;
    sparseResidencyImage2D: uint32_t | boolean | Membuf;
    sparseResidencyImage3D: uint32_t | boolean | Membuf;
    sparseResidency2Samples: uint32_t | boolean | Membuf;
    sparseResidency4Samples: uint32_t | boolean | Membuf;
    sparseResidency8Samples: uint32_t | boolean | Membuf;
    sparseResidency16Samples: uint32_t | boolean | Membuf;
    sparseResidencyAliased: uint32_t | boolean | Membuf;
    variableMultisampleRate: uint32_t | boolean | Membuf;
    inheritedQueries: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceSparsePropertiesInput {
    residencyStandard2DBlockShape: uint32_t | boolean | Membuf;
    residencyStandard2DMultisampleBlockShape: uint32_t | boolean | Membuf;
    residencyStandard3DBlockShape: uint32_t | boolean | Membuf;
    residencyAlignedMipSize: uint32_t | boolean | Membuf;
    residencyNonResidentStrict: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceLimitsInput {
    maxImageDimension1D: uint32_t | number | Membuf;
    maxImageDimension2D: uint32_t | number | Membuf;
    maxImageDimension3D: uint32_t | number | Membuf;
    maxImageDimensionCube: uint32_t | number | Membuf;
    maxImageArrayLayers: uint32_t | number | Membuf;
    maxTexelBufferElements: uint32_t | number | Membuf;
    maxUniformBufferRange: uint32_t | number | Membuf;
    maxStorageBufferRange: uint32_t | number | Membuf;
    maxPushConstantsSize: uint32_t | number | Membuf;
    maxMemoryAllocationCount: uint32_t | number | Membuf;
    maxSamplerAllocationCount: uint32_t | number | Membuf;
    bufferImageGranularity: uint64_t | number | Membuf;
    sparseAddressSpaceSize: uint64_t | number | Membuf;
    maxBoundDescriptorSets: uint32_t | number | Membuf;
    maxPerStageDescriptorSamplers: uint32_t | number | Membuf;
    maxPerStageDescriptorUniformBuffers: uint32_t | number | Membuf;
    maxPerStageDescriptorStorageBuffers: uint32_t | number | Membuf;
    maxPerStageDescriptorSampledImages: uint32_t | number | Membuf;
    maxPerStageDescriptorStorageImages: uint32_t | number | Membuf;
    maxPerStageDescriptorInputAttachments: uint32_t | number | Membuf;
    maxPerStageResources: uint32_t | number | Membuf;
    maxDescriptorSetSamplers: uint32_t | number | Membuf;
    maxDescriptorSetUniformBuffers: uint32_t | number | Membuf;
    maxDescriptorSetUniformBuffersDynamic: uint32_t | number | Membuf;
    maxDescriptorSetStorageBuffers: uint32_t | number | Membuf;
    maxDescriptorSetStorageBuffersDynamic: uint32_t | number | Membuf;
    maxDescriptorSetSampledImages: uint32_t | number | Membuf;
    maxDescriptorSetStorageImages: uint32_t | number | Membuf;
    maxDescriptorSetInputAttachments: uint32_t | number | Membuf;
    maxVertexInputAttributes: uint32_t | number | Membuf;
    maxVertexInputBindings: uint32_t | number | Membuf;
    maxVertexInputAttributeOffset: uint32_t | number | Membuf;
    maxVertexInputBindingStride: uint32_t | number | Membuf;
    maxVertexOutputComponents: uint32_t | number | Membuf;
    maxTessellationGenerationLevel: uint32_t | number | Membuf;
    maxTessellationPatchSize: uint32_t | number | Membuf;
    maxTessellationControlPerVertexInputComponents: uint32_t | number | Membuf;
    maxTessellationControlPerVertexOutputComponents: uint32_t | number | Membuf;
    maxTessellationControlPerPatchOutputComponents: uint32_t | number | Membuf;
    maxTessellationControlTotalOutputComponents: uint32_t | number | Membuf;
    maxTessellationEvaluationInputComponents: uint32_t | number | Membuf;
    maxTessellationEvaluationOutputComponents: uint32_t | number | Membuf;
    maxGeometryShaderInvocations: uint32_t | number | Membuf;
    maxGeometryInputComponents: uint32_t | number | Membuf;
    maxGeometryOutputComponents: uint32_t | number | Membuf;
    maxGeometryOutputVertices: uint32_t | number | Membuf;
    maxGeometryTotalOutputComponents: uint32_t | number | Membuf;
    maxFragmentInputComponents: uint32_t | number | Membuf;
    maxFragmentOutputAttachments: uint32_t | number | Membuf;
    maxFragmentDualSrcAttachments: uint32_t | number | Membuf;
    maxFragmentCombinedOutputResources: uint32_t | number | Membuf;
    maxComputeSharedMemorySize: uint32_t | number | Membuf;
    maxComputeWorkGroupCount: uint32_t[] | null | Membuf;
    maxComputeWorkGroupInvocations: uint32_t | number | Membuf;
    maxComputeWorkGroupSize: uint32_t[] | null | Membuf;
    subPixelPrecisionBits: uint32_t | number | Membuf;
    subTexelPrecisionBits: uint32_t | number | Membuf;
    mipmapPrecisionBits: uint32_t | number | Membuf;
    maxDrawIndexedIndexValue: uint32_t | number | Membuf;
    maxDrawIndirectCount: uint32_t | number | Membuf;
    maxSamplerLodBias: float | number | Membuf;
    maxSamplerAnisotropy: float | number | Membuf;
    maxViewports: uint32_t | number | Membuf;
    maxViewportDimensions: uint32_t[] | null | Membuf;
    viewportBoundsRange: float[] | null | Membuf;
    viewportSubPixelBits: uint32_t | number | Membuf;
    minMemoryMapAlignment: size_t | number | Membuf;
    minTexelBufferOffsetAlignment: uint64_t | number | Membuf;
    minUniformBufferOffsetAlignment: uint64_t | number | Membuf;
    minStorageBufferOffsetAlignment: uint64_t | number | Membuf;
    minTexelOffset: int32_t | number | Membuf;
    maxTexelOffset: uint32_t | number | Membuf;
    minTexelGatherOffset: int32_t | number | Membuf;
    maxTexelGatherOffset: uint32_t | number | Membuf;
    minInterpolationOffset: float | number | Membuf;
    maxInterpolationOffset: float | number | Membuf;
    subPixelInterpolationOffsetBits: uint32_t | number | Membuf;
    maxFramebufferWidth: uint32_t | number | Membuf;
    maxFramebufferHeight: uint32_t | number | Membuf;
    maxFramebufferLayers: uint32_t | number | Membuf;
    framebufferColorSampleCounts?: uint32_t | number | Membuf;
    framebufferDepthSampleCounts?: uint32_t | number | Membuf;
    framebufferStencilSampleCounts?: uint32_t | number | Membuf;
    framebufferNoAttachmentsSampleCounts?: uint32_t | number | Membuf;
    maxColorAttachments: uint32_t | number | Membuf;
    sampledImageColorSampleCounts?: uint32_t | number | Membuf;
    sampledImageIntegerSampleCounts?: uint32_t | number | Membuf;
    sampledImageDepthSampleCounts?: uint32_t | number | Membuf;
    sampledImageStencilSampleCounts?: uint32_t | number | Membuf;
    storageImageSampleCounts?: uint32_t | number | Membuf;
    maxSampleMaskWords: uint32_t | number | Membuf;
    timestampComputeAndGraphics: uint32_t | boolean | Membuf;
    timestampPeriod: float | number | Membuf;
    maxClipDistances: uint32_t | number | Membuf;
    maxCullDistances: uint32_t | number | Membuf;
    maxCombinedClipAndCullDistances: uint32_t | number | Membuf;
    discreteQueuePriorities: uint32_t | number | Membuf;
    pointSizeRange: float[] | null | Membuf;
    lineWidthRange: float[] | null | Membuf;
    pointSizeGranularity: float | number | Membuf;
    lineWidthGranularity: float | number | Membuf;
    strictLines: uint32_t | boolean | Membuf;
    standardSampleLocations: uint32_t | boolean | Membuf;
    optimalBufferCopyOffsetAlignment: uint64_t | number | Membuf;
    optimalBufferCopyRowPitchAlignment: uint64_t | number | Membuf;
    nonCoherentAtomSize: uint64_t | number | Membuf
}
export interface VkSemaphoreCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf
}
export interface VkQueryPoolCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: int32_t | number | Membuf;
    queryType: int32_t | number | Membuf;
    queryCount: uint32_t | number | Membuf;
    pipelineStatistics?: uint32_t | number | Membuf
}
export interface VkFramebufferCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    renderPass: ptr64_t | Membuf;
    attachmentCount?: uint32_t | number | Membuf;
    pAttachments: ptr64_t[] | null | Membuf;
    width: uint32_t | number | Membuf;
    height: uint32_t | number | Membuf;
    layers: uint32_t | number | Membuf
}
export interface VkDrawIndirectCommandInput {
    vertexCount: uint32_t | number | Membuf;
    instanceCount: uint32_t | number | Membuf;
    firstVertex: uint32_t | number | Membuf;
    firstInstance: uint32_t | number | Membuf
}
export interface VkDrawIndexedIndirectCommandInput {
    indexCount: uint32_t | number | Membuf;
    instanceCount: uint32_t | number | Membuf;
    firstIndex: uint32_t | number | Membuf;
    vertexOffset: int32_t | number | Membuf;
    firstInstance: uint32_t | number | Membuf
}
export interface VkDispatchIndirectCommandInput {
    x: uint32_t | number | Membuf;
    y: uint32_t | number | Membuf;
    z: uint32_t | number | Membuf
}
export interface VkMultiDrawInfoEXTInput {
    firstVertex: uint32_t | number | Membuf;
    vertexCount: uint32_t | number | Membuf
}
export interface VkMultiDrawIndexedInfoEXTInput {
    firstIndex: uint32_t | number | Membuf;
    indexCount: uint32_t | number | Membuf;
    vertexOffset: int32_t | number | Membuf
}
export interface VkSubmitInfoInput {
    pNext?: ptr64_t| null | Membuf;
    waitSemaphoreCount?: uint32_t | number | Membuf;
    pWaitSemaphores: ptr64_t[] | null | Membuf;
    pWaitDstStageMask: uint32_t[] | null | Membuf;
    commandBufferCount?: uint32_t | number | Membuf;
    pCommandBuffers: ptr64_t[] | null | Membuf;
    signalSemaphoreCount?: uint32_t | number | Membuf;
    pSignalSemaphores: ptr64_t[] | null | Membuf
}
export interface VkDisplayPropertiesKHRInput {
    display: ptr64_t | Membuf;
    displayName: string | Membuf;
    physicalDimensions: VkExtent2D[] | Membuf;
    physicalResolution: VkExtent2D[] | Membuf;
    supportedTransforms?: uint32_t | number | Membuf;
    planeReorderPossible: uint32_t | boolean | Membuf;
    persistentContent: uint32_t | boolean | Membuf
}
export interface VkDisplayPlanePropertiesKHRInput {
    currentDisplay: ptr64_t | Membuf;
    currentStackIndex: uint32_t | number | Membuf
}
export interface VkDisplayModeParametersKHRInput {
    visibleRegion: VkExtent2D[] | Membuf;
    refreshRate: uint32_t | number | Membuf
}
export interface VkDisplayModePropertiesKHRInput {
    displayMode: ptr64_t | Membuf;
    parameters: VkDisplayModeParametersKHR[] | Membuf
}
export interface VkDisplayModeCreateInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: int32_t | number | Membuf;
    parameters: VkDisplayModeParametersKHR[] | Membuf
}
export interface VkDisplayPlaneCapabilitiesKHRInput {
    supportedAlpha?: uint32_t | number | Membuf;
    minSrcPosition: VkOffset2D[] | Membuf;
    maxSrcPosition: VkOffset2D[] | Membuf;
    minSrcExtent: VkExtent2D[] | Membuf;
    maxSrcExtent: VkExtent2D[] | Membuf;
    minDstPosition: VkOffset2D[] | Membuf;
    maxDstPosition: VkOffset2D[] | Membuf;
    minDstExtent: VkExtent2D[] | Membuf;
    maxDstExtent: VkExtent2D[] | Membuf
}
export interface VkDisplaySurfaceCreateInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: int32_t | number | Membuf;
    displayMode: ptr64_t | Membuf;
    planeIndex: uint32_t | number | Membuf;
    planeStackIndex: uint32_t | number | Membuf;
    transform: uint32_t | number | Membuf;
    globalAlpha: float | number | Membuf;
    alphaMode: uint32_t | number | Membuf;
    imageExtent: VkExtent2D[] | Membuf
}
export interface VkDisplayPresentInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    srcRect: VkRect2D[] | Membuf;
    dstRect: VkRect2D[] | Membuf;
    persistent: uint32_t | boolean | Membuf
}
export interface VkSurfaceCapabilitiesKHRInput {
    minImageCount: uint32_t | number | Membuf;
    maxImageCount: uint32_t | number | Membuf;
    currentExtent: VkExtent2D[] | Membuf;
    minImageExtent: VkExtent2D[] | Membuf;
    maxImageExtent: VkExtent2D[] | Membuf;
    maxImageArrayLayers: uint32_t | number | Membuf;
    supportedTransforms: uint32_t | number | Membuf;
    currentTransform: uint32_t | number | Membuf;
    supportedCompositeAlpha: uint32_t | number | Membuf;
    supportedUsageFlags: uint32_t | number | Membuf
}
export interface VkSurfaceFormatKHRInput {
    format: int32_t | number | Membuf;
    colorSpace: int32_t | number | Membuf
}
export interface VkSwapchainCreateInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    surface: ptr64_t | Membuf;
    minImageCount: uint32_t | number | Membuf;
    imageFormat: int32_t | number | Membuf;
    imageColorSpace: int32_t | number | Membuf;
    imageExtent: VkExtent2D[] | Membuf;
    imageArrayLayers: uint32_t | number | Membuf;
    imageUsage: uint32_t | number | Membuf;
    imageSharingMode: int32_t | number | Membuf;
    queueFamilyIndexCount?: uint32_t | number | Membuf;
    pQueueFamilyIndices: uint32_t[] | null | Membuf;
    preTransform: uint32_t | number | Membuf;
    compositeAlpha: uint32_t | number | Membuf;
    presentMode: int32_t | number | Membuf;
    clipped: uint32_t | boolean | Membuf;
    oldSwapchain?: ptr64_t | Membuf
}
export interface VkPresentInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    waitSemaphoreCount?: uint32_t | number | Membuf;
    pWaitSemaphores: ptr64_t[] | null | Membuf;
    swapchainCount: uint32_t | number | Membuf;
    pSwapchains: ptr64_t[] | null | Membuf;
    pImageIndices: uint32_t[] | null | Membuf;
    pResults?: int32_t[] | null | Membuf
}
export interface VkValidationFlagsEXTInput {
    pNext?: ptr64_t| null | Membuf;
    disabledValidationCheckCount: uint32_t | number | Membuf;
    pDisabledValidationChecks: int32_t[] | null | Membuf
}
export interface VkValidationFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    enabledValidationFeatureCount?: uint32_t | number | Membuf;
    pEnabledValidationFeatures: int32_t[] | null | Membuf;
    disabledValidationFeatureCount?: uint32_t | number | Membuf;
    pDisabledValidationFeatures: int32_t[] | null | Membuf
}
export interface VkDevicePrivateDataCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    privateDataSlotRequestCount: uint32_t | number | Membuf
}
export interface VkDevicePrivateDataCreateInfoEXTInput {

}
export interface VkPrivateDataSlotCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags: uint32_t | number | Membuf
}
export interface VkPrivateDataSlotCreateInfoEXTInput {

}
export interface VkPhysicalDevicePrivateDataFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    privateData: uint32_t | boolean | Membuf
}
export interface VkPhysicalDevicePrivateDataFeaturesEXTInput {

}
export interface VkPhysicalDeviceMultiDrawPropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    maxMultiDrawCount: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceFeatures2Input {
    pNext?: ptr64_t| null | Membuf;
    features: VkPhysicalDeviceFeatures[] | Membuf
}
export interface VkPhysicalDeviceFeatures2KHRInput {

}
export interface VkPhysicalDeviceProperties2Input {
    pNext?: ptr64_t| null | Membuf;
    properties: VkPhysicalDeviceProperties[] | Membuf
}
export interface VkPhysicalDeviceProperties2KHRInput {

}
export interface VkFormatProperties2Input {
    pNext?: ptr64_t| null | Membuf;
    formatProperties: VkFormatProperties[] | Membuf
}
export interface VkFormatProperties2KHRInput {

}
export interface VkImageFormatProperties2Input {
    pNext?: ptr64_t| null | Membuf;
    imageFormatProperties: VkImageFormatProperties[] | Membuf
}
export interface VkImageFormatProperties2KHRInput {

}
export interface VkPhysicalDeviceImageFormatInfo2Input {
    pNext?: ptr64_t| null | Membuf;
    format: int32_t | number | Membuf;
    type: int32_t | number | Membuf;
    tiling: int32_t | number | Membuf;
    usage: uint32_t | number | Membuf;
    flags?: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceImageFormatInfo2KHRInput {

}
export interface VkQueueFamilyProperties2Input {
    pNext?: ptr64_t| null | Membuf;
    queueFamilyProperties: VkQueueFamilyProperties[] | Membuf
}
export interface VkQueueFamilyProperties2KHRInput {

}
export interface VkPhysicalDeviceMemoryProperties2Input {
    pNext?: ptr64_t| null | Membuf;
    memoryProperties: VkPhysicalDeviceMemoryProperties[] | Membuf
}
export interface VkPhysicalDeviceMemoryProperties2KHRInput {

}
export interface VkSparseImageFormatProperties2Input {
    pNext?: ptr64_t| null | Membuf;
    properties: VkSparseImageFormatProperties[] | Membuf
}
export interface VkSparseImageFormatProperties2KHRInput {

}
export interface VkPhysicalDeviceSparseImageFormatInfo2Input {
    pNext?: ptr64_t| null | Membuf;
    format: int32_t | number | Membuf;
    type: int32_t | number | Membuf;
    samples: uint32_t | number | Membuf;
    usage: uint32_t | number | Membuf;
    tiling: int32_t | number | Membuf
}
export interface VkPhysicalDeviceSparseImageFormatInfo2KHRInput {

}
export interface VkPhysicalDevicePushDescriptorPropertiesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    maxPushDescriptors: uint32_t | number | Membuf
}
export interface VkConformanceVersionInput {
    major: uint8_t | number | Membuf;
    minor: uint8_t | number | Membuf;
    subminor: uint8_t | number | Membuf;
    patch: uint8_t | number | Membuf
}
export interface VkConformanceVersionKHRInput {

}
export interface VkPhysicalDeviceDriverPropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    driverID: int32_t | number | Membuf;
    driverName: char[] | null | Membuf;
    driverInfo: char[] | null | Membuf;
    conformanceVersion: VkConformanceVersion[] | Membuf
}
export interface VkPhysicalDeviceDriverPropertiesKHRInput {

}
export interface VkPresentRegionsKHRInput {
    pNext?: ptr64_t| null | Membuf;
    swapchainCount: uint32_t | number | Membuf;
    pRegions?: VkPresentRegionKHR[] | null | Membuf
}
export interface VkPresentRegionKHRInput {
    rectangleCount?: uint32_t | number | Membuf;
    pRectangles?: VkRectLayerKHR[] | null | Membuf
}
export interface VkRectLayerKHRInput {
    offset: VkOffset2D[] | Membuf;
    extent: VkExtent2D[] | Membuf;
    layer: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceVariablePointersFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    variablePointersStorageBuffer: uint32_t | boolean | Membuf;
    variablePointers: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceVariablePointersFeaturesKHRInput {

}
export interface VkPhysicalDeviceVariablePointerFeaturesKHRInput {

}
export interface VkPhysicalDeviceVariablePointerFeaturesInput {

}
export interface VkExternalMemoryPropertiesInput {
    externalMemoryFeatures: uint32_t | number | Membuf;
    exportFromImportedHandleTypes?: uint32_t | number | Membuf;
    compatibleHandleTypes: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceExternalImageFormatInfoInput {
    pNext?: ptr64_t| null | Membuf;
    handleType?: uint32_t | number | Membuf
}
export interface VkExternalImageFormatPropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    externalMemoryProperties: VkExternalMemoryProperties[] | Membuf
}
export interface VkPhysicalDeviceExternalBufferInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    usage: uint32_t | number | Membuf;
    handleType: uint32_t | number | Membuf
}
export interface VkExternalBufferPropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    externalMemoryProperties: VkExternalMemoryProperties[] | Membuf
}
export interface VkPhysicalDeviceIDPropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    deviceUUID: uint8_t[] | null | Membuf;
    driverUUID: uint8_t[] | null | Membuf;
    deviceLUID: uint8_t[] | null | Membuf;
    deviceNodeMask: uint32_t | number | Membuf;
    deviceLUIDValid: uint32_t | boolean | Membuf
}
export interface VkExternalMemoryImageCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    handleTypes?: uint32_t | number | Membuf
}
export interface VkExternalMemoryBufferCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    handleTypes?: uint32_t | number | Membuf
}
export interface VkExportMemoryAllocateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    handleTypes?: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceExternalSemaphoreInfoInput {
    pNext?: ptr64_t| null | Membuf;
    handleType: uint32_t | number | Membuf
}
export interface VkExternalSemaphorePropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    exportFromImportedHandleTypes: uint32_t | number | Membuf;
    compatibleHandleTypes: uint32_t | number | Membuf;
    externalSemaphoreFeatures?: uint32_t | number | Membuf
}
export interface VkExportSemaphoreCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    handleTypes?: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceExternalFenceInfoInput {
    pNext?: ptr64_t| null | Membuf;
    handleType: uint32_t | number | Membuf
}
export interface VkExternalFencePropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    exportFromImportedHandleTypes: uint32_t | number | Membuf;
    compatibleHandleTypes: uint32_t | number | Membuf;
    externalFenceFeatures?: uint32_t | number | Membuf
}
export interface VkExportFenceCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    handleTypes?: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceMultiviewFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    multiview: uint32_t | boolean | Membuf;
    multiviewGeometryShader: uint32_t | boolean | Membuf;
    multiviewTessellationShader: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceMultiviewFeaturesKHRInput {

}
export interface VkPhysicalDeviceMultiviewPropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    maxMultiviewViewCount: uint32_t | number | Membuf;
    maxMultiviewInstanceIndex: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceMultiviewPropertiesKHRInput {

}
export interface VkRenderPassMultiviewCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    subpassCount?: uint32_t | number | Membuf;
    pViewMasks: uint32_t[] | null | Membuf;
    dependencyCount?: uint32_t | number | Membuf;
    pViewOffsets: int32_t[] | null | Membuf;
    correlationMaskCount?: uint32_t | number | Membuf;
    pCorrelationMasks: uint32_t[] | null | Membuf
}
export interface VkRenderPassMultiviewCreateInfoKHRInput {

}
export interface VkPhysicalDeviceGroupPropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    physicalDeviceCount: uint32_t | number | Membuf;
    physicalDevices: ptr64_t[] | null | Membuf;
    subsetAllocation: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceGroupPropertiesKHRInput {

}
export interface VkMemoryAllocateFlagsInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    deviceMask: uint32_t | number | Membuf
}
export interface VkMemoryAllocateFlagsInfoKHRInput {

}
export interface VkBindBufferMemoryInfoInput {
    pNext?: ptr64_t| null | Membuf;
    buffer: ptr64_t | Membuf;
    memory: ptr64_t | Membuf;
    memoryOffset: uint64_t | number | Membuf
}
export interface VkBindBufferMemoryInfoKHRInput {

}
export interface VkBindBufferMemoryDeviceGroupInfoInput {
    pNext?: ptr64_t| null | Membuf;
    deviceIndexCount?: uint32_t | number | Membuf;
    pDeviceIndices: uint32_t[] | null | Membuf
}
export interface VkBindBufferMemoryDeviceGroupInfoKHRInput {

}
export interface VkBindImageMemoryInfoInput {
    pNext?: ptr64_t| null | Membuf;
    image: ptr64_t | Membuf;
    memory: ptr64_t | Membuf;
    memoryOffset: uint64_t | number | Membuf
}
export interface VkBindImageMemoryInfoKHRInput {

}
export interface VkBindImageMemoryDeviceGroupInfoInput {
    pNext?: ptr64_t| null | Membuf;
    deviceIndexCount?: uint32_t | number | Membuf;
    pDeviceIndices: uint32_t[] | null | Membuf;
    splitInstanceBindRegionCount?: uint32_t | number | Membuf;
    pSplitInstanceBindRegions: VkRect2D[] | null | Membuf
}
export interface VkBindImageMemoryDeviceGroupInfoKHRInput {

}
export interface VkDeviceGroupRenderPassBeginInfoInput {
    pNext?: ptr64_t| null | Membuf;
    deviceMask: uint32_t | number | Membuf;
    deviceRenderAreaCount?: uint32_t | number | Membuf;
    pDeviceRenderAreas: VkRect2D[] | null | Membuf
}
export interface VkDeviceGroupRenderPassBeginInfoKHRInput {

}
export interface VkDeviceGroupCommandBufferBeginInfoInput {
    pNext?: ptr64_t| null | Membuf;
    deviceMask: uint32_t | number | Membuf
}
export interface VkDeviceGroupCommandBufferBeginInfoKHRInput {

}
export interface VkDeviceGroupSubmitInfoInput {
    pNext?: ptr64_t| null | Membuf;
    waitSemaphoreCount?: uint32_t | number | Membuf;
    pWaitSemaphoreDeviceIndices: uint32_t[] | null | Membuf;
    commandBufferCount?: uint32_t | number | Membuf;
    pCommandBufferDeviceMasks: uint32_t[] | null | Membuf;
    signalSemaphoreCount?: uint32_t | number | Membuf;
    pSignalSemaphoreDeviceIndices: uint32_t[] | null | Membuf
}
export interface VkDeviceGroupSubmitInfoKHRInput {

}
export interface VkDeviceGroupBindSparseInfoInput {
    pNext?: ptr64_t| null | Membuf;
    resourceDeviceIndex: uint32_t | number | Membuf;
    memoryDeviceIndex: uint32_t | number | Membuf
}
export interface VkDeviceGroupBindSparseInfoKHRInput {

}
export interface VkDeviceGroupPresentCapabilitiesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    presentMask: uint32_t[] | null | Membuf;
    modes: uint32_t | number | Membuf
}
export interface VkImageSwapchainCreateInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    swapchain?: ptr64_t | Membuf
}
export interface VkBindImageMemorySwapchainInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    swapchain: ptr64_t | Membuf;
    imageIndex: uint32_t | number | Membuf
}
export interface VkAcquireNextImageInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    swapchain: ptr64_t | Membuf;
    timeout: uint64_t | number | Membuf;
    semaphore?: ptr64_t | Membuf;
    fence?: ptr64_t | Membuf;
    deviceMask: uint32_t | number | Membuf
}
export interface VkDeviceGroupPresentInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    swapchainCount?: uint32_t | number | Membuf;
    pDeviceMasks: uint32_t[] | null | Membuf;
    mode: uint32_t | number | Membuf
}
export interface VkDeviceGroupDeviceCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    physicalDeviceCount?: uint32_t | number | Membuf;
    pPhysicalDevices: ptr64_t[] | null | Membuf
}
export interface VkDeviceGroupDeviceCreateInfoKHRInput {

}
export interface VkDeviceGroupSwapchainCreateInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    modes: uint32_t | number | Membuf
}
export interface VkDescriptorUpdateTemplateEntryInput {
    dstBinding: uint32_t | number | Membuf;
    dstArrayElement: uint32_t | number | Membuf;
    descriptorCount: uint32_t | number | Membuf;
    descriptorType: int32_t | number | Membuf;
    offset: size_t | number | Membuf;
    stride: size_t | number | Membuf
}
export interface VkDescriptorUpdateTemplateEntryKHRInput {

}
export interface VkDescriptorUpdateTemplateCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: int32_t | number | Membuf;
    descriptorUpdateEntryCount: uint32_t | number | Membuf;
    pDescriptorUpdateEntries: VkDescriptorUpdateTemplateEntry[] | null | Membuf;
    templateType: int32_t | number | Membuf;
    descriptorSetLayout: ptr64_t | Membuf;
    pipelineBindPoint: int32_t | number | Membuf;
    pipelineLayout: ptr64_t | Membuf;
    set: uint32_t | number | Membuf
}
export interface VkDescriptorUpdateTemplateCreateInfoKHRInput {

}
export interface VkXYColorEXTInput {
    x: float | number | Membuf;
    y: float | number | Membuf
}
export interface VkPhysicalDevicePresentIdFeaturesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    presentId: uint32_t | boolean | Membuf
}
export interface VkPresentIdKHRInput {
    pNext?: ptr64_t| null | Membuf;
    swapchainCount: uint32_t | number | Membuf;
    pPresentIds?: uint64_t[] | null | Membuf
}
export interface VkPhysicalDevicePresentWaitFeaturesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    presentWait: uint32_t | boolean | Membuf
}
export interface VkHdrMetadataEXTInput {
    pNext?: ptr64_t| null | Membuf;
    displayPrimaryRed: VkXYColorEXT[] | Membuf;
    displayPrimaryGreen: VkXYColorEXT[] | Membuf;
    displayPrimaryBlue: VkXYColorEXT[] | Membuf;
    whitePoint: VkXYColorEXT[] | Membuf;
    maxLuminance: float | number | Membuf;
    minLuminance: float | number | Membuf;
    maxContentLightLevel: float | number | Membuf;
    maxFrameAverageLightLevel: float | number | Membuf
}
export interface VkInputAttachmentAspectReferenceInput {
    subpass: uint32_t | number | Membuf;
    inputAttachmentIndex: uint32_t | number | Membuf;
    aspectMask: uint32_t | number | Membuf
}
export interface VkRenderPassInputAttachmentAspectCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    aspectReferenceCount: uint32_t | number | Membuf;
    pAspectReferences: VkInputAttachmentAspectReference[] | null | Membuf
}
export interface VkPhysicalDeviceSurfaceInfo2KHRInput {
    pNext?: ptr64_t| null | Membuf;
    surface?: ptr64_t | Membuf
}
export interface VkSurfaceCapabilities2KHRInput {
    pNext?: ptr64_t| null | Membuf;
    surfaceCapabilities: VkSurfaceCapabilitiesKHR[] | Membuf
}
export interface VkSurfaceFormat2KHRInput {
    pNext?: ptr64_t| null | Membuf;
    surfaceFormat: VkSurfaceFormatKHR[] | Membuf
}
export interface VkDisplayProperties2KHRInput {
    pNext?: ptr64_t| null | Membuf;
    displayProperties: VkDisplayPropertiesKHR[] | Membuf
}
export interface VkDisplayPlaneProperties2KHRInput {
    pNext?: ptr64_t| null | Membuf;
    displayPlaneProperties: VkDisplayPlanePropertiesKHR[] | Membuf
}
export interface VkDisplayModeProperties2KHRInput {
    pNext?: ptr64_t| null | Membuf;
    displayModeProperties: VkDisplayModePropertiesKHR[] | Membuf
}
export interface VkDisplayPlaneInfo2KHRInput {
    pNext?: ptr64_t| null | Membuf;
    mode: ptr64_t | Membuf;
    planeIndex: uint32_t | number | Membuf
}
export interface VkDisplayPlaneCapabilities2KHRInput {
    pNext?: ptr64_t| null | Membuf;
    capabilities: VkDisplayPlaneCapabilitiesKHR[] | Membuf
}
export interface VkSharedPresentSurfaceCapabilitiesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    sharedPresentSupportedUsageFlags?: uint32_t | number | Membuf
}
export interface VkPhysicalDevice16BitStorageFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    storageBuffer16BitAccess: uint32_t | boolean | Membuf;
    uniformAndStorageBuffer16BitAccess: uint32_t | boolean | Membuf;
    storagePushConstant16: uint32_t | boolean | Membuf;
    storageInputOutput16: uint32_t | boolean | Membuf
}
export interface VkPhysicalDevice16BitStorageFeaturesKHRInput {

}
export interface VkPhysicalDeviceSubgroupPropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    subgroupSize: uint32_t | number | Membuf;
    supportedStages: uint32_t | number | Membuf;
    supportedOperations: uint32_t | number | Membuf;
    quadOperationsInAllStages: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    shaderSubgroupExtendedTypes: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHRInput {

}
export interface VkBufferMemoryRequirementsInfo2Input {
    pNext?: ptr64_t| null | Membuf;
    buffer: ptr64_t | Membuf
}
export interface VkBufferMemoryRequirementsInfo2KHRInput {

}
export interface VkDeviceBufferMemoryRequirementsInput {
    pNext?: ptr64_t| null | Membuf;
    pCreateInfo: VkBufferCreateInfo| null | Membuf
}
export interface VkImageMemoryRequirementsInfo2Input {
    pNext?: ptr64_t| null | Membuf;
    image: ptr64_t | Membuf
}
export interface VkImageMemoryRequirementsInfo2KHRInput {

}
export interface VkImageSparseMemoryRequirementsInfo2Input {
    pNext?: ptr64_t| null | Membuf;
    image: ptr64_t | Membuf
}
export interface VkImageSparseMemoryRequirementsInfo2KHRInput {

}
export interface VkDeviceImageMemoryRequirementsInput {
    pNext?: ptr64_t| null | Membuf;
    pCreateInfo: VkImageCreateInfo| null | Membuf;
    planeAspect?: uint32_t | number | Membuf
}
export interface VkMemoryRequirements2Input {
    pNext?: ptr64_t| null | Membuf;
    memoryRequirements: VkMemoryRequirements[] | Membuf
}
export interface VkSparseImageMemoryRequirements2Input {
    pNext?: ptr64_t| null | Membuf;
    memoryRequirements: VkSparseImageMemoryRequirements[] | Membuf
}
export interface VkSparseImageMemoryRequirements2KHRInput {

}
export interface VkPhysicalDevicePointClippingPropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    pointClippingBehavior: int32_t | number | Membuf
}
export interface VkMemoryDedicatedRequirementsInput {
    pNext?: ptr64_t| null | Membuf;
    prefersDedicatedAllocation: uint32_t | boolean | Membuf;
    requiresDedicatedAllocation: uint32_t | boolean | Membuf
}
export interface VkMemoryDedicatedRequirementsKHRInput {

}
export interface VkMemoryDedicatedAllocateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    image?: ptr64_t | Membuf;
    buffer?: ptr64_t | Membuf
}
export interface VkMemoryDedicatedAllocateInfoKHRInput {

}
export interface VkImageViewUsageCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    usage: uint32_t | number | Membuf
}
export interface VkPipelineTessellationDomainOriginStateCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    domainOrigin: int32_t | number | Membuf
}
export interface VkSamplerYcbcrConversionInfoInput {
    pNext?: ptr64_t| null | Membuf;
    conversion: ptr64_t | Membuf
}
export interface VkSamplerYcbcrConversionInfoKHRInput {

}
export interface VkSamplerYcbcrConversionCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    format: int32_t | number | Membuf;
    ycbcrModel: int32_t | number | Membuf;
    ycbcrRange: int32_t | number | Membuf;
    components: VkComponentMapping[] | Membuf;
    xChromaOffset: int32_t | number | Membuf;
    yChromaOffset: int32_t | number | Membuf;
    chromaFilter: int32_t | number | Membuf;
    forceExplicitReconstruction: uint32_t | boolean | Membuf
}
export interface VkSamplerYcbcrConversionCreateInfoKHRInput {

}
export interface VkBindImagePlaneMemoryInfoInput {
    pNext?: ptr64_t| null | Membuf;
    planeAspect: uint32_t | number | Membuf
}
export interface VkBindImagePlaneMemoryInfoKHRInput {

}
export interface VkImagePlaneMemoryRequirementsInfoInput {
    pNext?: ptr64_t| null | Membuf;
    planeAspect: uint32_t | number | Membuf
}
export interface VkImagePlaneMemoryRequirementsInfoKHRInput {

}
export interface VkPhysicalDeviceSamplerYcbcrConversionFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    samplerYcbcrConversion: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHRInput {

}
export interface VkSamplerYcbcrConversionImageFormatPropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    combinedImageSamplerDescriptorCount: uint32_t | number | Membuf
}
export interface VkSamplerYcbcrConversionImageFormatPropertiesKHRInput {

}
export interface VkProtectedSubmitInfoInput {
    pNext?: ptr64_t| null | Membuf;
    protectedSubmit: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceProtectedMemoryFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    protectedMemory: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceProtectedMemoryPropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    protectedNoFault: uint32_t | boolean | Membuf
}
export interface VkDeviceQueueInfo2Input {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    queueFamilyIndex: uint32_t | number | Membuf;
    queueIndex: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceSamplerFilterMinmaxPropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    filterMinmaxSingleComponentFormats: uint32_t | boolean | Membuf;
    filterMinmaxImageComponentMapping: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXTInput {

}
export interface VkSampleLocationEXTInput {
    x: float | number | Membuf;
    y: float | number | Membuf
}
export interface VkSampleLocationsInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    sampleLocationsPerPixel: uint32_t | number | Membuf;
    sampleLocationGridSize: VkExtent2D[] | Membuf;
    sampleLocationsCount?: uint32_t | number | Membuf;
    pSampleLocations: VkSampleLocationEXT[] | null | Membuf
}
export interface VkAttachmentSampleLocationsEXTInput {
    attachmentIndex: uint32_t | number | Membuf;
    sampleLocationsInfo: VkSampleLocationsInfoEXT[] | Membuf
}
export interface VkSubpassSampleLocationsEXTInput {
    subpassIndex: uint32_t | number | Membuf;
    sampleLocationsInfo: VkSampleLocationsInfoEXT[] | Membuf
}
export interface VkRenderPassSampleLocationsBeginInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    attachmentInitialSampleLocationsCount?: uint32_t | number | Membuf;
    pAttachmentInitialSampleLocations: VkAttachmentSampleLocationsEXT[] | null | Membuf;
    postSubpassSampleLocationsCount?: uint32_t | number | Membuf;
    pPostSubpassSampleLocations: VkSubpassSampleLocationsEXT[] | null | Membuf
}
export interface VkPipelineSampleLocationsStateCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    sampleLocationsEnable: uint32_t | boolean | Membuf;
    sampleLocationsInfo: VkSampleLocationsInfoEXT[] | Membuf
}
export interface VkPhysicalDeviceSampleLocationsPropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    sampleLocationSampleCounts: uint32_t | number | Membuf;
    maxSampleLocationGridSize: VkExtent2D[] | Membuf;
    sampleLocationCoordinateRange: float[] | null | Membuf;
    sampleLocationSubPixelBits: uint32_t | number | Membuf;
    variableSampleLocations: uint32_t | boolean | Membuf
}
export interface VkMultisamplePropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    maxSampleLocationGridSize: VkExtent2D[] | Membuf
}
export interface VkSamplerReductionModeCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    reductionMode: int32_t | number | Membuf
}
export interface VkSamplerReductionModeCreateInfoEXTInput {

}
export interface VkPhysicalDeviceMultiDrawFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    multiDraw: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceInlineUniformBlockFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    inlineUniformBlock: uint32_t | boolean | Membuf;
    descriptorBindingInlineUniformBlockUpdateAfterBind: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceInlineUniformBlockFeaturesEXTInput {

}
export interface VkPhysicalDeviceInlineUniformBlockPropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    maxInlineUniformBlockSize: uint32_t | number | Membuf;
    maxPerStageDescriptorInlineUniformBlocks: uint32_t | number | Membuf;
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: uint32_t | number | Membuf;
    maxDescriptorSetInlineUniformBlocks: uint32_t | number | Membuf;
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceInlineUniformBlockPropertiesEXTInput {

}
export interface VkWriteDescriptorSetInlineUniformBlockInput {
    pNext?: ptr64_t| null | Membuf;
    dataSize: uint32_t | number | Membuf;
    pData: ptr64_t[] | null | Membuf
}
export interface VkWriteDescriptorSetInlineUniformBlockEXTInput {

}
export interface VkDescriptorPoolInlineUniformBlockCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    maxInlineUniformBlockBindings: uint32_t | number | Membuf
}
export interface VkDescriptorPoolInlineUniformBlockCreateInfoEXTInput {

}
export interface VkImageFormatListCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    viewFormatCount?: uint32_t | number | Membuf;
    pViewFormats: int32_t[] | null | Membuf
}
export interface VkImageFormatListCreateInfoKHRInput {

}
export interface VkValidationCacheCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: int32_t | number | Membuf;
    initialDataSize?: size_t | number | Membuf;
    pInitialData: ptr64_t[] | null | Membuf
}
export interface VkShaderModuleValidationCacheCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    validationCache: ptr64_t | Membuf
}
export interface VkPhysicalDeviceMaintenance3PropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    maxPerSetDescriptors: uint32_t | number | Membuf;
    maxMemoryAllocationSize: uint64_t | number | Membuf
}
export interface VkPhysicalDeviceMaintenance4FeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    maintenance4: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceMaintenance4PropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    maxBufferSize: uint64_t | number | Membuf
}
export interface VkDescriptorSetLayoutSupportInput {
    pNext?: ptr64_t| null | Membuf;
    supported: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceShaderDrawParametersFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    shaderDrawParameters: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceShaderDrawParameterFeaturesInput {

}
export interface VkPhysicalDeviceShaderFloat16Int8FeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    shaderFloat16: uint32_t | boolean | Membuf;
    shaderInt8: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceShaderFloat16Int8FeaturesKHRInput {

}
export interface VkPhysicalDeviceFloat16Int8FeaturesKHRInput {

}
export interface VkPhysicalDeviceFloatControlsPropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    denormBehaviorIndependence: int32_t | number | Membuf;
    roundingModeIndependence: int32_t | number | Membuf;
    shaderSignedZeroInfNanPreserveFloat16: uint32_t | boolean | Membuf;
    shaderSignedZeroInfNanPreserveFloat32: uint32_t | boolean | Membuf;
    shaderSignedZeroInfNanPreserveFloat64: uint32_t | boolean | Membuf;
    shaderDenormPreserveFloat16: uint32_t | boolean | Membuf;
    shaderDenormPreserveFloat32: uint32_t | boolean | Membuf;
    shaderDenormPreserveFloat64: uint32_t | boolean | Membuf;
    shaderDenormFlushToZeroFloat16: uint32_t | boolean | Membuf;
    shaderDenormFlushToZeroFloat32: uint32_t | boolean | Membuf;
    shaderDenormFlushToZeroFloat64: uint32_t | boolean | Membuf;
    shaderRoundingModeRTEFloat16: uint32_t | boolean | Membuf;
    shaderRoundingModeRTEFloat32: uint32_t | boolean | Membuf;
    shaderRoundingModeRTEFloat64: uint32_t | boolean | Membuf;
    shaderRoundingModeRTZFloat16: uint32_t | boolean | Membuf;
    shaderRoundingModeRTZFloat32: uint32_t | boolean | Membuf;
    shaderRoundingModeRTZFloat64: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceFloatControlsPropertiesKHRInput {

}
export interface VkPhysicalDeviceHostQueryResetFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    hostQueryReset: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceHostQueryResetFeaturesEXTInput {

}
export interface VkDeviceQueueGlobalPriorityCreateInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    globalPriority: int32_t | number | Membuf
}
export interface VkDeviceQueueGlobalPriorityCreateInfoEXTInput {

}
export interface VkPhysicalDeviceGlobalPriorityQueryFeaturesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    globalPriorityQuery: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceGlobalPriorityQueryFeaturesEXTInput {

}
export interface VkQueueFamilyGlobalPriorityPropertiesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    priorityCount: uint32_t | number | Membuf;
    priorities: int32_t[] | null | Membuf
}
export interface VkQueueFamilyGlobalPriorityPropertiesEXTInput {

}
export interface VkImportMemoryHostPointerInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    handleType: uint32_t | number | Membuf;
    pHostPointer: ptr64_t| null | Membuf
}
export interface VkMemoryHostPointerPropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    memoryTypeBits: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceExternalMemoryHostPropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    minImportedHostPointerAlignment: uint64_t | number | Membuf
}
export interface VkPhysicalDeviceDescriptorIndexingFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    shaderInputAttachmentArrayDynamicIndexing: uint32_t | boolean | Membuf;
    shaderUniformTexelBufferArrayDynamicIndexing: uint32_t | boolean | Membuf;
    shaderStorageTexelBufferArrayDynamicIndexing: uint32_t | boolean | Membuf;
    shaderUniformBufferArrayNonUniformIndexing: uint32_t | boolean | Membuf;
    shaderSampledImageArrayNonUniformIndexing: uint32_t | boolean | Membuf;
    shaderStorageBufferArrayNonUniformIndexing: uint32_t | boolean | Membuf;
    shaderStorageImageArrayNonUniformIndexing: uint32_t | boolean | Membuf;
    shaderInputAttachmentArrayNonUniformIndexing: uint32_t | boolean | Membuf;
    shaderUniformTexelBufferArrayNonUniformIndexing: uint32_t | boolean | Membuf;
    shaderStorageTexelBufferArrayNonUniformIndexing: uint32_t | boolean | Membuf;
    descriptorBindingUniformBufferUpdateAfterBind: uint32_t | boolean | Membuf;
    descriptorBindingSampledImageUpdateAfterBind: uint32_t | boolean | Membuf;
    descriptorBindingStorageImageUpdateAfterBind: uint32_t | boolean | Membuf;
    descriptorBindingStorageBufferUpdateAfterBind: uint32_t | boolean | Membuf;
    descriptorBindingUniformTexelBufferUpdateAfterBind: uint32_t | boolean | Membuf;
    descriptorBindingStorageTexelBufferUpdateAfterBind: uint32_t | boolean | Membuf;
    descriptorBindingUpdateUnusedWhilePending: uint32_t | boolean | Membuf;
    descriptorBindingPartiallyBound: uint32_t | boolean | Membuf;
    descriptorBindingVariableDescriptorCount: uint32_t | boolean | Membuf;
    runtimeDescriptorArray: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceDescriptorIndexingPropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    maxUpdateAfterBindDescriptorsInAllPools: uint32_t | number | Membuf;
    shaderUniformBufferArrayNonUniformIndexingNative: uint32_t | boolean | Membuf;
    shaderSampledImageArrayNonUniformIndexingNative: uint32_t | boolean | Membuf;
    shaderStorageBufferArrayNonUniformIndexingNative: uint32_t | boolean | Membuf;
    shaderStorageImageArrayNonUniformIndexingNative: uint32_t | boolean | Membuf;
    shaderInputAttachmentArrayNonUniformIndexingNative: uint32_t | boolean | Membuf;
    robustBufferAccessUpdateAfterBind: uint32_t | boolean | Membuf;
    quadDivergentImplicitLod: uint32_t | boolean | Membuf;
    maxPerStageDescriptorUpdateAfterBindSamplers: uint32_t | number | Membuf;
    maxPerStageDescriptorUpdateAfterBindUniformBuffers: uint32_t | number | Membuf;
    maxPerStageDescriptorUpdateAfterBindStorageBuffers: uint32_t | number | Membuf;
    maxPerStageDescriptorUpdateAfterBindSampledImages: uint32_t | number | Membuf;
    maxPerStageDescriptorUpdateAfterBindStorageImages: uint32_t | number | Membuf;
    maxPerStageDescriptorUpdateAfterBindInputAttachments: uint32_t | number | Membuf;
    maxPerStageUpdateAfterBindResources: uint32_t | number | Membuf;
    maxDescriptorSetUpdateAfterBindSamplers: uint32_t | number | Membuf;
    maxDescriptorSetUpdateAfterBindUniformBuffers: uint32_t | number | Membuf;
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: uint32_t | number | Membuf;
    maxDescriptorSetUpdateAfterBindStorageBuffers: uint32_t | number | Membuf;
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: uint32_t | number | Membuf;
    maxDescriptorSetUpdateAfterBindSampledImages: uint32_t | number | Membuf;
    maxDescriptorSetUpdateAfterBindStorageImages: uint32_t | number | Membuf;
    maxDescriptorSetUpdateAfterBindInputAttachments: uint32_t | number | Membuf
}
export interface VkDescriptorSetLayoutBindingFlagsCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    bindingCount?: uint32_t | number | Membuf;
    pBindingFlags: uint32_t[] | null | Membuf
}
export interface VkDescriptorSetVariableDescriptorCountAllocateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    descriptorSetCount?: uint32_t | number | Membuf;
    pDescriptorCounts: uint32_t[] | null | Membuf
}
export interface VkDescriptorSetVariableDescriptorCountLayoutSupportInput {
    pNext?: ptr64_t| null | Membuf;
    maxVariableDescriptorCount: uint32_t | number | Membuf
}
export interface VkAttachmentDescription2Input {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    format: int32_t | number | Membuf;
    samples: uint32_t | number | Membuf;
    loadOp: int32_t | number | Membuf;
    storeOp: int32_t | number | Membuf;
    stencilLoadOp: int32_t | number | Membuf;
    stencilStoreOp: int32_t | number | Membuf;
    initialLayout: int32_t | number | Membuf;
    finalLayout: int32_t | number | Membuf
}
export interface VkAttachmentDescription2KHRInput {

}
export interface VkAttachmentReference2Input {
    pNext?: ptr64_t| null | Membuf;
    attachment: uint32_t | number | Membuf;
    layout: int32_t | number | Membuf;
    aspectMask: uint32_t | number | Membuf
}
export interface VkAttachmentReference2KHRInput {

}
export interface VkSubpassDescription2Input {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    pipelineBindPoint: int32_t | number | Membuf;
    viewMask: uint32_t | number | Membuf;
    inputAttachmentCount?: uint32_t | number | Membuf;
    pInputAttachments: VkAttachmentReference2[] | null | Membuf;
    colorAttachmentCount?: uint32_t | number | Membuf;
    pColorAttachments: VkAttachmentReference2[] | null | Membuf;
    pResolveAttachments?: VkAttachmentReference2[] | null | Membuf;
    pDepthStencilAttachment?: VkAttachmentReference2| null | Membuf;
    preserveAttachmentCount?: uint32_t | number | Membuf;
    pPreserveAttachments: uint32_t[] | null | Membuf
}
export interface VkSubpassDescription2KHRInput {

}
export interface VkSubpassDependency2Input {
    pNext?: ptr64_t| null | Membuf;
    srcSubpass: uint32_t | number | Membuf;
    dstSubpass: uint32_t | number | Membuf;
    srcStageMask?: uint32_t | number | Membuf;
    dstStageMask?: uint32_t | number | Membuf;
    srcAccessMask?: uint32_t | number | Membuf;
    dstAccessMask?: uint32_t | number | Membuf;
    dependencyFlags?: uint32_t | number | Membuf;
    viewOffset: int32_t | number | Membuf
}
export interface VkSubpassDependency2KHRInput {

}
export interface VkRenderPassCreateInfo2Input {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    attachmentCount?: uint32_t | number | Membuf;
    pAttachments: VkAttachmentDescription2[] | null | Membuf;
    subpassCount: uint32_t | number | Membuf;
    pSubpasses: VkSubpassDescription2[] | null | Membuf;
    dependencyCount?: uint32_t | number | Membuf;
    pDependencies: VkSubpassDependency2[] | null | Membuf;
    correlatedViewMaskCount?: uint32_t | number | Membuf;
    pCorrelatedViewMasks: uint32_t[] | null | Membuf
}
export interface VkRenderPassCreateInfo2KHRInput {

}
export interface VkSubpassBeginInfoInput {
    pNext?: ptr64_t| null | Membuf;
    contents: int32_t | number | Membuf
}
export interface VkSubpassBeginInfoKHRInput {

}
export interface VkSubpassEndInfoInput {
    pNext?: ptr64_t| null | Membuf
}
export interface VkSubpassEndInfoKHRInput {

}
export interface VkPhysicalDeviceTimelineSemaphoreFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    timelineSemaphore: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceTimelineSemaphoreFeaturesKHRInput {

}
export interface VkPhysicalDeviceTimelineSemaphorePropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    maxTimelineSemaphoreValueDifference: uint64_t | number | Membuf
}
export interface VkPhysicalDeviceTimelineSemaphorePropertiesKHRInput {

}
export interface VkSemaphoreTypeCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    semaphoreType: int32_t | number | Membuf;
    initialValue: uint64_t | number | Membuf
}
export interface VkSemaphoreTypeCreateInfoKHRInput {

}
export interface VkTimelineSemaphoreSubmitInfoInput {
    pNext?: ptr64_t| null | Membuf;
    waitSemaphoreValueCount?: uint32_t | number | Membuf;
    pWaitSemaphoreValues?: uint64_t[] | null | Membuf;
    signalSemaphoreValueCount?: uint32_t | number | Membuf;
    pSignalSemaphoreValues?: uint64_t[] | null | Membuf
}
export interface VkTimelineSemaphoreSubmitInfoKHRInput {

}
export interface VkSemaphoreWaitInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    semaphoreCount: uint32_t | number | Membuf;
    pSemaphores: ptr64_t[] | null | Membuf;
    pValues: uint64_t[] | null | Membuf
}
export interface VkSemaphoreWaitInfoKHRInput {

}
export interface VkSemaphoreSignalInfoInput {
    pNext?: ptr64_t| null | Membuf;
    semaphore: ptr64_t | Membuf;
    value: uint64_t | number | Membuf
}
export interface VkSemaphoreSignalInfoKHRInput {

}
export interface VkVertexInputBindingDivisorDescriptionEXTInput {
    binding: uint32_t | number | Membuf;
    divisor: uint32_t | number | Membuf
}
export interface VkPipelineVertexInputDivisorStateCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    vertexBindingDivisorCount: uint32_t | number | Membuf;
    pVertexBindingDivisors: VkVertexInputBindingDivisorDescriptionEXT[] | null | Membuf
}
export interface VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    maxVertexAttribDivisor: uint32_t | number | Membuf
}
export interface VkPhysicalDevicePCIBusInfoPropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    pciDomain: uint32_t | number | Membuf;
    pciBus: uint32_t | number | Membuf;
    pciDevice: uint32_t | number | Membuf;
    pciFunction: uint32_t | number | Membuf
}
export interface VkPhysicalDevice8BitStorageFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    storageBuffer8BitAccess: uint32_t | boolean | Membuf;
    uniformAndStorageBuffer8BitAccess: uint32_t | boolean | Membuf;
    storagePushConstant8: uint32_t | boolean | Membuf
}
export interface VkPhysicalDevice8BitStorageFeaturesKHRInput {

}
export interface VkPhysicalDeviceVulkanMemoryModelFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    vulkanMemoryModel: uint32_t | boolean | Membuf;
    vulkanMemoryModelDeviceScope: uint32_t | boolean | Membuf;
    vulkanMemoryModelAvailabilityVisibilityChains: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceVulkanMemoryModelFeaturesKHRInput {

}
export interface VkPhysicalDeviceShaderAtomicInt64FeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    shaderBufferInt64Atomics: uint32_t | boolean | Membuf;
    shaderSharedInt64Atomics: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceShaderAtomicInt64FeaturesKHRInput {

}
export interface VkPhysicalDeviceShaderAtomicFloatFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    shaderBufferFloat32Atomics: uint32_t | boolean | Membuf;
    shaderBufferFloat32AtomicAdd: uint32_t | boolean | Membuf;
    shaderBufferFloat64Atomics: uint32_t | boolean | Membuf;
    shaderBufferFloat64AtomicAdd: uint32_t | boolean | Membuf;
    shaderSharedFloat32Atomics: uint32_t | boolean | Membuf;
    shaderSharedFloat32AtomicAdd: uint32_t | boolean | Membuf;
    shaderSharedFloat64Atomics: uint32_t | boolean | Membuf;
    shaderSharedFloat64AtomicAdd: uint32_t | boolean | Membuf;
    shaderImageFloat32Atomics: uint32_t | boolean | Membuf;
    shaderImageFloat32AtomicAdd: uint32_t | boolean | Membuf;
    sparseImageFloat32Atomics: uint32_t | boolean | Membuf;
    sparseImageFloat32AtomicAdd: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceShaderAtomicFloat2FeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    shaderBufferFloat16Atomics: uint32_t | boolean | Membuf;
    shaderBufferFloat16AtomicAdd: uint32_t | boolean | Membuf;
    shaderBufferFloat16AtomicMinMax: uint32_t | boolean | Membuf;
    shaderBufferFloat32AtomicMinMax: uint32_t | boolean | Membuf;
    shaderBufferFloat64AtomicMinMax: uint32_t | boolean | Membuf;
    shaderSharedFloat16Atomics: uint32_t | boolean | Membuf;
    shaderSharedFloat16AtomicAdd: uint32_t | boolean | Membuf;
    shaderSharedFloat16AtomicMinMax: uint32_t | boolean | Membuf;
    shaderSharedFloat32AtomicMinMax: uint32_t | boolean | Membuf;
    shaderSharedFloat64AtomicMinMax: uint32_t | boolean | Membuf;
    shaderImageFloat32AtomicMinMax: uint32_t | boolean | Membuf;
    sparseImageFloat32AtomicMinMax: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    vertexAttributeInstanceRateDivisor: uint32_t | boolean | Membuf;
    vertexAttributeInstanceRateZeroDivisor: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceDepthStencilResolvePropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    supportedDepthResolveModes: uint32_t | number | Membuf;
    supportedStencilResolveModes: uint32_t | number | Membuf;
    independentResolveNone: uint32_t | boolean | Membuf;
    independentResolve: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceDepthStencilResolvePropertiesKHRInput {

}
export interface VkSubpassDescriptionDepthStencilResolveInput {
    pNext?: ptr64_t| null | Membuf;
    depthResolveMode: uint32_t | number | Membuf;
    stencilResolveMode: uint32_t | number | Membuf;
    pDepthStencilResolveAttachment?: VkAttachmentReference2| null | Membuf
}
export interface VkSubpassDescriptionDepthStencilResolveKHRInput {

}
export interface VkPhysicalDeviceTransformFeedbackFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    transformFeedback: uint32_t | boolean | Membuf;
    geometryStreams: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceTransformFeedbackPropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    maxTransformFeedbackStreams: uint32_t | number | Membuf;
    maxTransformFeedbackBuffers: uint32_t | number | Membuf;
    maxTransformFeedbackBufferSize: uint64_t | number | Membuf;
    maxTransformFeedbackStreamDataSize: uint32_t | number | Membuf;
    maxTransformFeedbackBufferDataSize: uint32_t | number | Membuf;
    maxTransformFeedbackBufferDataStride: uint32_t | number | Membuf;
    transformFeedbackQueries: uint32_t | boolean | Membuf;
    transformFeedbackStreamsLinesTriangles: uint32_t | boolean | Membuf;
    transformFeedbackRasterizationStreamSelect: uint32_t | boolean | Membuf;
    transformFeedbackDraw: uint32_t | boolean | Membuf
}
export interface VkPipelineRasterizationStateStreamCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: int32_t | number | Membuf;
    rasterizationStream: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceMeshShaderFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    taskShader: uint32_t | boolean | Membuf;
    meshShader: uint32_t | boolean | Membuf;
    multiviewMeshShader: uint32_t | boolean | Membuf;
    primitiveFragmentShadingRateMeshShader: uint32_t | boolean | Membuf;
    meshShaderQueries: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceMeshShaderPropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    maxTaskWorkGroupTotalCount: uint32_t | number | Membuf;
    maxTaskWorkGroupCount: uint32_t[] | null | Membuf;
    maxTaskWorkGroupInvocations: uint32_t | number | Membuf;
    maxTaskWorkGroupSize: uint32_t[] | null | Membuf;
    maxTaskPayloadSize: uint32_t | number | Membuf;
    maxTaskSharedMemorySize: uint32_t | number | Membuf;
    maxTaskPayloadAndSharedMemorySize: uint32_t | number | Membuf;
    maxMeshWorkGroupTotalCount: uint32_t | number | Membuf;
    maxMeshWorkGroupCount: uint32_t[] | null | Membuf;
    maxMeshWorkGroupInvocations: uint32_t | number | Membuf;
    maxMeshWorkGroupSize: uint32_t[] | null | Membuf;
    maxMeshSharedMemorySize: uint32_t | number | Membuf;
    maxMeshPayloadAndSharedMemorySize: uint32_t | number | Membuf;
    maxMeshOutputMemorySize: uint32_t | number | Membuf;
    maxMeshPayloadAndOutputMemorySize: uint32_t | number | Membuf;
    maxMeshOutputComponents: uint32_t | number | Membuf;
    maxMeshOutputVertices: uint32_t | number | Membuf;
    maxMeshOutputPrimitives: uint32_t | number | Membuf;
    maxMeshOutputLayers: uint32_t | number | Membuf;
    maxMeshMultiviewViewCount: uint32_t | number | Membuf;
    meshOutputPerVertexGranularity: uint32_t | number | Membuf;
    meshOutputPerPrimitiveGranularity: uint32_t | number | Membuf;
    maxPreferredTaskWorkGroupInvocations: uint32_t | number | Membuf;
    maxPreferredMeshWorkGroupInvocations: uint32_t | number | Membuf;
    prefersLocalInvocationVertexOutput: uint32_t | boolean | Membuf;
    prefersLocalInvocationPrimitiveOutput: uint32_t | boolean | Membuf;
    prefersCompactVertexOutput: uint32_t | boolean | Membuf;
    prefersCompactPrimitiveOutput: uint32_t | boolean | Membuf
}
export interface VkDrawMeshTasksIndirectCommandEXTInput {
    groupCountX: uint32_t | number | Membuf;
    groupCountY: uint32_t | number | Membuf;
    groupCountZ: uint32_t | number | Membuf
}
export interface VkRayTracingShaderGroupCreateInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    type: int32_t | number | Membuf;
    generalShader: uint32_t | number | Membuf;
    closestHitShader: uint32_t | number | Membuf;
    anyHitShader: uint32_t | number | Membuf;
    intersectionShader: uint32_t | number | Membuf;
    pShaderGroupCaptureReplayHandle?: ptr64_t| null | Membuf
}
export interface VkRayTracingPipelineCreateInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    stageCount?: uint32_t | number | Membuf;
    pStages: VkPipelineShaderStageCreateInfo[] | null | Membuf;
    groupCount?: uint32_t | number | Membuf;
    pGroups: VkRayTracingShaderGroupCreateInfoKHR[] | null | Membuf;
    maxPipelineRayRecursionDepth: uint32_t | number | Membuf;
    pLibraryInfo?: VkPipelineLibraryCreateInfoKHR| null | Membuf;
    pLibraryInterface?: VkRayTracingPipelineInterfaceCreateInfoKHR| null | Membuf;
    pDynamicState?: VkPipelineDynamicStateCreateInfo| null | Membuf;
    layout: ptr64_t | Membuf;
    basePipelineHandle?: ptr64_t | Membuf;
    basePipelineIndex: int32_t | number | Membuf
}
export interface VkPhysicalDeviceRayTracingPipelineFeaturesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    rayTracingPipeline: uint32_t | boolean | Membuf;
    rayTracingPipelineShaderGroupHandleCaptureReplay: uint32_t | boolean | Membuf;
    rayTracingPipelineShaderGroupHandleCaptureReplayMixed: uint32_t | boolean | Membuf;
    rayTracingPipelineTraceRaysIndirect: uint32_t | boolean | Membuf;
    rayTraversalPrimitiveCulling: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceRayQueryFeaturesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    rayQuery: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceRayTracingPipelinePropertiesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    shaderGroupHandleSize: uint32_t | number | Membuf;
    maxRayRecursionDepth: uint32_t | number | Membuf;
    maxShaderGroupStride: uint32_t | number | Membuf;
    shaderGroupBaseAlignment: uint32_t | number | Membuf;
    shaderGroupHandleCaptureReplaySize: uint32_t | number | Membuf;
    maxRayDispatchInvocationCount: uint32_t | number | Membuf;
    shaderGroupHandleAlignment: uint32_t | number | Membuf;
    maxRayHitAttributeSize: uint32_t | number | Membuf
}
export interface VkStridedDeviceAddressRegionKHRInput {
    deviceAddress?: ptr64_t | Membuf;
    stride: uint64_t | number | Membuf;
    size: uint64_t | number | Membuf
}
export interface VkTraceRaysIndirectCommandKHRInput {
    width: uint32_t | number | Membuf;
    height: uint32_t | number | Membuf;
    depth: uint32_t | number | Membuf
}
export interface VkTraceRaysIndirectCommand2KHRInput {
    raygenShaderRecordAddress: ptr64_t | Membuf;
    raygenShaderRecordSize: uint64_t | number | Membuf;
    missShaderBindingTableAddress: ptr64_t | Membuf;
    missShaderBindingTableSize: uint64_t | number | Membuf;
    missShaderBindingTableStride: uint64_t | number | Membuf;
    hitShaderBindingTableAddress: ptr64_t | Membuf;
    hitShaderBindingTableSize: uint64_t | number | Membuf;
    hitShaderBindingTableStride: uint64_t | number | Membuf;
    callableShaderBindingTableAddress: ptr64_t | Membuf;
    callableShaderBindingTableSize: uint64_t | number | Membuf;
    callableShaderBindingTableStride: uint64_t | number | Membuf;
    width: uint32_t | number | Membuf;
    height: uint32_t | number | Membuf;
    depth: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceRayTracingMaintenance1FeaturesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    rayTracingMaintenance1: uint32_t | boolean | Membuf;
    rayTracingPipelineTraceRaysIndirect2: uint32_t | boolean | Membuf
}
export interface VkDrmFormatModifierPropertiesListEXTInput {
    pNext?: ptr64_t| null | Membuf;
    drmFormatModifierCount?: uint32_t | number | Membuf;
    pDrmFormatModifierProperties?: VkDrmFormatModifierPropertiesEXT[] | null | Membuf
}
export interface VkDrmFormatModifierPropertiesEXTInput {
    drmFormatModifier: uint64_t | number | Membuf;
    drmFormatModifierPlaneCount: uint32_t | number | Membuf;
    drmFormatModifierTilingFeatures: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceImageDrmFormatModifierInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    drmFormatModifier: uint64_t | number | Membuf;
    sharingMode: int32_t | number | Membuf;
    queueFamilyIndexCount?: uint32_t | number | Membuf;
    pQueueFamilyIndices: uint32_t[] | null | Membuf
}
export interface VkImageDrmFormatModifierListCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    drmFormatModifierCount: uint32_t | number | Membuf;
    pDrmFormatModifiers: uint64_t[] | null | Membuf
}
export interface VkImageDrmFormatModifierExplicitCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    drmFormatModifier: uint64_t | number | Membuf;
    drmFormatModifierPlaneCount: uint32_t | number | Membuf;
    pPlaneLayouts: VkSubresourceLayout[] | null | Membuf
}
export interface VkImageDrmFormatModifierPropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    drmFormatModifier: uint64_t | number | Membuf
}
export interface VkImageStencilUsageCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    stencilUsage: uint32_t | number | Membuf
}
export interface VkImageStencilUsageCreateInfoEXTInput {

}
export interface VkPhysicalDeviceFragmentDensityMapFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    fragmentDensityMap: uint32_t | boolean | Membuf;
    fragmentDensityMapDynamic: uint32_t | boolean | Membuf;
    fragmentDensityMapNonSubsampledImages: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceFragmentDensityMap2FeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    fragmentDensityMapDeferred: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceFragmentDensityMapPropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    minFragmentDensityTexelSize: VkExtent2D[] | Membuf;
    maxFragmentDensityTexelSize: VkExtent2D[] | Membuf;
    fragmentDensityInvocations: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceFragmentDensityMap2PropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    subsampledLoads: uint32_t | boolean | Membuf;
    subsampledCoarseReconstructionEarlyAccess: uint32_t | boolean | Membuf;
    maxSubsampledArrayLayers: uint32_t | number | Membuf;
    maxDescriptorSetSubsampledSamplers: uint32_t | number | Membuf
}
export interface VkRenderPassFragmentDensityMapCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    fragmentDensityMapAttachment: VkAttachmentReference[] | Membuf
}
export interface VkPhysicalDeviceScalarBlockLayoutFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    scalarBlockLayout: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceScalarBlockLayoutFeaturesEXTInput {

}
export interface VkSurfaceProtectedCapabilitiesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    supportsProtected: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceUniformBufferStandardLayoutFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    uniformBufferStandardLayout: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHRInput {

}
export interface VkPhysicalDeviceMemoryBudgetPropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    heapBudget: uint64_t[] | null | Membuf;
    heapUsage: uint64_t[] | null | Membuf
}
export interface VkPhysicalDeviceMemoryPriorityFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    memoryPriority: uint32_t | boolean | Membuf
}
export interface VkMemoryPriorityAllocateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    priority: float | number | Membuf
}
export interface VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    pageableDeviceLocalMemory: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceBufferDeviceAddressFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    bufferDeviceAddress: uint32_t | boolean | Membuf;
    bufferDeviceAddressCaptureReplay: uint32_t | boolean | Membuf;
    bufferDeviceAddressMultiDevice: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceBufferDeviceAddressFeaturesKHRInput {

}
export interface VkBufferDeviceAddressInfoInput {
    pNext?: ptr64_t| null | Membuf;
    buffer: ptr64_t | Membuf
}
export interface VkBufferDeviceAddressInfoKHRInput {

}
export interface VkBufferOpaqueCaptureAddressCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    opaqueCaptureAddress: uint64_t | number | Membuf
}
export interface VkBufferOpaqueCaptureAddressCreateInfoKHRInput {

}
export interface VkPhysicalDeviceImageViewImageFormatInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    imageViewType: int32_t | number | Membuf
}
export interface VkFilterCubicImageViewImageFormatPropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    filterCubic: uint32_t | boolean | Membuf;
    filterCubicMinmax: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceImagelessFramebufferFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    imagelessFramebuffer: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceImagelessFramebufferFeaturesKHRInput {

}
export interface VkFramebufferAttachmentsCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    attachmentImageInfoCount?: uint32_t | number | Membuf;
    pAttachmentImageInfos: VkFramebufferAttachmentImageInfo[] | null | Membuf
}
export interface VkFramebufferAttachmentsCreateInfoKHRInput {

}
export interface VkFramebufferAttachmentImageInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    usage: uint32_t | number | Membuf;
    width: uint32_t | number | Membuf;
    height: uint32_t | number | Membuf;
    layerCount: uint32_t | number | Membuf;
    viewFormatCount?: uint32_t | number | Membuf;
    pViewFormats: int32_t[] | null | Membuf
}
export interface VkFramebufferAttachmentImageInfoKHRInput {

}
export interface VkRenderPassAttachmentBeginInfoInput {
    pNext?: ptr64_t| null | Membuf;
    attachmentCount?: uint32_t | number | Membuf;
    pAttachments: ptr64_t[] | null | Membuf
}
export interface VkRenderPassAttachmentBeginInfoKHRInput {

}
export interface VkPhysicalDeviceTextureCompressionASTCHDRFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    textureCompressionASTC_HDR: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTInput {

}
export interface VkPhysicalDeviceYcbcrImageArraysFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    ycbcrImageArrays: uint32_t | boolean | Membuf
}
export interface VkPipelineCreationFeedbackInput {
    flags: uint32_t | number | Membuf;
    duration: uint64_t | number | Membuf
}
export interface VkPipelineCreationFeedbackEXTInput {

}
export interface VkPipelineCreationFeedbackCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    pPipelineCreationFeedback: VkPipelineCreationFeedback| null | Membuf;
    pipelineStageCreationFeedbackCount?: uint32_t | number | Membuf;
    pPipelineStageCreationFeedbacks: VkPipelineCreationFeedback[] | null | Membuf
}
export interface VkPipelineCreationFeedbackCreateInfoEXTInput {

}
export interface VkHeadlessSurfaceCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: int32_t | number | Membuf
}
export interface VkPhysicalDeviceShaderClockFeaturesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    shaderSubgroupClock: uint32_t | boolean | Membuf;
    shaderDeviceClock: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceIndexTypeUint8FeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    indexTypeUint8: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    fragmentShaderSampleInterlock: uint32_t | boolean | Membuf;
    fragmentShaderPixelInterlock: uint32_t | boolean | Membuf;
    fragmentShaderShadingRateInterlock: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    separateDepthStencilLayouts: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHRInput {

}
export interface VkAttachmentReferenceStencilLayoutInput {
    pNext?: ptr64_t| null | Membuf;
    stencilLayout: int32_t | number | Membuf
}
export interface VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    primitiveTopologyListRestart: uint32_t | boolean | Membuf;
    primitiveTopologyPatchListRestart: uint32_t | boolean | Membuf
}
export interface VkAttachmentReferenceStencilLayoutKHRInput {

}
export interface VkAttachmentDescriptionStencilLayoutInput {
    pNext?: ptr64_t| null | Membuf;
    stencilInitialLayout: int32_t | number | Membuf;
    stencilFinalLayout: int32_t | number | Membuf
}
export interface VkAttachmentDescriptionStencilLayoutKHRInput {

}
export interface VkPipelineInfoEXTInput {

}
export interface VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    shaderDemoteToHelperInvocation: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTInput {

}
export interface VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    texelBufferAlignment: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceTexelBufferAlignmentPropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    storageTexelBufferOffsetAlignmentBytes: uint64_t | number | Membuf;
    storageTexelBufferOffsetSingleTexelAlignment: uint32_t | boolean | Membuf;
    uniformTexelBufferOffsetAlignmentBytes: uint64_t | number | Membuf;
    uniformTexelBufferOffsetSingleTexelAlignment: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTInput {

}
export interface VkPhysicalDeviceSubgroupSizeControlFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    subgroupSizeControl: uint32_t | boolean | Membuf;
    computeFullSubgroups: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceSubgroupSizeControlFeaturesEXTInput {

}
export interface VkPhysicalDeviceSubgroupSizeControlPropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    minSubgroupSize: uint32_t | number | Membuf;
    maxSubgroupSize: uint32_t | number | Membuf;
    maxComputeWorkgroupSubgroups: uint32_t | number | Membuf;
    requiredSubgroupSizeStages: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceSubgroupSizeControlPropertiesEXTInput {

}
export interface VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTInput {

}
export interface VkMemoryOpaqueCaptureAddressAllocateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    opaqueCaptureAddress: uint64_t | number | Membuf
}
export interface VkMemoryOpaqueCaptureAddressAllocateInfoKHRInput {

}
export interface VkDeviceMemoryOpaqueCaptureAddressInfoInput {
    pNext?: ptr64_t| null | Membuf;
    memory: ptr64_t | Membuf
}
export interface VkDeviceMemoryOpaqueCaptureAddressInfoKHRInput {

}
export interface VkPhysicalDeviceLineRasterizationFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    rectangularLines: uint32_t | boolean | Membuf;
    bresenhamLines: uint32_t | boolean | Membuf;
    smoothLines: uint32_t | boolean | Membuf;
    stippledRectangularLines: uint32_t | boolean | Membuf;
    stippledBresenhamLines: uint32_t | boolean | Membuf;
    stippledSmoothLines: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceLineRasterizationPropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    lineSubPixelPrecisionBits: uint32_t | number | Membuf
}
export interface VkPipelineRasterizationLineStateCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    lineRasterizationMode: int32_t | number | Membuf;
    stippledLineEnable: uint32_t | boolean | Membuf;
    lineStippleFactor: uint32_t | number | Membuf;
    lineStipplePattern: uint16_t | number | Membuf
}
export interface VkPhysicalDevicePipelineCreationCacheControlFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    pipelineCreationCacheControl: uint32_t | boolean | Membuf
}
export interface VkPhysicalDevicePipelineCreationCacheControlFeaturesEXTInput {

}
export interface VkPhysicalDeviceVulkan11FeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    storageBuffer16BitAccess: uint32_t | boolean | Membuf;
    uniformAndStorageBuffer16BitAccess: uint32_t | boolean | Membuf;
    storagePushConstant16: uint32_t | boolean | Membuf;
    storageInputOutput16: uint32_t | boolean | Membuf;
    multiview: uint32_t | boolean | Membuf;
    multiviewGeometryShader: uint32_t | boolean | Membuf;
    multiviewTessellationShader: uint32_t | boolean | Membuf;
    variablePointersStorageBuffer: uint32_t | boolean | Membuf;
    variablePointers: uint32_t | boolean | Membuf;
    protectedMemory: uint32_t | boolean | Membuf;
    samplerYcbcrConversion: uint32_t | boolean | Membuf;
    shaderDrawParameters: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceVulkan11PropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    deviceUUID: uint8_t[] | null | Membuf;
    driverUUID: uint8_t[] | null | Membuf;
    deviceLUID: uint8_t[] | null | Membuf;
    deviceNodeMask: uint32_t | number | Membuf;
    deviceLUIDValid: uint32_t | boolean | Membuf;
    subgroupSize: uint32_t | number | Membuf;
    subgroupSupportedStages: uint32_t | number | Membuf;
    subgroupSupportedOperations: uint32_t | number | Membuf;
    subgroupQuadOperationsInAllStages: uint32_t | boolean | Membuf;
    pointClippingBehavior: int32_t | number | Membuf;
    maxMultiviewViewCount: uint32_t | number | Membuf;
    maxMultiviewInstanceIndex: uint32_t | number | Membuf;
    protectedNoFault: uint32_t | boolean | Membuf;
    maxPerSetDescriptors: uint32_t | number | Membuf;
    maxMemoryAllocationSize: uint64_t | number | Membuf
}
export interface VkPhysicalDeviceVulkan12FeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    samplerMirrorClampToEdge: uint32_t | boolean | Membuf;
    drawIndirectCount: uint32_t | boolean | Membuf;
    storageBuffer8BitAccess: uint32_t | boolean | Membuf;
    uniformAndStorageBuffer8BitAccess: uint32_t | boolean | Membuf;
    storagePushConstant8: uint32_t | boolean | Membuf;
    shaderBufferInt64Atomics: uint32_t | boolean | Membuf;
    shaderSharedInt64Atomics: uint32_t | boolean | Membuf;
    shaderFloat16: uint32_t | boolean | Membuf;
    shaderInt8: uint32_t | boolean | Membuf;
    descriptorIndexing: uint32_t | boolean | Membuf;
    shaderInputAttachmentArrayDynamicIndexing: uint32_t | boolean | Membuf;
    shaderUniformTexelBufferArrayDynamicIndexing: uint32_t | boolean | Membuf;
    shaderStorageTexelBufferArrayDynamicIndexing: uint32_t | boolean | Membuf;
    shaderUniformBufferArrayNonUniformIndexing: uint32_t | boolean | Membuf;
    shaderSampledImageArrayNonUniformIndexing: uint32_t | boolean | Membuf;
    shaderStorageBufferArrayNonUniformIndexing: uint32_t | boolean | Membuf;
    shaderStorageImageArrayNonUniformIndexing: uint32_t | boolean | Membuf;
    shaderInputAttachmentArrayNonUniformIndexing: uint32_t | boolean | Membuf;
    shaderUniformTexelBufferArrayNonUniformIndexing: uint32_t | boolean | Membuf;
    shaderStorageTexelBufferArrayNonUniformIndexing: uint32_t | boolean | Membuf;
    descriptorBindingUniformBufferUpdateAfterBind: uint32_t | boolean | Membuf;
    descriptorBindingSampledImageUpdateAfterBind: uint32_t | boolean | Membuf;
    descriptorBindingStorageImageUpdateAfterBind: uint32_t | boolean | Membuf;
    descriptorBindingStorageBufferUpdateAfterBind: uint32_t | boolean | Membuf;
    descriptorBindingUniformTexelBufferUpdateAfterBind: uint32_t | boolean | Membuf;
    descriptorBindingStorageTexelBufferUpdateAfterBind: uint32_t | boolean | Membuf;
    descriptorBindingUpdateUnusedWhilePending: uint32_t | boolean | Membuf;
    descriptorBindingPartiallyBound: uint32_t | boolean | Membuf;
    descriptorBindingVariableDescriptorCount: uint32_t | boolean | Membuf;
    runtimeDescriptorArray: uint32_t | boolean | Membuf;
    samplerFilterMinmax: uint32_t | boolean | Membuf;
    scalarBlockLayout: uint32_t | boolean | Membuf;
    imagelessFramebuffer: uint32_t | boolean | Membuf;
    uniformBufferStandardLayout: uint32_t | boolean | Membuf;
    shaderSubgroupExtendedTypes: uint32_t | boolean | Membuf;
    separateDepthStencilLayouts: uint32_t | boolean | Membuf;
    hostQueryReset: uint32_t | boolean | Membuf;
    timelineSemaphore: uint32_t | boolean | Membuf;
    bufferDeviceAddress: uint32_t | boolean | Membuf;
    bufferDeviceAddressCaptureReplay: uint32_t | boolean | Membuf;
    bufferDeviceAddressMultiDevice: uint32_t | boolean | Membuf;
    vulkanMemoryModel: uint32_t | boolean | Membuf;
    vulkanMemoryModelDeviceScope: uint32_t | boolean | Membuf;
    vulkanMemoryModelAvailabilityVisibilityChains: uint32_t | boolean | Membuf;
    shaderOutputViewportIndex: uint32_t | boolean | Membuf;
    shaderOutputLayer: uint32_t | boolean | Membuf;
    subgroupBroadcastDynamicId: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceVulkan12PropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    driverID: int32_t | number | Membuf;
    driverName: char[] | null | Membuf;
    driverInfo: char[] | null | Membuf;
    conformanceVersion: VkConformanceVersion[] | Membuf;
    denormBehaviorIndependence: int32_t | number | Membuf;
    roundingModeIndependence: int32_t | number | Membuf;
    shaderSignedZeroInfNanPreserveFloat16: uint32_t | boolean | Membuf;
    shaderSignedZeroInfNanPreserveFloat32: uint32_t | boolean | Membuf;
    shaderSignedZeroInfNanPreserveFloat64: uint32_t | boolean | Membuf;
    shaderDenormPreserveFloat16: uint32_t | boolean | Membuf;
    shaderDenormPreserveFloat32: uint32_t | boolean | Membuf;
    shaderDenormPreserveFloat64: uint32_t | boolean | Membuf;
    shaderDenormFlushToZeroFloat16: uint32_t | boolean | Membuf;
    shaderDenormFlushToZeroFloat32: uint32_t | boolean | Membuf;
    shaderDenormFlushToZeroFloat64: uint32_t | boolean | Membuf;
    shaderRoundingModeRTEFloat16: uint32_t | boolean | Membuf;
    shaderRoundingModeRTEFloat32: uint32_t | boolean | Membuf;
    shaderRoundingModeRTEFloat64: uint32_t | boolean | Membuf;
    shaderRoundingModeRTZFloat16: uint32_t | boolean | Membuf;
    shaderRoundingModeRTZFloat32: uint32_t | boolean | Membuf;
    shaderRoundingModeRTZFloat64: uint32_t | boolean | Membuf;
    maxUpdateAfterBindDescriptorsInAllPools: uint32_t | number | Membuf;
    shaderUniformBufferArrayNonUniformIndexingNative: uint32_t | boolean | Membuf;
    shaderSampledImageArrayNonUniformIndexingNative: uint32_t | boolean | Membuf;
    shaderStorageBufferArrayNonUniformIndexingNative: uint32_t | boolean | Membuf;
    shaderStorageImageArrayNonUniformIndexingNative: uint32_t | boolean | Membuf;
    shaderInputAttachmentArrayNonUniformIndexingNative: uint32_t | boolean | Membuf;
    robustBufferAccessUpdateAfterBind: uint32_t | boolean | Membuf;
    quadDivergentImplicitLod: uint32_t | boolean | Membuf;
    maxPerStageDescriptorUpdateAfterBindSamplers: uint32_t | number | Membuf;
    maxPerStageDescriptorUpdateAfterBindUniformBuffers: uint32_t | number | Membuf;
    maxPerStageDescriptorUpdateAfterBindStorageBuffers: uint32_t | number | Membuf;
    maxPerStageDescriptorUpdateAfterBindSampledImages: uint32_t | number | Membuf;
    maxPerStageDescriptorUpdateAfterBindStorageImages: uint32_t | number | Membuf;
    maxPerStageDescriptorUpdateAfterBindInputAttachments: uint32_t | number | Membuf;
    maxPerStageUpdateAfterBindResources: uint32_t | number | Membuf;
    maxDescriptorSetUpdateAfterBindSamplers: uint32_t | number | Membuf;
    maxDescriptorSetUpdateAfterBindUniformBuffers: uint32_t | number | Membuf;
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: uint32_t | number | Membuf;
    maxDescriptorSetUpdateAfterBindStorageBuffers: uint32_t | number | Membuf;
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: uint32_t | number | Membuf;
    maxDescriptorSetUpdateAfterBindSampledImages: uint32_t | number | Membuf;
    maxDescriptorSetUpdateAfterBindStorageImages: uint32_t | number | Membuf;
    maxDescriptorSetUpdateAfterBindInputAttachments: uint32_t | number | Membuf;
    supportedDepthResolveModes: uint32_t | number | Membuf;
    supportedStencilResolveModes: uint32_t | number | Membuf;
    independentResolveNone: uint32_t | boolean | Membuf;
    independentResolve: uint32_t | boolean | Membuf;
    filterMinmaxSingleComponentFormats: uint32_t | boolean | Membuf;
    filterMinmaxImageComponentMapping: uint32_t | boolean | Membuf;
    maxTimelineSemaphoreValueDifference: uint64_t | number | Membuf;
    framebufferIntegerColorSampleCounts?: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceVulkan13FeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    robustImageAccess: uint32_t | boolean | Membuf;
    inlineUniformBlock: uint32_t | boolean | Membuf;
    descriptorBindingInlineUniformBlockUpdateAfterBind: uint32_t | boolean | Membuf;
    pipelineCreationCacheControl: uint32_t | boolean | Membuf;
    privateData: uint32_t | boolean | Membuf;
    shaderDemoteToHelperInvocation: uint32_t | boolean | Membuf;
    shaderTerminateInvocation: uint32_t | boolean | Membuf;
    subgroupSizeControl: uint32_t | boolean | Membuf;
    computeFullSubgroups: uint32_t | boolean | Membuf;
    synchronization2: uint32_t | boolean | Membuf;
    textureCompressionASTC_HDR: uint32_t | boolean | Membuf;
    shaderZeroInitializeWorkgroupMemory: uint32_t | boolean | Membuf;
    dynamicRendering: uint32_t | boolean | Membuf;
    shaderIntegerDotProduct: uint32_t | boolean | Membuf;
    maintenance4: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceVulkan13PropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    minSubgroupSize: uint32_t | number | Membuf;
    maxSubgroupSize: uint32_t | number | Membuf;
    maxComputeWorkgroupSubgroups: uint32_t | number | Membuf;
    requiredSubgroupSizeStages: uint32_t | number | Membuf;
    maxInlineUniformBlockSize: uint32_t | number | Membuf;
    maxPerStageDescriptorInlineUniformBlocks: uint32_t | number | Membuf;
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: uint32_t | number | Membuf;
    maxDescriptorSetInlineUniformBlocks: uint32_t | number | Membuf;
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks: uint32_t | number | Membuf;
    maxInlineUniformTotalSize: uint32_t | number | Membuf;
    integerDotProduct8BitUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct8BitSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct8BitMixedSignednessAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct4x8BitPackedUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct4x8BitPackedSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct4x8BitPackedMixedSignednessAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct16BitUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct16BitSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct16BitMixedSignednessAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct32BitUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct32BitSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct32BitMixedSignednessAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct64BitUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct64BitSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct64BitMixedSignednessAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating8BitSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating16BitSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating32BitSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating64BitSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: uint32_t | boolean | Membuf;
    storageTexelBufferOffsetAlignmentBytes: uint64_t | number | Membuf;
    storageTexelBufferOffsetSingleTexelAlignment: uint32_t | boolean | Membuf;
    uniformTexelBufferOffsetAlignmentBytes: uint64_t | number | Membuf;
    uniformTexelBufferOffsetSingleTexelAlignment: uint32_t | boolean | Membuf;
    maxBufferSize: uint64_t | number | Membuf
}
export interface VkPhysicalDeviceToolPropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    name: char[] | null | Membuf;
    version: char[] | null | Membuf;
    purposes: uint32_t | number | Membuf;
    description: char[] | null | Membuf;
    layer: char[] | null | Membuf
}
export interface VkPhysicalDeviceToolPropertiesEXTInput {

}
export interface VkRayTracingPipelineInterfaceCreateInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    maxPipelineRayPayloadSize: uint32_t | number | Membuf;
    maxPipelineRayHitAttributeSize: uint32_t | number | Membuf
}
export interface VkPipelineLibraryCreateInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    libraryCount?: uint32_t | number | Membuf;
    pLibraries: ptr64_t[] | null | Membuf
}
export interface VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    shaderZeroInitializeWorkgroupMemory: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHRInput {

}
export interface VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    shaderSubgroupUniformControlFlow: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceRobustness2FeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    robustBufferAccess2: uint32_t | boolean | Membuf;
    robustImageAccess2: uint32_t | boolean | Membuf;
    nullDescriptor: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceRobustness2PropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    robustStorageBufferAccessSizeAlignment: uint64_t | number | Membuf;
    robustUniformBufferAccessSizeAlignment: uint64_t | number | Membuf
}
export interface VkPhysicalDeviceImageRobustnessFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    robustImageAccess: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceImageRobustnessFeaturesEXTInput {

}
export interface VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    workgroupMemoryExplicitLayout: uint32_t | boolean | Membuf;
    workgroupMemoryExplicitLayoutScalarBlockLayout: uint32_t | boolean | Membuf;
    workgroupMemoryExplicitLayout8BitAccess: uint32_t | boolean | Membuf;
    workgroupMemoryExplicitLayout16BitAccess: uint32_t | boolean | Membuf
}
export interface VkBufferCopy2Input {
    pNext?: ptr64_t| null | Membuf;
    srcOffset: uint64_t | number | Membuf;
    dstOffset: uint64_t | number | Membuf;
    size: uint64_t | number | Membuf
}
export interface VkBufferCopy2KHRInput {

}
export interface VkImageCopy2Input {
    pNext?: ptr64_t| null | Membuf;
    srcSubresource: VkImageSubresourceLayers[] | Membuf;
    srcOffset: VkOffset3D[] | Membuf;
    dstSubresource: VkImageSubresourceLayers[] | Membuf;
    dstOffset: VkOffset3D[] | Membuf;
    extent: VkExtent3D[] | Membuf
}
export interface VkImageCopy2KHRInput {

}
export interface VkImageBlit2Input {
    pNext?: ptr64_t| null | Membuf;
    srcSubresource: VkImageSubresourceLayers[] | Membuf;
    srcOffsets: VkOffset3D[] | Membuf;
    dstSubresource: VkImageSubresourceLayers[] | Membuf;
    dstOffsets: VkOffset3D[] | Membuf
}
export interface VkImageBlit2KHRInput {

}
export interface VkBufferImageCopy2Input {
    pNext?: ptr64_t| null | Membuf;
    bufferOffset: uint64_t | number | Membuf;
    bufferRowLength: uint32_t | number | Membuf;
    bufferImageHeight: uint32_t | number | Membuf;
    imageSubresource: VkImageSubresourceLayers[] | Membuf;
    imageOffset: VkOffset3D[] | Membuf;
    imageExtent: VkExtent3D[] | Membuf
}
export interface VkBufferImageCopy2KHRInput {

}
export interface VkImageResolve2Input {
    pNext?: ptr64_t| null | Membuf;
    srcSubresource: VkImageSubresourceLayers[] | Membuf;
    srcOffset: VkOffset3D[] | Membuf;
    dstSubresource: VkImageSubresourceLayers[] | Membuf;
    dstOffset: VkOffset3D[] | Membuf;
    extent: VkExtent3D[] | Membuf
}
export interface VkImageResolve2KHRInput {

}
export interface VkCopyBufferInfo2Input {
    pNext?: ptr64_t| null | Membuf;
    srcBuffer: ptr64_t | Membuf;
    dstBuffer: ptr64_t | Membuf;
    regionCount: uint32_t | number | Membuf;
    pRegions: VkBufferCopy2[] | null | Membuf
}
export interface VkCopyBufferInfo2KHRInput {

}
export interface VkCopyImageInfo2Input {
    pNext?: ptr64_t| null | Membuf;
    srcImage: ptr64_t | Membuf;
    srcImageLayout: int32_t | number | Membuf;
    dstImage: ptr64_t | Membuf;
    dstImageLayout: int32_t | number | Membuf;
    regionCount: uint32_t | number | Membuf;
    pRegions: VkImageCopy2[] | null | Membuf
}
export interface VkCopyImageInfo2KHRInput {

}
export interface VkBlitImageInfo2Input {
    pNext?: ptr64_t| null | Membuf;
    srcImage: ptr64_t | Membuf;
    srcImageLayout: int32_t | number | Membuf;
    dstImage: ptr64_t | Membuf;
    dstImageLayout: int32_t | number | Membuf;
    regionCount: uint32_t | number | Membuf;
    pRegions: VkImageBlit2[] | null | Membuf;
    filter: int32_t | number | Membuf
}
export interface VkBlitImageInfo2KHRInput {

}
export interface VkCopyBufferToImageInfo2Input {
    pNext?: ptr64_t| null | Membuf;
    srcBuffer: ptr64_t | Membuf;
    dstImage: ptr64_t | Membuf;
    dstImageLayout: int32_t | number | Membuf;
    regionCount: uint32_t | number | Membuf;
    pRegions: VkBufferImageCopy2[] | null | Membuf
}
export interface VkCopyBufferToImageInfo2KHRInput {

}
export interface VkCopyImageToBufferInfo2Input {
    pNext?: ptr64_t| null | Membuf;
    srcImage: ptr64_t | Membuf;
    srcImageLayout: int32_t | number | Membuf;
    dstBuffer: ptr64_t | Membuf;
    regionCount: uint32_t | number | Membuf;
    pRegions: VkBufferImageCopy2[] | null | Membuf
}
export interface VkCopyImageToBufferInfo2KHRInput {

}
export interface VkResolveImageInfo2Input {
    pNext?: ptr64_t| null | Membuf;
    srcImage: ptr64_t | Membuf;
    srcImageLayout: int32_t | number | Membuf;
    dstImage: ptr64_t | Membuf;
    dstImageLayout: int32_t | number | Membuf;
    regionCount: uint32_t | number | Membuf;
    pRegions: VkImageResolve2[] | null | Membuf
}
export interface VkResolveImageInfo2KHRInput {

}
export interface VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    shaderImageInt64Atomics: uint32_t | boolean | Membuf;
    sparseImageInt64Atomics: uint32_t | boolean | Membuf
}
export interface VkFragmentShadingRateAttachmentInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    pFragmentShadingRateAttachment?: VkAttachmentReference2| null | Membuf;
    shadingRateAttachmentTexelSize: VkExtent2D[] | Membuf
}
export interface VkPipelineFragmentShadingRateStateCreateInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    fragmentSize: VkExtent2D[] | Membuf;
    combinerOps: int32_t[] | null | Membuf
}
export interface VkPhysicalDeviceFragmentShadingRateFeaturesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    pipelineFragmentShadingRate: uint32_t | boolean | Membuf;
    primitiveFragmentShadingRate: uint32_t | boolean | Membuf;
    attachmentFragmentShadingRate: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceFragmentShadingRatePropertiesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    minFragmentShadingRateAttachmentTexelSize: VkExtent2D[] | Membuf;
    maxFragmentShadingRateAttachmentTexelSize: VkExtent2D[] | Membuf;
    maxFragmentShadingRateAttachmentTexelSizeAspectRatio: uint32_t | number | Membuf;
    primitiveFragmentShadingRateWithMultipleViewports: uint32_t | boolean | Membuf;
    layeredShadingRateAttachments: uint32_t | boolean | Membuf;
    fragmentShadingRateNonTrivialCombinerOps: uint32_t | boolean | Membuf;
    maxFragmentSize: VkExtent2D[] | Membuf;
    maxFragmentSizeAspectRatio: uint32_t | number | Membuf;
    maxFragmentShadingRateCoverageSamples: uint32_t | number | Membuf;
    maxFragmentShadingRateRasterizationSamples: uint32_t | number | Membuf;
    fragmentShadingRateWithShaderDepthStencilWrites: uint32_t | boolean | Membuf;
    fragmentShadingRateWithSampleMask: uint32_t | boolean | Membuf;
    fragmentShadingRateWithShaderSampleMask: uint32_t | boolean | Membuf;
    fragmentShadingRateWithConservativeRasterization: uint32_t | boolean | Membuf;
    fragmentShadingRateWithFragmentShaderInterlock: uint32_t | boolean | Membuf;
    fragmentShadingRateWithCustomSampleLocations: uint32_t | boolean | Membuf;
    fragmentShadingRateStrictMultiplyCombiner: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceFragmentShadingRateKHRInput {
    pNext?: ptr64_t| null | Membuf;
    sampleCounts: uint32_t | number | Membuf;
    fragmentSize: VkExtent2D[] | Membuf
}
export interface VkPhysicalDeviceShaderTerminateInvocationFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    shaderTerminateInvocation: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceShaderTerminateInvocationFeaturesKHRInput {

}
export interface VkPhysicalDeviceImage2DViewOf3DFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    image2DViewOf3D: uint32_t | boolean | Membuf;
    sampler2DViewOf3D: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceMutableDescriptorTypeFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    mutableDescriptorType: uint32_t | boolean | Membuf
}
export interface VkMutableDescriptorTypeListEXTInput {
    descriptorTypeCount?: uint32_t | number | Membuf;
    pDescriptorTypes: int32_t[] | null | Membuf
}
export interface VkMutableDescriptorTypeCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    mutableDescriptorTypeListCount?: uint32_t | number | Membuf;
    pMutableDescriptorTypeLists: VkMutableDescriptorTypeListEXT[] | null | Membuf
}
export interface VkPhysicalDeviceVertexInputDynamicStateFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    vertexInputDynamicState: uint32_t | boolean | Membuf
}
export interface VkMemoryBarrier2Input {
    pNext?: ptr64_t| null | Membuf;
    srcStageMask?: uint64_t | number | Membuf;
    srcAccessMask?: uint64_t | number | Membuf;
    dstStageMask?: uint64_t | number | Membuf;
    dstAccessMask?: uint64_t | number | Membuf
}
export interface VkMemoryBarrier2KHRInput {

}
export interface VkImageMemoryBarrier2Input {
    pNext?: ptr64_t| null | Membuf;
    srcStageMask?: uint64_t | number | Membuf;
    srcAccessMask?: uint64_t | number | Membuf;
    dstStageMask?: uint64_t | number | Membuf;
    dstAccessMask?: uint64_t | number | Membuf;
    oldLayout: int32_t | number | Membuf;
    newLayout: int32_t | number | Membuf;
    srcQueueFamilyIndex: uint32_t | number | Membuf;
    dstQueueFamilyIndex: uint32_t | number | Membuf;
    image: ptr64_t | Membuf;
    subresourceRange: VkImageSubresourceRange[] | Membuf
}
export interface VkImageMemoryBarrier2KHRInput {

}
export interface VkBufferMemoryBarrier2Input {
    pNext?: ptr64_t| null | Membuf;
    srcStageMask?: uint64_t | number | Membuf;
    srcAccessMask?: uint64_t | number | Membuf;
    dstStageMask?: uint64_t | number | Membuf;
    dstAccessMask?: uint64_t | number | Membuf;
    srcQueueFamilyIndex: uint32_t | number | Membuf;
    dstQueueFamilyIndex: uint32_t | number | Membuf;
    buffer: ptr64_t | Membuf;
    offset: uint64_t | number | Membuf;
    size: uint64_t | number | Membuf
}
export interface VkBufferMemoryBarrier2KHRInput {

}
export interface VkDependencyInfoInput {
    pNext?: ptr64_t| null | Membuf;
    dependencyFlags?: uint32_t | number | Membuf;
    memoryBarrierCount?: uint32_t | number | Membuf;
    pMemoryBarriers: VkMemoryBarrier2[] | null | Membuf;
    bufferMemoryBarrierCount?: uint32_t | number | Membuf;
    pBufferMemoryBarriers: VkBufferMemoryBarrier2[] | null | Membuf;
    imageMemoryBarrierCount?: uint32_t | number | Membuf;
    pImageMemoryBarriers: VkImageMemoryBarrier2[] | null | Membuf
}
export interface VkDependencyInfoKHRInput {

}
export interface VkSemaphoreSubmitInfoInput {
    pNext?: ptr64_t| null | Membuf;
    semaphore: ptr64_t | Membuf;
    value: uint64_t | number | Membuf;
    stageMask?: uint64_t | number | Membuf;
    deviceIndex: uint32_t | number | Membuf
}
export interface VkSemaphoreSubmitInfoKHRInput {

}
export interface VkCommandBufferSubmitInfoInput {
    pNext?: ptr64_t| null | Membuf;
    commandBuffer: ptr64_t | Membuf;
    deviceMask: uint32_t | number | Membuf
}
export interface VkCommandBufferSubmitInfoKHRInput {

}
export interface VkSubmitInfo2Input {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    waitSemaphoreInfoCount?: uint32_t | number | Membuf;
    pWaitSemaphoreInfos: VkSemaphoreSubmitInfo[] | null | Membuf;
    commandBufferInfoCount?: uint32_t | number | Membuf;
    pCommandBufferInfos: VkCommandBufferSubmitInfo[] | null | Membuf;
    signalSemaphoreInfoCount?: uint32_t | number | Membuf;
    pSignalSemaphoreInfos: VkSemaphoreSubmitInfo[] | null | Membuf
}
export interface VkSubmitInfo2KHRInput {

}
export interface VkQueueFamilyCheckpointProperties2NVInput {
    pNext?: ptr64_t| null | Membuf;
    checkpointExecutionStageMask: uint64_t | number | Membuf
}
export interface VkCheckpointData2NVInput {
    pNext?: ptr64_t| null | Membuf;
    stage: uint64_t | number | Membuf;
    pCheckpointMarker: ptr64_t| null | Membuf
}
export interface VkPhysicalDeviceSynchronization2FeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    synchronization2: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceSynchronization2FeaturesKHRInput {

}
export interface VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    primitivesGeneratedQuery: uint32_t | boolean | Membuf;
    primitivesGeneratedQueryWithRasterizerDiscard: uint32_t | boolean | Membuf;
    primitivesGeneratedQueryWithNonZeroStreams: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceLegacyDitheringFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    legacyDithering: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    multisampledRenderToSingleSampled: uint32_t | boolean | Membuf
}
export interface VkSubpassResolvePerformanceQueryEXTInput {
    pNext?: ptr64_t| null | Membuf;
    optimal: uint32_t | boolean | Membuf
}
export interface VkMultisampledRenderToSingleSampledInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    multisampledRenderToSingleSampledEnable: uint32_t | boolean | Membuf;
    rasterizationSamples: uint32_t | number | Membuf
}
export interface VkPhysicalDevicePipelineProtectedAccessFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    pipelineProtectedAccess: uint32_t | boolean | Membuf
}
export interface VkQueueFamilyVideoPropertiesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    videoCodecOperations: uint32_t | number | Membuf
}
export interface VkQueueFamilyQueryResultStatusPropertiesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    queryResultStatusSupport: uint32_t | boolean | Membuf
}
export interface VkVideoProfileListInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    profileCount?: uint32_t | number | Membuf;
    pProfiles: VkVideoProfileInfoKHR[] | null | Membuf
}
export interface VkPhysicalDeviceVideoFormatInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    imageUsage: uint32_t | number | Membuf
}
export interface VkVideoFormatPropertiesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    format: int32_t | number | Membuf;
    componentMapping: VkComponentMapping[] | Membuf;
    imageCreateFlags: uint32_t | number | Membuf;
    imageType: int32_t | number | Membuf;
    imageTiling: int32_t | number | Membuf;
    imageUsageFlags: uint32_t | number | Membuf
}
export interface VkVideoProfileInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    videoCodecOperation: uint32_t | number | Membuf;
    chromaSubsampling: uint32_t | number | Membuf;
    lumaBitDepth: uint32_t | number | Membuf;
    chromaBitDepth?: uint32_t | number | Membuf
}
export interface VkVideoCapabilitiesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    flags: uint32_t | number | Membuf;
    minBitstreamBufferOffsetAlignment: uint64_t | number | Membuf;
    minBitstreamBufferSizeAlignment: uint64_t | number | Membuf;
    pictureAccessGranularity: VkExtent2D[] | Membuf;
    minCodedExtent: VkExtent2D[] | Membuf;
    maxCodedExtent: VkExtent2D[] | Membuf;
    maxDpbSlots: uint32_t | number | Membuf;
    maxActiveReferencePictures: uint32_t | number | Membuf;
    stdHeaderVersion: VkExtensionProperties[] | Membuf
}
export interface VkVideoSessionMemoryRequirementsKHRInput {
    pNext?: ptr64_t| null | Membuf;
    memoryBindIndex: uint32_t | number | Membuf;
    memoryRequirements: VkMemoryRequirements[] | Membuf
}
export interface VkBindVideoSessionMemoryInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    memoryBindIndex: uint32_t | number | Membuf;
    memory: ptr64_t | Membuf;
    memoryOffset: uint64_t | number | Membuf;
    memorySize: uint64_t | number | Membuf
}
export interface VkVideoPictureResourceInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    codedOffset: VkOffset2D[] | Membuf;
    codedExtent: VkExtent2D[] | Membuf;
    baseArrayLayer: uint32_t | number | Membuf;
    imageViewBinding: ptr64_t | Membuf
}
export interface VkVideoReferenceSlotInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    slotIndex: int32_t | number | Membuf;
    pPictureResource?: VkVideoPictureResourceInfoKHR| null | Membuf
}
export interface VkVideoSessionCreateInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    queueFamilyIndex: uint32_t | number | Membuf;
    flags?: uint32_t | number | Membuf;
    pVideoProfile: VkVideoProfileInfoKHR| null | Membuf;
    pictureFormat: int32_t | number | Membuf;
    maxCodedExtent: VkExtent2D[] | Membuf;
    referencePictureFormat: int32_t | number | Membuf;
    maxDpbSlots: uint32_t | number | Membuf;
    maxActiveReferencePictures: uint32_t | number | Membuf;
    pStdHeaderVersion: VkExtensionProperties| null | Membuf
}
export interface VkVideoSessionParametersCreateInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: int32_t | number | Membuf;
    videoSessionParametersTemplate?: ptr64_t | Membuf;
    videoSession: ptr64_t | Membuf
}
export interface VkVideoSessionParametersUpdateInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    updateSequenceCount: uint32_t | number | Membuf
}
export interface VkVideoBeginCodingInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: int32_t | number | Membuf;
    videoSession: ptr64_t | Membuf;
    videoSessionParameters?: ptr64_t | Membuf;
    referenceSlotCount?: uint32_t | number | Membuf;
    pReferenceSlots: VkVideoReferenceSlotInfoKHR[] | null | Membuf
}
export interface VkVideoEndCodingInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: int32_t | number | Membuf
}
export interface VkVideoCodingControlInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    flags: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    ycbcr2plane444Formats: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceProvokingVertexFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    provokingVertexLast: uint32_t | boolean | Membuf;
    transformFeedbackPreservesProvokingVertex: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceProvokingVertexPropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    provokingVertexModePerPipeline: uint32_t | boolean | Membuf;
    transformFeedbackPreservesTriangleFanProvokingVertex: uint32_t | boolean | Membuf
}
export interface VkPipelineRasterizationProvokingVertexStateCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    provokingVertexMode: int32_t | number | Membuf
}
export interface VkPhysicalDeviceShaderIntegerDotProductFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    shaderIntegerDotProduct: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceShaderIntegerDotProductFeaturesKHRInput {

}
export interface VkPhysicalDeviceShaderIntegerDotProductPropertiesInput {
    pNext?: ptr64_t| null | Membuf;
    integerDotProduct8BitUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct8BitSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct8BitMixedSignednessAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct4x8BitPackedUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct4x8BitPackedSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct4x8BitPackedMixedSignednessAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct16BitUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct16BitSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct16BitMixedSignednessAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct32BitUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct32BitSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct32BitMixedSignednessAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct64BitUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct64BitSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProduct64BitMixedSignednessAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating8BitSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating16BitSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating32BitSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating64BitSignedAccelerated: uint32_t | boolean | Membuf;
    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceShaderIntegerDotProductPropertiesKHRInput {

}
export interface VkPhysicalDeviceDrmPropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    hasPrimary: uint32_t | boolean | Membuf;
    hasRender: uint32_t | boolean | Membuf;
    primaryMajor: int64_t | number | Membuf;
    primaryMinor: int64_t | number | Membuf;
    renderMajor: int64_t | number | Membuf;
    renderMinor: int64_t | number | Membuf
}
export interface VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    fragmentShaderBarycentric: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHRInput {
    pNext?: ptr64_t| null | Membuf;
    triStripVertexOrderIndependentOfProvokingVertex: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceRGBA10X6FormatsFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    formatRgba10x6WithoutYCbCrSampler: uint32_t | boolean | Membuf
}
export interface VkFormatProperties3Input {
    pNext?: ptr64_t| null | Membuf;
    linearTilingFeatures?: uint64_t | number | Membuf;
    optimalTilingFeatures?: uint64_t | number | Membuf;
    bufferFeatures?: uint64_t | number | Membuf
}
export interface VkFormatProperties3KHRInput {

}
export interface VkDrmFormatModifierPropertiesList2EXTInput {
    pNext?: ptr64_t| null | Membuf;
    drmFormatModifierCount?: uint32_t | number | Membuf;
    pDrmFormatModifierProperties?: VkDrmFormatModifierProperties2EXT[] | null | Membuf
}
export interface VkDrmFormatModifierProperties2EXTInput {
    drmFormatModifier: uint64_t | number | Membuf;
    drmFormatModifierPlaneCount: uint32_t | number | Membuf;
    drmFormatModifierTilingFeatures: uint64_t | number | Membuf
}
export interface VkPipelineRenderingCreateInfoInput {
    pNext?: ptr64_t| null | Membuf;
    viewMask: uint32_t | number | Membuf;
    colorAttachmentCount?: uint32_t | number | Membuf;
    pColorAttachmentFormats: int32_t[] | null | Membuf;
    depthAttachmentFormat: int32_t | number | Membuf;
    stencilAttachmentFormat: int32_t | number | Membuf
}
export interface VkPipelineRenderingCreateInfoKHRInput {

}
export interface VkRenderingInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    renderArea: VkRect2D[] | Membuf;
    layerCount: uint32_t | number | Membuf;
    viewMask: uint32_t | number | Membuf;
    colorAttachmentCount?: uint32_t | number | Membuf;
    pColorAttachments: VkRenderingAttachmentInfo[] | null | Membuf;
    pDepthAttachment?: VkRenderingAttachmentInfo| null | Membuf;
    pStencilAttachment?: VkRenderingAttachmentInfo| null | Membuf
}
export interface VkRenderingAttachmentInfoInput {
    pNext?: ptr64_t| null | Membuf;
    imageView?: ptr64_t | Membuf;
    imageLayout: int32_t | number | Membuf;
    resolveMode?: uint32_t | number | Membuf;
    resolveImageView?: ptr64_t | Membuf;
    resolveImageLayout: int32_t | number | Membuf;
    loadOp: int32_t | number | Membuf;
    storeOp: int32_t | number | Membuf;
    clearValue: VkClearValue[] | Membuf
}
export interface VkRenderingAttachmentInfoKHRInput {

}
export interface VkRenderingFragmentShadingRateAttachmentInfoKHRInput {
    pNext?: ptr64_t| null | Membuf;
    imageView?: ptr64_t | Membuf;
    imageLayout: int32_t | number | Membuf;
    shadingRateAttachmentTexelSize: VkExtent2D[] | Membuf
}
export interface VkRenderingFragmentDensityMapAttachmentInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    imageView: ptr64_t | Membuf;
    imageLayout: int32_t | number | Membuf
}
export interface VkPhysicalDeviceDynamicRenderingFeaturesInput {
    pNext?: ptr64_t| null | Membuf;
    dynamicRendering: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceDynamicRenderingFeaturesKHRInput {

}
export interface VkCommandBufferInheritanceRenderingInfoInput {
    pNext?: ptr64_t| null | Membuf;
    flags?: uint32_t | number | Membuf;
    viewMask: uint32_t | number | Membuf;
    colorAttachmentCount?: uint32_t | number | Membuf;
    pColorAttachmentFormats: int32_t[] | null | Membuf;
    depthAttachmentFormat: int32_t | number | Membuf;
    stencilAttachmentFormat: int32_t | number | Membuf;
    rasterizationSamples?: uint32_t | number | Membuf
}
export interface VkCommandBufferInheritanceRenderingInfoKHRInput {

}
export interface VkAttachmentSampleCountInfoAMDInput {
    pNext?: ptr64_t| null | Membuf;
    colorAttachmentCount?: uint32_t | number | Membuf;
    pColorAttachmentSamples: uint32_t[] | null | Membuf;
    depthStencilAttachmentSamples?: uint32_t | number | Membuf
}
export interface VkAttachmentSampleCountInfoNVInput {

}
export interface VkMultiviewPerViewAttributesInfoNVXInput {
    pNext?: ptr64_t| null | Membuf;
    perViewAttributes: uint32_t | boolean | Membuf;
    perViewAttributesPositionXOnly: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceImageViewMinLodFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    minLod: uint32_t | boolean | Membuf
}
export interface VkImageViewMinLodCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    minLod: float | number | Membuf
}
export interface VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    rasterizationOrderColorAttachmentAccess: uint32_t | boolean | Membuf;
    rasterizationOrderDepthAttachmentAccess: uint32_t | boolean | Membuf;
    rasterizationOrderStencilAttachmentAccess: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    graphicsPipelineLibrary: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    graphicsPipelineLibraryFastLinking: uint32_t | boolean | Membuf;
    graphicsPipelineLibraryIndependentInterpolationDecoration: uint32_t | boolean | Membuf
}
export interface VkGraphicsPipelineLibraryCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    flags: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceShaderModuleIdentifierFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    shaderModuleIdentifier: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceShaderModuleIdentifierPropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    shaderModuleIdentifierAlgorithmUUID: uint8_t[] | null | Membuf
}
export interface VkPipelineShaderStageModuleIdentifierCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    identifierSize?: uint32_t | number | Membuf;
    pIdentifier: uint8_t[] | null | Membuf
}
export interface VkShaderModuleIdentifierEXTInput {
    pNext?: ptr64_t| null | Membuf;
    identifierSize: uint32_t | number | Membuf;
    identifier: uint8_t[] | null | Membuf
}
export interface VkImageCompressionControlEXTInput {
    pNext?: ptr64_t| null | Membuf;
    flags: uint32_t | number | Membuf;
    compressionControlPlaneCount?: uint32_t | number | Membuf;
    pFixedRateFlags: uint32_t[] | null | Membuf
}
export interface VkPhysicalDeviceImageCompressionControlFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    imageCompressionControl: uint32_t | boolean | Membuf
}
export interface VkImageCompressionPropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    imageCompressionFlags: uint32_t | number | Membuf;
    imageCompressionFixedRateFlags: uint32_t | number | Membuf
}
export interface VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    imageCompressionControlSwapchain: uint32_t | boolean | Membuf
}
export interface VkRenderPassCreationControlEXTInput {
    pNext?: ptr64_t| null | Membuf;
    disallowMerging: uint32_t | boolean | Membuf
}
export interface VkRenderPassCreationFeedbackInfoEXTInput {
    postMergeSubpassCount: uint32_t | number | Membuf
}
export interface VkRenderPassCreationFeedbackCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    pRenderPassFeedback: VkRenderPassCreationFeedbackInfoEXT| null | Membuf
}
export interface VkRenderPassSubpassFeedbackInfoEXTInput {
    subpassMergeStatus: int32_t | number | Membuf;
    description: char[] | null | Membuf;
    postMergeIndex: uint32_t | number | Membuf
}
export interface VkRenderPassSubpassFeedbackCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    pSubpassFeedback: VkRenderPassSubpassFeedbackInfoEXT| null | Membuf
}
export interface VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    subpassMergeFeedback: uint32_t | boolean | Membuf
}
export interface VkPipelinePropertiesIdentifierEXTInput {
    pNext?: ptr64_t| null | Membuf;
    pipelineIdentifier: uint8_t[] | null | Membuf
}
export interface VkPhysicalDevicePipelinePropertiesFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    pipelinePropertiesIdentifier: uint32_t | boolean | Membuf
}
export interface VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    nonSeamlessCubeMap: uint32_t | boolean | Membuf
}
export interface VkPhysicalDevicePipelineRobustnessFeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    pipelineRobustness: uint32_t | boolean | Membuf
}
export interface VkPipelineRobustnessCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    storageBuffers: int32_t | number | Membuf;
    uniformBuffers: int32_t | number | Membuf;
    vertexInputs: int32_t | number | Membuf;
    images: int32_t | number | Membuf
}
export interface VkPhysicalDevicePipelineRobustnessPropertiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    defaultRobustnessStorageBuffers: int32_t | number | Membuf;
    defaultRobustnessUniformBuffers: int32_t | number | Membuf;
    defaultRobustnessVertexInputs: int32_t | number | Membuf;
    defaultRobustnessImages: int32_t | number | Membuf
}
export interface VkSurfacePresentModeEXTInput {
    pNext?: ptr64_t| null | Membuf;
    presentMode: int32_t | number | Membuf
}
export interface VkSurfacePresentScalingCapabilitiesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    supportedPresentScaling?: uint32_t | number | Membuf;
    supportedPresentGravityX?: uint32_t | number | Membuf;
    supportedPresentGravityY?: uint32_t | number | Membuf;
    minScaledImageExtent?: VkExtent2D[] | Membuf;
    maxScaledImageExtent?: VkExtent2D[] | Membuf
}
export interface VkSurfacePresentModeCompatibilityEXTInput {
    pNext?: ptr64_t| null | Membuf;
    presentModeCount?: uint32_t | number | Membuf;
    pPresentModes?: int32_t[] | null | Membuf
}
export interface VkPhysicalDeviceSwapchainMaintenance1FeaturesEXTInput {
    pNext?: ptr64_t| null | Membuf;
    swapchainMaintenance1: uint32_t | boolean | Membuf
}
export interface VkSwapchainPresentFenceInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    swapchainCount: uint32_t | number | Membuf;
    pFences: ptr64_t[] | null | Membuf
}
export interface VkSwapchainPresentModesCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    presentModeCount: uint32_t | number | Membuf;
    pPresentModes: int32_t[] | null | Membuf
}
export interface VkSwapchainPresentModeInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    swapchainCount: uint32_t | number | Membuf;
    pPresentModes: int32_t[] | null | Membuf
}
export interface VkSwapchainPresentScalingCreateInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    scalingBehavior?: uint32_t | number | Membuf;
    presentGravityX?: uint32_t | number | Membuf;
    presentGravityY?: uint32_t | number | Membuf
}
export interface VkReleaseSwapchainImagesInfoEXTInput {
    pNext?: ptr64_t| null | Membuf;
    swapchain: ptr64_t | Membuf;
    imageIndexCount: uint32_t | number | Membuf;
    pImageIndices: uint32_t[] | null | Membuf
}
export class VkBaseOutStructure extends VkSerializable<VkBaseOutStructureInput, VkBaseOutStructureDeserialized> {
        public constructor(data: VkBaseOutStructureInput){ super(data, "VkBaseOutStructure"); }
    }
export class VkBaseInStructure extends VkSerializable<VkBaseInStructureInput, VkBaseInStructureDeserialized> {
        public constructor(data: VkBaseInStructureInput){ super(data, "VkBaseInStructure"); }
    }
export class VkOffset2D extends VkSerializable<VkOffset2DInput, VkOffset2DDeserialized> {
        public constructor(data: VkOffset2DInput){ super(data, "VkOffset2D"); }
    }
export class VkOffset3D extends VkSerializable<VkOffset3DInput, VkOffset3DDeserialized> {
        public constructor(data: VkOffset3DInput){ super(data, "VkOffset3D"); }
    }
export class VkExtent2D extends VkSerializable<VkExtent2DInput, VkExtent2DDeserialized> {
        public constructor(data: VkExtent2DInput){ super(data, "VkExtent2D"); }
    }
export class VkExtent3D extends VkSerializable<VkExtent3DInput, VkExtent3DDeserialized> {
        public constructor(data: VkExtent3DInput){ super(data, "VkExtent3D"); }
    }
export class VkViewport extends VkSerializable<VkViewportInput, VkViewportDeserialized> {
        public constructor(data: VkViewportInput){ super(data, "VkViewport"); }
    }
export class VkRect2D extends VkSerializable<VkRect2DInput, VkRect2DDeserialized> {
        public constructor(data: VkRect2DInput){ super(data, "VkRect2D"); }
    }
export class VkClearRect extends VkSerializable<VkClearRectInput, VkClearRectDeserialized> {
        public constructor(data: VkClearRectInput){ super(data, "VkClearRect"); }
    }
export class VkComponentMapping extends VkSerializable<VkComponentMappingInput, VkComponentMappingDeserialized> {
        public constructor(data: VkComponentMappingInput){ super(data, "VkComponentMapping"); }
    }
export class VkPhysicalDeviceProperties extends VkSerializable<VkPhysicalDevicePropertiesInput, VkPhysicalDevicePropertiesDeserialized> {
        public constructor(data: VkPhysicalDevicePropertiesInput){ super(data, "VkPhysicalDeviceProperties"); }
    }
export class VkExtensionProperties extends VkSerializable<VkExtensionPropertiesInput, VkExtensionPropertiesDeserialized> {
        public constructor(data: VkExtensionPropertiesInput){ super(data, "VkExtensionProperties"); }
    }
export class VkLayerProperties extends VkSerializable<VkLayerPropertiesInput, VkLayerPropertiesDeserialized> {
        public constructor(data: VkLayerPropertiesInput){ super(data, "VkLayerProperties"); }
    }
export class VkApplicationInfo extends VkSerializable<VkApplicationInfoInput, VkApplicationInfoDeserialized> {
        public constructor(data: VkApplicationInfoInput){ super(data, "VkApplicationInfo"); }
    }
export class VkAllocationCallbacks extends VkSerializable<VkAllocationCallbacksInput, VkAllocationCallbacksDeserialized> {
        public constructor(data: VkAllocationCallbacksInput){ super(data, "VkAllocationCallbacks"); }
    }
export class VkDeviceQueueCreateInfo extends VkSerializable<VkDeviceQueueCreateInfoInput, VkDeviceQueueCreateInfoDeserialized> {
        public constructor(data: VkDeviceQueueCreateInfoInput){ super(data, "VkDeviceQueueCreateInfo"); }
    }
export class VkDeviceCreateInfo extends VkSerializable<VkDeviceCreateInfoInput, VkDeviceCreateInfoDeserialized> {
        public constructor(data: VkDeviceCreateInfoInput){ super(data, "VkDeviceCreateInfo"); }
    }
export class VkInstanceCreateInfo extends VkSerializable<VkInstanceCreateInfoInput, VkInstanceCreateInfoDeserialized> {
        public constructor(data: VkInstanceCreateInfoInput){ super(data, "VkInstanceCreateInfo"); }
    }
export class VkQueueFamilyProperties extends VkSerializable<VkQueueFamilyPropertiesInput, VkQueueFamilyPropertiesDeserialized> {
        public constructor(data: VkQueueFamilyPropertiesInput){ super(data, "VkQueueFamilyProperties"); }
    }
export class VkPhysicalDeviceMemoryProperties extends VkSerializable<VkPhysicalDeviceMemoryPropertiesInput, VkPhysicalDeviceMemoryPropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceMemoryPropertiesInput){ super(data, "VkPhysicalDeviceMemoryProperties"); }
    }
export class VkMemoryAllocateInfo extends VkSerializable<VkMemoryAllocateInfoInput, VkMemoryAllocateInfoDeserialized> {
        public constructor(data: VkMemoryAllocateInfoInput){ super(data, "VkMemoryAllocateInfo"); }
    }
export class VkMemoryRequirements extends VkSerializable<VkMemoryRequirementsInput, VkMemoryRequirementsDeserialized> {
        public constructor(data: VkMemoryRequirementsInput){ super(data, "VkMemoryRequirements"); }
    }
export class VkSparseImageFormatProperties extends VkSerializable<VkSparseImageFormatPropertiesInput, VkSparseImageFormatPropertiesDeserialized> {
        public constructor(data: VkSparseImageFormatPropertiesInput){ super(data, "VkSparseImageFormatProperties"); }
    }
export class VkSparseImageMemoryRequirements extends VkSerializable<VkSparseImageMemoryRequirementsInput, VkSparseImageMemoryRequirementsDeserialized> {
        public constructor(data: VkSparseImageMemoryRequirementsInput){ super(data, "VkSparseImageMemoryRequirements"); }
    }
export class VkMemoryType extends VkSerializable<VkMemoryTypeInput, VkMemoryTypeDeserialized> {
        public constructor(data: VkMemoryTypeInput){ super(data, "VkMemoryType"); }
    }
export class VkMemoryHeap extends VkSerializable<VkMemoryHeapInput, VkMemoryHeapDeserialized> {
        public constructor(data: VkMemoryHeapInput){ super(data, "VkMemoryHeap"); }
    }
export class VkMappedMemoryRange extends VkSerializable<VkMappedMemoryRangeInput, VkMappedMemoryRangeDeserialized> {
        public constructor(data: VkMappedMemoryRangeInput){ super(data, "VkMappedMemoryRange"); }
    }
export class VkFormatProperties extends VkSerializable<VkFormatPropertiesInput, VkFormatPropertiesDeserialized> {
        public constructor(data: VkFormatPropertiesInput){ super(data, "VkFormatProperties"); }
    }
export class VkImageFormatProperties extends VkSerializable<VkImageFormatPropertiesInput, VkImageFormatPropertiesDeserialized> {
        public constructor(data: VkImageFormatPropertiesInput){ super(data, "VkImageFormatProperties"); }
    }
export class VkDescriptorBufferInfo extends VkSerializable<VkDescriptorBufferInfoInput, VkDescriptorBufferInfoDeserialized> {
        public constructor(data: VkDescriptorBufferInfoInput){ super(data, "VkDescriptorBufferInfo"); }
    }
export class VkDescriptorImageInfo extends VkSerializable<VkDescriptorImageInfoInput, VkDescriptorImageInfoDeserialized> {
        public constructor(data: VkDescriptorImageInfoInput){ super(data, "VkDescriptorImageInfo"); }
    }
export class VkWriteDescriptorSet extends VkSerializable<VkWriteDescriptorSetInput, VkWriteDescriptorSetDeserialized> {
        public constructor(data: VkWriteDescriptorSetInput){ super(data, "VkWriteDescriptorSet"); }
    }
export class VkCopyDescriptorSet extends VkSerializable<VkCopyDescriptorSetInput, VkCopyDescriptorSetDeserialized> {
        public constructor(data: VkCopyDescriptorSetInput){ super(data, "VkCopyDescriptorSet"); }
    }
export class VkBufferCreateInfo extends VkSerializable<VkBufferCreateInfoInput, VkBufferCreateInfoDeserialized> {
        public constructor(data: VkBufferCreateInfoInput){ super(data, "VkBufferCreateInfo"); }
    }
export class VkBufferViewCreateInfo extends VkSerializable<VkBufferViewCreateInfoInput, VkBufferViewCreateInfoDeserialized> {
        public constructor(data: VkBufferViewCreateInfoInput){ super(data, "VkBufferViewCreateInfo"); }
    }
export class VkImageSubresource extends VkSerializable<VkImageSubresourceInput, VkImageSubresourceDeserialized> {
        public constructor(data: VkImageSubresourceInput){ super(data, "VkImageSubresource"); }
    }
export class VkImageSubresourceLayers extends VkSerializable<VkImageSubresourceLayersInput, VkImageSubresourceLayersDeserialized> {
        public constructor(data: VkImageSubresourceLayersInput){ super(data, "VkImageSubresourceLayers"); }
    }
export class VkImageSubresourceRange extends VkSerializable<VkImageSubresourceRangeInput, VkImageSubresourceRangeDeserialized> {
        public constructor(data: VkImageSubresourceRangeInput){ super(data, "VkImageSubresourceRange"); }
    }
export class VkMemoryBarrier extends VkSerializable<VkMemoryBarrierInput, VkMemoryBarrierDeserialized> {
        public constructor(data: VkMemoryBarrierInput){ super(data, "VkMemoryBarrier"); }
    }
export class VkBufferMemoryBarrier extends VkSerializable<VkBufferMemoryBarrierInput, VkBufferMemoryBarrierDeserialized> {
        public constructor(data: VkBufferMemoryBarrierInput){ super(data, "VkBufferMemoryBarrier"); }
    }
export class VkImageMemoryBarrier extends VkSerializable<VkImageMemoryBarrierInput, VkImageMemoryBarrierDeserialized> {
        public constructor(data: VkImageMemoryBarrierInput){ super(data, "VkImageMemoryBarrier"); }
    }
export class VkImageCreateInfo extends VkSerializable<VkImageCreateInfoInput, VkImageCreateInfoDeserialized> {
        public constructor(data: VkImageCreateInfoInput){ super(data, "VkImageCreateInfo"); }
    }
export class VkSubresourceLayout extends VkSerializable<VkSubresourceLayoutInput, VkSubresourceLayoutDeserialized> {
        public constructor(data: VkSubresourceLayoutInput){ super(data, "VkSubresourceLayout"); }
    }
export class VkImageViewCreateInfo extends VkSerializable<VkImageViewCreateInfoInput, VkImageViewCreateInfoDeserialized> {
        public constructor(data: VkImageViewCreateInfoInput){ super(data, "VkImageViewCreateInfo"); }
    }
export class VkBufferCopy extends VkSerializable<VkBufferCopyInput, VkBufferCopyDeserialized> {
        public constructor(data: VkBufferCopyInput){ super(data, "VkBufferCopy"); }
    }
export class VkSparseMemoryBind extends VkSerializable<VkSparseMemoryBindInput, VkSparseMemoryBindDeserialized> {
        public constructor(data: VkSparseMemoryBindInput){ super(data, "VkSparseMemoryBind"); }
    }
export class VkSparseImageMemoryBind extends VkSerializable<VkSparseImageMemoryBindInput, VkSparseImageMemoryBindDeserialized> {
        public constructor(data: VkSparseImageMemoryBindInput){ super(data, "VkSparseImageMemoryBind"); }
    }
export class VkSparseBufferMemoryBindInfo extends VkSerializable<VkSparseBufferMemoryBindInfoInput, VkSparseBufferMemoryBindInfoDeserialized> {
        public constructor(data: VkSparseBufferMemoryBindInfoInput){ super(data, "VkSparseBufferMemoryBindInfo"); }
    }
export class VkSparseImageOpaqueMemoryBindInfo extends VkSerializable<VkSparseImageOpaqueMemoryBindInfoInput, VkSparseImageOpaqueMemoryBindInfoDeserialized> {
        public constructor(data: VkSparseImageOpaqueMemoryBindInfoInput){ super(data, "VkSparseImageOpaqueMemoryBindInfo"); }
    }
export class VkSparseImageMemoryBindInfo extends VkSerializable<VkSparseImageMemoryBindInfoInput, VkSparseImageMemoryBindInfoDeserialized> {
        public constructor(data: VkSparseImageMemoryBindInfoInput){ super(data, "VkSparseImageMemoryBindInfo"); }
    }
export class VkBindSparseInfo extends VkSerializable<VkBindSparseInfoInput, VkBindSparseInfoDeserialized> {
        public constructor(data: VkBindSparseInfoInput){ super(data, "VkBindSparseInfo"); }
    }
export class VkImageCopy extends VkSerializable<VkImageCopyInput, VkImageCopyDeserialized> {
        public constructor(data: VkImageCopyInput){ super(data, "VkImageCopy"); }
    }
export class VkImageBlit extends VkSerializable<VkImageBlitInput, VkImageBlitDeserialized> {
        public constructor(data: VkImageBlitInput){ super(data, "VkImageBlit"); }
    }
export class VkBufferImageCopy extends VkSerializable<VkBufferImageCopyInput, VkBufferImageCopyDeserialized> {
        public constructor(data: VkBufferImageCopyInput){ super(data, "VkBufferImageCopy"); }
    }
export class VkImageResolve extends VkSerializable<VkImageResolveInput, VkImageResolveDeserialized> {
        public constructor(data: VkImageResolveInput){ super(data, "VkImageResolve"); }
    }
export class VkShaderModuleCreateInfo extends VkSerializable<VkShaderModuleCreateInfoInput, VkShaderModuleCreateInfoDeserialized> {
        public constructor(data: VkShaderModuleCreateInfoInput){ super(data, "VkShaderModuleCreateInfo"); }
    }
export class VkDescriptorSetLayoutBinding extends VkSerializable<VkDescriptorSetLayoutBindingInput, VkDescriptorSetLayoutBindingDeserialized> {
        public constructor(data: VkDescriptorSetLayoutBindingInput){ super(data, "VkDescriptorSetLayoutBinding"); }
    }
export class VkDescriptorSetLayoutCreateInfo extends VkSerializable<VkDescriptorSetLayoutCreateInfoInput, VkDescriptorSetLayoutCreateInfoDeserialized> {
        public constructor(data: VkDescriptorSetLayoutCreateInfoInput){ super(data, "VkDescriptorSetLayoutCreateInfo"); }
    }
export class VkDescriptorPoolSize extends VkSerializable<VkDescriptorPoolSizeInput, VkDescriptorPoolSizeDeserialized> {
        public constructor(data: VkDescriptorPoolSizeInput){ super(data, "VkDescriptorPoolSize"); }
    }
export class VkDescriptorPoolCreateInfo extends VkSerializable<VkDescriptorPoolCreateInfoInput, VkDescriptorPoolCreateInfoDeserialized> {
        public constructor(data: VkDescriptorPoolCreateInfoInput){ super(data, "VkDescriptorPoolCreateInfo"); }
    }
export class VkDescriptorSetAllocateInfo extends VkSerializable<VkDescriptorSetAllocateInfoInput, VkDescriptorSetAllocateInfoDeserialized> {
        public constructor(data: VkDescriptorSetAllocateInfoInput){ super(data, "VkDescriptorSetAllocateInfo"); }
    }
export class VkSpecializationMapEntry extends VkSerializable<VkSpecializationMapEntryInput, VkSpecializationMapEntryDeserialized> {
        public constructor(data: VkSpecializationMapEntryInput){ super(data, "VkSpecializationMapEntry"); }
    }
export class VkSpecializationInfo extends VkSerializable<VkSpecializationInfoInput, VkSpecializationInfoDeserialized> {
        public constructor(data: VkSpecializationInfoInput){ super(data, "VkSpecializationInfo"); }
    }
export class VkPipelineShaderStageCreateInfo extends VkSerializable<VkPipelineShaderStageCreateInfoInput, VkPipelineShaderStageCreateInfoDeserialized> {
        public constructor(data: VkPipelineShaderStageCreateInfoInput){ super(data, "VkPipelineShaderStageCreateInfo"); }
    }
export class VkComputePipelineCreateInfo extends VkSerializable<VkComputePipelineCreateInfoInput, VkComputePipelineCreateInfoDeserialized> {
        public constructor(data: VkComputePipelineCreateInfoInput){ super(data, "VkComputePipelineCreateInfo"); }
    }
export class VkVertexInputBindingDescription extends VkSerializable<VkVertexInputBindingDescriptionInput, VkVertexInputBindingDescriptionDeserialized> {
        public constructor(data: VkVertexInputBindingDescriptionInput){ super(data, "VkVertexInputBindingDescription"); }
    }
export class VkVertexInputAttributeDescription extends VkSerializable<VkVertexInputAttributeDescriptionInput, VkVertexInputAttributeDescriptionDeserialized> {
        public constructor(data: VkVertexInputAttributeDescriptionInput){ super(data, "VkVertexInputAttributeDescription"); }
    }
export class VkPipelineVertexInputStateCreateInfo extends VkSerializable<VkPipelineVertexInputStateCreateInfoInput, VkPipelineVertexInputStateCreateInfoDeserialized> {
        public constructor(data: VkPipelineVertexInputStateCreateInfoInput){ super(data, "VkPipelineVertexInputStateCreateInfo"); }
    }
export class VkPipelineInputAssemblyStateCreateInfo extends VkSerializable<VkPipelineInputAssemblyStateCreateInfoInput, VkPipelineInputAssemblyStateCreateInfoDeserialized> {
        public constructor(data: VkPipelineInputAssemblyStateCreateInfoInput){ super(data, "VkPipelineInputAssemblyStateCreateInfo"); }
    }
export class VkPipelineTessellationStateCreateInfo extends VkSerializable<VkPipelineTessellationStateCreateInfoInput, VkPipelineTessellationStateCreateInfoDeserialized> {
        public constructor(data: VkPipelineTessellationStateCreateInfoInput){ super(data, "VkPipelineTessellationStateCreateInfo"); }
    }
export class VkPipelineViewportStateCreateInfo extends VkSerializable<VkPipelineViewportStateCreateInfoInput, VkPipelineViewportStateCreateInfoDeserialized> {
        public constructor(data: VkPipelineViewportStateCreateInfoInput){ super(data, "VkPipelineViewportStateCreateInfo"); }
    }
export class VkPipelineRasterizationStateCreateInfo extends VkSerializable<VkPipelineRasterizationStateCreateInfoInput, VkPipelineRasterizationStateCreateInfoDeserialized> {
        public constructor(data: VkPipelineRasterizationStateCreateInfoInput){ super(data, "VkPipelineRasterizationStateCreateInfo"); }
    }
export class VkPipelineMultisampleStateCreateInfo extends VkSerializable<VkPipelineMultisampleStateCreateInfoInput, VkPipelineMultisampleStateCreateInfoDeserialized> {
        public constructor(data: VkPipelineMultisampleStateCreateInfoInput){ super(data, "VkPipelineMultisampleStateCreateInfo"); }
    }
export class VkPipelineColorBlendAttachmentState extends VkSerializable<VkPipelineColorBlendAttachmentStateInput, VkPipelineColorBlendAttachmentStateDeserialized> {
        public constructor(data: VkPipelineColorBlendAttachmentStateInput){ super(data, "VkPipelineColorBlendAttachmentState"); }
    }
export class VkPipelineColorBlendStateCreateInfo extends VkSerializable<VkPipelineColorBlendStateCreateInfoInput, VkPipelineColorBlendStateCreateInfoDeserialized> {
        public constructor(data: VkPipelineColorBlendStateCreateInfoInput){ super(data, "VkPipelineColorBlendStateCreateInfo"); }
    }
export class VkPipelineDynamicStateCreateInfo extends VkSerializable<VkPipelineDynamicStateCreateInfoInput, VkPipelineDynamicStateCreateInfoDeserialized> {
        public constructor(data: VkPipelineDynamicStateCreateInfoInput){ super(data, "VkPipelineDynamicStateCreateInfo"); }
    }
export class VkStencilOpState extends VkSerializable<VkStencilOpStateInput, VkStencilOpStateDeserialized> {
        public constructor(data: VkStencilOpStateInput){ super(data, "VkStencilOpState"); }
    }
export class VkPipelineDepthStencilStateCreateInfo extends VkSerializable<VkPipelineDepthStencilStateCreateInfoInput, VkPipelineDepthStencilStateCreateInfoDeserialized> {
        public constructor(data: VkPipelineDepthStencilStateCreateInfoInput){ super(data, "VkPipelineDepthStencilStateCreateInfo"); }
    }
export class VkGraphicsPipelineCreateInfo extends VkSerializable<VkGraphicsPipelineCreateInfoInput, VkGraphicsPipelineCreateInfoDeserialized> {
        public constructor(data: VkGraphicsPipelineCreateInfoInput){ super(data, "VkGraphicsPipelineCreateInfo"); }
    }
export class VkPipelineCacheCreateInfo extends VkSerializable<VkPipelineCacheCreateInfoInput, VkPipelineCacheCreateInfoDeserialized> {
        public constructor(data: VkPipelineCacheCreateInfoInput){ super(data, "VkPipelineCacheCreateInfo"); }
    }
export class VkPipelineCacheHeaderVersionOne extends VkSerializable<VkPipelineCacheHeaderVersionOneInput, VkPipelineCacheHeaderVersionOneDeserialized> {
        public constructor(data: VkPipelineCacheHeaderVersionOneInput){ super(data, "VkPipelineCacheHeaderVersionOne"); }
    }
export class VkPushConstantRange extends VkSerializable<VkPushConstantRangeInput, VkPushConstantRangeDeserialized> {
        public constructor(data: VkPushConstantRangeInput){ super(data, "VkPushConstantRange"); }
    }
export class VkPipelineLayoutCreateInfo extends VkSerializable<VkPipelineLayoutCreateInfoInput, VkPipelineLayoutCreateInfoDeserialized> {
        public constructor(data: VkPipelineLayoutCreateInfoInput){ super(data, "VkPipelineLayoutCreateInfo"); }
    }
export class VkSamplerCreateInfo extends VkSerializable<VkSamplerCreateInfoInput, VkSamplerCreateInfoDeserialized> {
        public constructor(data: VkSamplerCreateInfoInput){ super(data, "VkSamplerCreateInfo"); }
    }
export class VkCommandPoolCreateInfo extends VkSerializable<VkCommandPoolCreateInfoInput, VkCommandPoolCreateInfoDeserialized> {
        public constructor(data: VkCommandPoolCreateInfoInput){ super(data, "VkCommandPoolCreateInfo"); }
    }
export class VkCommandBufferAllocateInfo extends VkSerializable<VkCommandBufferAllocateInfoInput, VkCommandBufferAllocateInfoDeserialized> {
        public constructor(data: VkCommandBufferAllocateInfoInput){ super(data, "VkCommandBufferAllocateInfo"); }
    }
export class VkCommandBufferInheritanceInfo extends VkSerializable<VkCommandBufferInheritanceInfoInput, VkCommandBufferInheritanceInfoDeserialized> {
        public constructor(data: VkCommandBufferInheritanceInfoInput){ super(data, "VkCommandBufferInheritanceInfo"); }
    }
export class VkCommandBufferBeginInfo extends VkSerializable<VkCommandBufferBeginInfoInput, VkCommandBufferBeginInfoDeserialized> {
        public constructor(data: VkCommandBufferBeginInfoInput){ super(data, "VkCommandBufferBeginInfo"); }
    }
export class VkRenderPassBeginInfo extends VkSerializable<VkRenderPassBeginInfoInput, VkRenderPassBeginInfoDeserialized> {
        public constructor(data: VkRenderPassBeginInfoInput){ super(data, "VkRenderPassBeginInfo"); }
    }
export class VkClearDepthStencilValue extends VkSerializable<VkClearDepthStencilValueInput, VkClearDepthStencilValueDeserialized> {
        public constructor(data: VkClearDepthStencilValueInput){ super(data, "VkClearDepthStencilValue"); }
    }
export class VkClearAttachment extends VkSerializable<VkClearAttachmentInput, VkClearAttachmentDeserialized> {
        public constructor(data: VkClearAttachmentInput){ super(data, "VkClearAttachment"); }
    }
export class VkAttachmentDescription extends VkSerializable<VkAttachmentDescriptionInput, VkAttachmentDescriptionDeserialized> {
        public constructor(data: VkAttachmentDescriptionInput){ super(data, "VkAttachmentDescription"); }
    }
export class VkAttachmentReference extends VkSerializable<VkAttachmentReferenceInput, VkAttachmentReferenceDeserialized> {
        public constructor(data: VkAttachmentReferenceInput){ super(data, "VkAttachmentReference"); }
    }
export class VkSubpassDescription extends VkSerializable<VkSubpassDescriptionInput, VkSubpassDescriptionDeserialized> {
        public constructor(data: VkSubpassDescriptionInput){ super(data, "VkSubpassDescription"); }
    }
export class VkSubpassDependency extends VkSerializable<VkSubpassDependencyInput, VkSubpassDependencyDeserialized> {
        public constructor(data: VkSubpassDependencyInput){ super(data, "VkSubpassDependency"); }
    }
export class VkRenderPassCreateInfo extends VkSerializable<VkRenderPassCreateInfoInput, VkRenderPassCreateInfoDeserialized> {
        public constructor(data: VkRenderPassCreateInfoInput){ super(data, "VkRenderPassCreateInfo"); }
    }
export class VkEventCreateInfo extends VkSerializable<VkEventCreateInfoInput, VkEventCreateInfoDeserialized> {
        public constructor(data: VkEventCreateInfoInput){ super(data, "VkEventCreateInfo"); }
    }
export class VkFenceCreateInfo extends VkSerializable<VkFenceCreateInfoInput, VkFenceCreateInfoDeserialized> {
        public constructor(data: VkFenceCreateInfoInput){ super(data, "VkFenceCreateInfo"); }
    }
export class VkPhysicalDeviceFeatures extends VkSerializable<VkPhysicalDeviceFeaturesInput, VkPhysicalDeviceFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceFeaturesInput){ super(data, "VkPhysicalDeviceFeatures"); }
    }
export class VkPhysicalDeviceSparseProperties extends VkSerializable<VkPhysicalDeviceSparsePropertiesInput, VkPhysicalDeviceSparsePropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceSparsePropertiesInput){ super(data, "VkPhysicalDeviceSparseProperties"); }
    }
export class VkPhysicalDeviceLimits extends VkSerializable<VkPhysicalDeviceLimitsInput, VkPhysicalDeviceLimitsDeserialized> {
        public constructor(data: VkPhysicalDeviceLimitsInput){ super(data, "VkPhysicalDeviceLimits"); }
    }
export class VkSemaphoreCreateInfo extends VkSerializable<VkSemaphoreCreateInfoInput, VkSemaphoreCreateInfoDeserialized> {
        public constructor(data: VkSemaphoreCreateInfoInput){ super(data, "VkSemaphoreCreateInfo"); }
    }
export class VkQueryPoolCreateInfo extends VkSerializable<VkQueryPoolCreateInfoInput, VkQueryPoolCreateInfoDeserialized> {
        public constructor(data: VkQueryPoolCreateInfoInput){ super(data, "VkQueryPoolCreateInfo"); }
    }
export class VkFramebufferCreateInfo extends VkSerializable<VkFramebufferCreateInfoInput, VkFramebufferCreateInfoDeserialized> {
        public constructor(data: VkFramebufferCreateInfoInput){ super(data, "VkFramebufferCreateInfo"); }
    }
export class VkDrawIndirectCommand extends VkSerializable<VkDrawIndirectCommandInput, VkDrawIndirectCommandDeserialized> {
        public constructor(data: VkDrawIndirectCommandInput){ super(data, "VkDrawIndirectCommand"); }
    }
export class VkDrawIndexedIndirectCommand extends VkSerializable<VkDrawIndexedIndirectCommandInput, VkDrawIndexedIndirectCommandDeserialized> {
        public constructor(data: VkDrawIndexedIndirectCommandInput){ super(data, "VkDrawIndexedIndirectCommand"); }
    }
export class VkDispatchIndirectCommand extends VkSerializable<VkDispatchIndirectCommandInput, VkDispatchIndirectCommandDeserialized> {
        public constructor(data: VkDispatchIndirectCommandInput){ super(data, "VkDispatchIndirectCommand"); }
    }
export class VkMultiDrawInfoEXT extends VkSerializable<VkMultiDrawInfoEXTInput, VkMultiDrawInfoEXTDeserialized> {
        public constructor(data: VkMultiDrawInfoEXTInput){ super(data, "VkMultiDrawInfoEXT"); }
    }
export class VkMultiDrawIndexedInfoEXT extends VkSerializable<VkMultiDrawIndexedInfoEXTInput, VkMultiDrawIndexedInfoEXTDeserialized> {
        public constructor(data: VkMultiDrawIndexedInfoEXTInput){ super(data, "VkMultiDrawIndexedInfoEXT"); }
    }
export class VkSubmitInfo extends VkSerializable<VkSubmitInfoInput, VkSubmitInfoDeserialized> {
        public constructor(data: VkSubmitInfoInput){ super(data, "VkSubmitInfo"); }
    }
export class VkDisplayPropertiesKHR extends VkSerializable<VkDisplayPropertiesKHRInput, VkDisplayPropertiesKHRDeserialized> {
        public constructor(data: VkDisplayPropertiesKHRInput){ super(data, "VkDisplayPropertiesKHR"); }
    }
export class VkDisplayPlanePropertiesKHR extends VkSerializable<VkDisplayPlanePropertiesKHRInput, VkDisplayPlanePropertiesKHRDeserialized> {
        public constructor(data: VkDisplayPlanePropertiesKHRInput){ super(data, "VkDisplayPlanePropertiesKHR"); }
    }
export class VkDisplayModeParametersKHR extends VkSerializable<VkDisplayModeParametersKHRInput, VkDisplayModeParametersKHRDeserialized> {
        public constructor(data: VkDisplayModeParametersKHRInput){ super(data, "VkDisplayModeParametersKHR"); }
    }
export class VkDisplayModePropertiesKHR extends VkSerializable<VkDisplayModePropertiesKHRInput, VkDisplayModePropertiesKHRDeserialized> {
        public constructor(data: VkDisplayModePropertiesKHRInput){ super(data, "VkDisplayModePropertiesKHR"); }
    }
export class VkDisplayModeCreateInfoKHR extends VkSerializable<VkDisplayModeCreateInfoKHRInput, VkDisplayModeCreateInfoKHRDeserialized> {
        public constructor(data: VkDisplayModeCreateInfoKHRInput){ super(data, "VkDisplayModeCreateInfoKHR"); }
    }
export class VkDisplayPlaneCapabilitiesKHR extends VkSerializable<VkDisplayPlaneCapabilitiesKHRInput, VkDisplayPlaneCapabilitiesKHRDeserialized> {
        public constructor(data: VkDisplayPlaneCapabilitiesKHRInput){ super(data, "VkDisplayPlaneCapabilitiesKHR"); }
    }
export class VkDisplaySurfaceCreateInfoKHR extends VkSerializable<VkDisplaySurfaceCreateInfoKHRInput, VkDisplaySurfaceCreateInfoKHRDeserialized> {
        public constructor(data: VkDisplaySurfaceCreateInfoKHRInput){ super(data, "VkDisplaySurfaceCreateInfoKHR"); }
    }
export class VkDisplayPresentInfoKHR extends VkSerializable<VkDisplayPresentInfoKHRInput, VkDisplayPresentInfoKHRDeserialized> {
        public constructor(data: VkDisplayPresentInfoKHRInput){ super(data, "VkDisplayPresentInfoKHR"); }
    }
export class VkSurfaceCapabilitiesKHR extends VkSerializable<VkSurfaceCapabilitiesKHRInput, VkSurfaceCapabilitiesKHRDeserialized> {
        public constructor(data: VkSurfaceCapabilitiesKHRInput){ super(data, "VkSurfaceCapabilitiesKHR"); }
    }
export class VkSurfaceFormatKHR extends VkSerializable<VkSurfaceFormatKHRInput, VkSurfaceFormatKHRDeserialized> {
        public constructor(data: VkSurfaceFormatKHRInput){ super(data, "VkSurfaceFormatKHR"); }
    }
export class VkSwapchainCreateInfoKHR extends VkSerializable<VkSwapchainCreateInfoKHRInput, VkSwapchainCreateInfoKHRDeserialized> {
        public constructor(data: VkSwapchainCreateInfoKHRInput){ super(data, "VkSwapchainCreateInfoKHR"); }
    }
export class VkPresentInfoKHR extends VkSerializable<VkPresentInfoKHRInput, VkPresentInfoKHRDeserialized> {
        public constructor(data: VkPresentInfoKHRInput){ super(data, "VkPresentInfoKHR"); }
    }
export class VkValidationFlagsEXT extends VkSerializable<VkValidationFlagsEXTInput, VkValidationFlagsEXTDeserialized> {
        public constructor(data: VkValidationFlagsEXTInput){ super(data, "VkValidationFlagsEXT"); }
    }
export class VkValidationFeaturesEXT extends VkSerializable<VkValidationFeaturesEXTInput, VkValidationFeaturesEXTDeserialized> {
        public constructor(data: VkValidationFeaturesEXTInput){ super(data, "VkValidationFeaturesEXT"); }
    }
export class VkDevicePrivateDataCreateInfo extends VkSerializable<VkDevicePrivateDataCreateInfoInput, VkDevicePrivateDataCreateInfoDeserialized> {
        public constructor(data: VkDevicePrivateDataCreateInfoInput){ super(data, "VkDevicePrivateDataCreateInfo"); }
    }
export class VkDevicePrivateDataCreateInfoEXT extends VkSerializable<VkDevicePrivateDataCreateInfoEXTInput, VkDevicePrivateDataCreateInfoEXTDeserialized> {
        public constructor(data: VkDevicePrivateDataCreateInfoEXTInput){ super(data, "VkDevicePrivateDataCreateInfoEXT"); }
    }
export class VkPrivateDataSlotCreateInfo extends VkSerializable<VkPrivateDataSlotCreateInfoInput, VkPrivateDataSlotCreateInfoDeserialized> {
        public constructor(data: VkPrivateDataSlotCreateInfoInput){ super(data, "VkPrivateDataSlotCreateInfo"); }
    }
export class VkPrivateDataSlotCreateInfoEXT extends VkSerializable<VkPrivateDataSlotCreateInfoEXTInput, VkPrivateDataSlotCreateInfoEXTDeserialized> {
        public constructor(data: VkPrivateDataSlotCreateInfoEXTInput){ super(data, "VkPrivateDataSlotCreateInfoEXT"); }
    }
export class VkPhysicalDevicePrivateDataFeatures extends VkSerializable<VkPhysicalDevicePrivateDataFeaturesInput, VkPhysicalDevicePrivateDataFeaturesDeserialized> {
        public constructor(data: VkPhysicalDevicePrivateDataFeaturesInput){ super(data, "VkPhysicalDevicePrivateDataFeatures"); }
    }
export class VkPhysicalDevicePrivateDataFeaturesEXT extends VkSerializable<VkPhysicalDevicePrivateDataFeaturesEXTInput, VkPhysicalDevicePrivateDataFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDevicePrivateDataFeaturesEXTInput){ super(data, "VkPhysicalDevicePrivateDataFeaturesEXT"); }
    }
export class VkPhysicalDeviceMultiDrawPropertiesEXT extends VkSerializable<VkPhysicalDeviceMultiDrawPropertiesEXTInput, VkPhysicalDeviceMultiDrawPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceMultiDrawPropertiesEXTInput){ super(data, "VkPhysicalDeviceMultiDrawPropertiesEXT"); }
    }
export class VkPhysicalDeviceFeatures2 extends VkSerializable<VkPhysicalDeviceFeatures2Input, VkPhysicalDeviceFeatures2Deserialized> {
        public constructor(data: VkPhysicalDeviceFeatures2Input){ super(data, "VkPhysicalDeviceFeatures2"); }
    }
export class VkPhysicalDeviceFeatures2KHR extends VkSerializable<VkPhysicalDeviceFeatures2KHRInput, VkPhysicalDeviceFeatures2KHRDeserialized> {
        public constructor(data: VkPhysicalDeviceFeatures2KHRInput){ super(data, "VkPhysicalDeviceFeatures2KHR"); }
    }
export class VkPhysicalDeviceProperties2 extends VkSerializable<VkPhysicalDeviceProperties2Input, VkPhysicalDeviceProperties2Deserialized> {
        public constructor(data: VkPhysicalDeviceProperties2Input){ super(data, "VkPhysicalDeviceProperties2"); }
    }
export class VkPhysicalDeviceProperties2KHR extends VkSerializable<VkPhysicalDeviceProperties2KHRInput, VkPhysicalDeviceProperties2KHRDeserialized> {
        public constructor(data: VkPhysicalDeviceProperties2KHRInput){ super(data, "VkPhysicalDeviceProperties2KHR"); }
    }
export class VkFormatProperties2 extends VkSerializable<VkFormatProperties2Input, VkFormatProperties2Deserialized> {
        public constructor(data: VkFormatProperties2Input){ super(data, "VkFormatProperties2"); }
    }
export class VkFormatProperties2KHR extends VkSerializable<VkFormatProperties2KHRInput, VkFormatProperties2KHRDeserialized> {
        public constructor(data: VkFormatProperties2KHRInput){ super(data, "VkFormatProperties2KHR"); }
    }
export class VkImageFormatProperties2 extends VkSerializable<VkImageFormatProperties2Input, VkImageFormatProperties2Deserialized> {
        public constructor(data: VkImageFormatProperties2Input){ super(data, "VkImageFormatProperties2"); }
    }
export class VkImageFormatProperties2KHR extends VkSerializable<VkImageFormatProperties2KHRInput, VkImageFormatProperties2KHRDeserialized> {
        public constructor(data: VkImageFormatProperties2KHRInput){ super(data, "VkImageFormatProperties2KHR"); }
    }
export class VkPhysicalDeviceImageFormatInfo2 extends VkSerializable<VkPhysicalDeviceImageFormatInfo2Input, VkPhysicalDeviceImageFormatInfo2Deserialized> {
        public constructor(data: VkPhysicalDeviceImageFormatInfo2Input){ super(data, "VkPhysicalDeviceImageFormatInfo2"); }
    }
export class VkPhysicalDeviceImageFormatInfo2KHR extends VkSerializable<VkPhysicalDeviceImageFormatInfo2KHRInput, VkPhysicalDeviceImageFormatInfo2KHRDeserialized> {
        public constructor(data: VkPhysicalDeviceImageFormatInfo2KHRInput){ super(data, "VkPhysicalDeviceImageFormatInfo2KHR"); }
    }
export class VkQueueFamilyProperties2 extends VkSerializable<VkQueueFamilyProperties2Input, VkQueueFamilyProperties2Deserialized> {
        public constructor(data: VkQueueFamilyProperties2Input){ super(data, "VkQueueFamilyProperties2"); }
    }
export class VkQueueFamilyProperties2KHR extends VkSerializable<VkQueueFamilyProperties2KHRInput, VkQueueFamilyProperties2KHRDeserialized> {
        public constructor(data: VkQueueFamilyProperties2KHRInput){ super(data, "VkQueueFamilyProperties2KHR"); }
    }
export class VkPhysicalDeviceMemoryProperties2 extends VkSerializable<VkPhysicalDeviceMemoryProperties2Input, VkPhysicalDeviceMemoryProperties2Deserialized> {
        public constructor(data: VkPhysicalDeviceMemoryProperties2Input){ super(data, "VkPhysicalDeviceMemoryProperties2"); }
    }
export class VkPhysicalDeviceMemoryProperties2KHR extends VkSerializable<VkPhysicalDeviceMemoryProperties2KHRInput, VkPhysicalDeviceMemoryProperties2KHRDeserialized> {
        public constructor(data: VkPhysicalDeviceMemoryProperties2KHRInput){ super(data, "VkPhysicalDeviceMemoryProperties2KHR"); }
    }
export class VkSparseImageFormatProperties2 extends VkSerializable<VkSparseImageFormatProperties2Input, VkSparseImageFormatProperties2Deserialized> {
        public constructor(data: VkSparseImageFormatProperties2Input){ super(data, "VkSparseImageFormatProperties2"); }
    }
export class VkSparseImageFormatProperties2KHR extends VkSerializable<VkSparseImageFormatProperties2KHRInput, VkSparseImageFormatProperties2KHRDeserialized> {
        public constructor(data: VkSparseImageFormatProperties2KHRInput){ super(data, "VkSparseImageFormatProperties2KHR"); }
    }
export class VkPhysicalDeviceSparseImageFormatInfo2 extends VkSerializable<VkPhysicalDeviceSparseImageFormatInfo2Input, VkPhysicalDeviceSparseImageFormatInfo2Deserialized> {
        public constructor(data: VkPhysicalDeviceSparseImageFormatInfo2Input){ super(data, "VkPhysicalDeviceSparseImageFormatInfo2"); }
    }
export class VkPhysicalDeviceSparseImageFormatInfo2KHR extends VkSerializable<VkPhysicalDeviceSparseImageFormatInfo2KHRInput, VkPhysicalDeviceSparseImageFormatInfo2KHRDeserialized> {
        public constructor(data: VkPhysicalDeviceSparseImageFormatInfo2KHRInput){ super(data, "VkPhysicalDeviceSparseImageFormatInfo2KHR"); }
    }
export class VkPhysicalDevicePushDescriptorPropertiesKHR extends VkSerializable<VkPhysicalDevicePushDescriptorPropertiesKHRInput, VkPhysicalDevicePushDescriptorPropertiesKHRDeserialized> {
        public constructor(data: VkPhysicalDevicePushDescriptorPropertiesKHRInput){ super(data, "VkPhysicalDevicePushDescriptorPropertiesKHR"); }
    }
export class VkConformanceVersion extends VkSerializable<VkConformanceVersionInput, VkConformanceVersionDeserialized> {
        public constructor(data: VkConformanceVersionInput){ super(data, "VkConformanceVersion"); }
    }
export class VkConformanceVersionKHR extends VkSerializable<VkConformanceVersionKHRInput, VkConformanceVersionKHRDeserialized> {
        public constructor(data: VkConformanceVersionKHRInput){ super(data, "VkConformanceVersionKHR"); }
    }
export class VkPhysicalDeviceDriverProperties extends VkSerializable<VkPhysicalDeviceDriverPropertiesInput, VkPhysicalDeviceDriverPropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceDriverPropertiesInput){ super(data, "VkPhysicalDeviceDriverProperties"); }
    }
export class VkPhysicalDeviceDriverPropertiesKHR extends VkSerializable<VkPhysicalDeviceDriverPropertiesKHRInput, VkPhysicalDeviceDriverPropertiesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceDriverPropertiesKHRInput){ super(data, "VkPhysicalDeviceDriverPropertiesKHR"); }
    }
export class VkPresentRegionsKHR extends VkSerializable<VkPresentRegionsKHRInput, VkPresentRegionsKHRDeserialized> {
        public constructor(data: VkPresentRegionsKHRInput){ super(data, "VkPresentRegionsKHR"); }
    }
export class VkPresentRegionKHR extends VkSerializable<VkPresentRegionKHRInput, VkPresentRegionKHRDeserialized> {
        public constructor(data: VkPresentRegionKHRInput){ super(data, "VkPresentRegionKHR"); }
    }
export class VkRectLayerKHR extends VkSerializable<VkRectLayerKHRInput, VkRectLayerKHRDeserialized> {
        public constructor(data: VkRectLayerKHRInput){ super(data, "VkRectLayerKHR"); }
    }
export class VkPhysicalDeviceVariablePointersFeatures extends VkSerializable<VkPhysicalDeviceVariablePointersFeaturesInput, VkPhysicalDeviceVariablePointersFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceVariablePointersFeaturesInput){ super(data, "VkPhysicalDeviceVariablePointersFeatures"); }
    }
export class VkPhysicalDeviceVariablePointersFeaturesKHR extends VkSerializable<VkPhysicalDeviceVariablePointersFeaturesKHRInput, VkPhysicalDeviceVariablePointersFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceVariablePointersFeaturesKHRInput){ super(data, "VkPhysicalDeviceVariablePointersFeaturesKHR"); }
    }
export class VkPhysicalDeviceVariablePointerFeaturesKHR extends VkSerializable<VkPhysicalDeviceVariablePointerFeaturesKHRInput, VkPhysicalDeviceVariablePointerFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceVariablePointerFeaturesKHRInput){ super(data, "VkPhysicalDeviceVariablePointerFeaturesKHR"); }
    }
export class VkPhysicalDeviceVariablePointerFeatures extends VkSerializable<VkPhysicalDeviceVariablePointerFeaturesInput, VkPhysicalDeviceVariablePointerFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceVariablePointerFeaturesInput){ super(data, "VkPhysicalDeviceVariablePointerFeatures"); }
    }
export class VkExternalMemoryProperties extends VkSerializable<VkExternalMemoryPropertiesInput, VkExternalMemoryPropertiesDeserialized> {
        public constructor(data: VkExternalMemoryPropertiesInput){ super(data, "VkExternalMemoryProperties"); }
    }
export class VkPhysicalDeviceExternalImageFormatInfo extends VkSerializable<VkPhysicalDeviceExternalImageFormatInfoInput, VkPhysicalDeviceExternalImageFormatInfoDeserialized> {
        public constructor(data: VkPhysicalDeviceExternalImageFormatInfoInput){ super(data, "VkPhysicalDeviceExternalImageFormatInfo"); }
    }
export class VkExternalImageFormatProperties extends VkSerializable<VkExternalImageFormatPropertiesInput, VkExternalImageFormatPropertiesDeserialized> {
        public constructor(data: VkExternalImageFormatPropertiesInput){ super(data, "VkExternalImageFormatProperties"); }
    }
export class VkPhysicalDeviceExternalBufferInfo extends VkSerializable<VkPhysicalDeviceExternalBufferInfoInput, VkPhysicalDeviceExternalBufferInfoDeserialized> {
        public constructor(data: VkPhysicalDeviceExternalBufferInfoInput){ super(data, "VkPhysicalDeviceExternalBufferInfo"); }
    }
export class VkExternalBufferProperties extends VkSerializable<VkExternalBufferPropertiesInput, VkExternalBufferPropertiesDeserialized> {
        public constructor(data: VkExternalBufferPropertiesInput){ super(data, "VkExternalBufferProperties"); }
    }
export class VkPhysicalDeviceIDProperties extends VkSerializable<VkPhysicalDeviceIDPropertiesInput, VkPhysicalDeviceIDPropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceIDPropertiesInput){ super(data, "VkPhysicalDeviceIDProperties"); }
    }
export class VkExternalMemoryImageCreateInfo extends VkSerializable<VkExternalMemoryImageCreateInfoInput, VkExternalMemoryImageCreateInfoDeserialized> {
        public constructor(data: VkExternalMemoryImageCreateInfoInput){ super(data, "VkExternalMemoryImageCreateInfo"); }
    }
export class VkExternalMemoryBufferCreateInfo extends VkSerializable<VkExternalMemoryBufferCreateInfoInput, VkExternalMemoryBufferCreateInfoDeserialized> {
        public constructor(data: VkExternalMemoryBufferCreateInfoInput){ super(data, "VkExternalMemoryBufferCreateInfo"); }
    }
export class VkExportMemoryAllocateInfo extends VkSerializable<VkExportMemoryAllocateInfoInput, VkExportMemoryAllocateInfoDeserialized> {
        public constructor(data: VkExportMemoryAllocateInfoInput){ super(data, "VkExportMemoryAllocateInfo"); }
    }
export class VkPhysicalDeviceExternalSemaphoreInfo extends VkSerializable<VkPhysicalDeviceExternalSemaphoreInfoInput, VkPhysicalDeviceExternalSemaphoreInfoDeserialized> {
        public constructor(data: VkPhysicalDeviceExternalSemaphoreInfoInput){ super(data, "VkPhysicalDeviceExternalSemaphoreInfo"); }
    }
export class VkExternalSemaphoreProperties extends VkSerializable<VkExternalSemaphorePropertiesInput, VkExternalSemaphorePropertiesDeserialized> {
        public constructor(data: VkExternalSemaphorePropertiesInput){ super(data, "VkExternalSemaphoreProperties"); }
    }
export class VkExportSemaphoreCreateInfo extends VkSerializable<VkExportSemaphoreCreateInfoInput, VkExportSemaphoreCreateInfoDeserialized> {
        public constructor(data: VkExportSemaphoreCreateInfoInput){ super(data, "VkExportSemaphoreCreateInfo"); }
    }
export class VkPhysicalDeviceExternalFenceInfo extends VkSerializable<VkPhysicalDeviceExternalFenceInfoInput, VkPhysicalDeviceExternalFenceInfoDeserialized> {
        public constructor(data: VkPhysicalDeviceExternalFenceInfoInput){ super(data, "VkPhysicalDeviceExternalFenceInfo"); }
    }
export class VkExternalFenceProperties extends VkSerializable<VkExternalFencePropertiesInput, VkExternalFencePropertiesDeserialized> {
        public constructor(data: VkExternalFencePropertiesInput){ super(data, "VkExternalFenceProperties"); }
    }
export class VkExportFenceCreateInfo extends VkSerializable<VkExportFenceCreateInfoInput, VkExportFenceCreateInfoDeserialized> {
        public constructor(data: VkExportFenceCreateInfoInput){ super(data, "VkExportFenceCreateInfo"); }
    }
export class VkPhysicalDeviceMultiviewFeatures extends VkSerializable<VkPhysicalDeviceMultiviewFeaturesInput, VkPhysicalDeviceMultiviewFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceMultiviewFeaturesInput){ super(data, "VkPhysicalDeviceMultiviewFeatures"); }
    }
export class VkPhysicalDeviceMultiviewFeaturesKHR extends VkSerializable<VkPhysicalDeviceMultiviewFeaturesKHRInput, VkPhysicalDeviceMultiviewFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceMultiviewFeaturesKHRInput){ super(data, "VkPhysicalDeviceMultiviewFeaturesKHR"); }
    }
export class VkPhysicalDeviceMultiviewProperties extends VkSerializable<VkPhysicalDeviceMultiviewPropertiesInput, VkPhysicalDeviceMultiviewPropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceMultiviewPropertiesInput){ super(data, "VkPhysicalDeviceMultiviewProperties"); }
    }
export class VkPhysicalDeviceMultiviewPropertiesKHR extends VkSerializable<VkPhysicalDeviceMultiviewPropertiesKHRInput, VkPhysicalDeviceMultiviewPropertiesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceMultiviewPropertiesKHRInput){ super(data, "VkPhysicalDeviceMultiviewPropertiesKHR"); }
    }
export class VkRenderPassMultiviewCreateInfo extends VkSerializable<VkRenderPassMultiviewCreateInfoInput, VkRenderPassMultiviewCreateInfoDeserialized> {
        public constructor(data: VkRenderPassMultiviewCreateInfoInput){ super(data, "VkRenderPassMultiviewCreateInfo"); }
    }
export class VkRenderPassMultiviewCreateInfoKHR extends VkSerializable<VkRenderPassMultiviewCreateInfoKHRInput, VkRenderPassMultiviewCreateInfoKHRDeserialized> {
        public constructor(data: VkRenderPassMultiviewCreateInfoKHRInput){ super(data, "VkRenderPassMultiviewCreateInfoKHR"); }
    }
export class VkPhysicalDeviceGroupProperties extends VkSerializable<VkPhysicalDeviceGroupPropertiesInput, VkPhysicalDeviceGroupPropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceGroupPropertiesInput){ super(data, "VkPhysicalDeviceGroupProperties"); }
    }
export class VkPhysicalDeviceGroupPropertiesKHR extends VkSerializable<VkPhysicalDeviceGroupPropertiesKHRInput, VkPhysicalDeviceGroupPropertiesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceGroupPropertiesKHRInput){ super(data, "VkPhysicalDeviceGroupPropertiesKHR"); }
    }
export class VkMemoryAllocateFlagsInfo extends VkSerializable<VkMemoryAllocateFlagsInfoInput, VkMemoryAllocateFlagsInfoDeserialized> {
        public constructor(data: VkMemoryAllocateFlagsInfoInput){ super(data, "VkMemoryAllocateFlagsInfo"); }
    }
export class VkMemoryAllocateFlagsInfoKHR extends VkSerializable<VkMemoryAllocateFlagsInfoKHRInput, VkMemoryAllocateFlagsInfoKHRDeserialized> {
        public constructor(data: VkMemoryAllocateFlagsInfoKHRInput){ super(data, "VkMemoryAllocateFlagsInfoKHR"); }
    }
export class VkBindBufferMemoryInfo extends VkSerializable<VkBindBufferMemoryInfoInput, VkBindBufferMemoryInfoDeserialized> {
        public constructor(data: VkBindBufferMemoryInfoInput){ super(data, "VkBindBufferMemoryInfo"); }
    }
export class VkBindBufferMemoryInfoKHR extends VkSerializable<VkBindBufferMemoryInfoKHRInput, VkBindBufferMemoryInfoKHRDeserialized> {
        public constructor(data: VkBindBufferMemoryInfoKHRInput){ super(data, "VkBindBufferMemoryInfoKHR"); }
    }
export class VkBindBufferMemoryDeviceGroupInfo extends VkSerializable<VkBindBufferMemoryDeviceGroupInfoInput, VkBindBufferMemoryDeviceGroupInfoDeserialized> {
        public constructor(data: VkBindBufferMemoryDeviceGroupInfoInput){ super(data, "VkBindBufferMemoryDeviceGroupInfo"); }
    }
export class VkBindBufferMemoryDeviceGroupInfoKHR extends VkSerializable<VkBindBufferMemoryDeviceGroupInfoKHRInput, VkBindBufferMemoryDeviceGroupInfoKHRDeserialized> {
        public constructor(data: VkBindBufferMemoryDeviceGroupInfoKHRInput){ super(data, "VkBindBufferMemoryDeviceGroupInfoKHR"); }
    }
export class VkBindImageMemoryInfo extends VkSerializable<VkBindImageMemoryInfoInput, VkBindImageMemoryInfoDeserialized> {
        public constructor(data: VkBindImageMemoryInfoInput){ super(data, "VkBindImageMemoryInfo"); }
    }
export class VkBindImageMemoryInfoKHR extends VkSerializable<VkBindImageMemoryInfoKHRInput, VkBindImageMemoryInfoKHRDeserialized> {
        public constructor(data: VkBindImageMemoryInfoKHRInput){ super(data, "VkBindImageMemoryInfoKHR"); }
    }
export class VkBindImageMemoryDeviceGroupInfo extends VkSerializable<VkBindImageMemoryDeviceGroupInfoInput, VkBindImageMemoryDeviceGroupInfoDeserialized> {
        public constructor(data: VkBindImageMemoryDeviceGroupInfoInput){ super(data, "VkBindImageMemoryDeviceGroupInfo"); }
    }
export class VkBindImageMemoryDeviceGroupInfoKHR extends VkSerializable<VkBindImageMemoryDeviceGroupInfoKHRInput, VkBindImageMemoryDeviceGroupInfoKHRDeserialized> {
        public constructor(data: VkBindImageMemoryDeviceGroupInfoKHRInput){ super(data, "VkBindImageMemoryDeviceGroupInfoKHR"); }
    }
export class VkDeviceGroupRenderPassBeginInfo extends VkSerializable<VkDeviceGroupRenderPassBeginInfoInput, VkDeviceGroupRenderPassBeginInfoDeserialized> {
        public constructor(data: VkDeviceGroupRenderPassBeginInfoInput){ super(data, "VkDeviceGroupRenderPassBeginInfo"); }
    }
export class VkDeviceGroupRenderPassBeginInfoKHR extends VkSerializable<VkDeviceGroupRenderPassBeginInfoKHRInput, VkDeviceGroupRenderPassBeginInfoKHRDeserialized> {
        public constructor(data: VkDeviceGroupRenderPassBeginInfoKHRInput){ super(data, "VkDeviceGroupRenderPassBeginInfoKHR"); }
    }
export class VkDeviceGroupCommandBufferBeginInfo extends VkSerializable<VkDeviceGroupCommandBufferBeginInfoInput, VkDeviceGroupCommandBufferBeginInfoDeserialized> {
        public constructor(data: VkDeviceGroupCommandBufferBeginInfoInput){ super(data, "VkDeviceGroupCommandBufferBeginInfo"); }
    }
export class VkDeviceGroupCommandBufferBeginInfoKHR extends VkSerializable<VkDeviceGroupCommandBufferBeginInfoKHRInput, VkDeviceGroupCommandBufferBeginInfoKHRDeserialized> {
        public constructor(data: VkDeviceGroupCommandBufferBeginInfoKHRInput){ super(data, "VkDeviceGroupCommandBufferBeginInfoKHR"); }
    }
export class VkDeviceGroupSubmitInfo extends VkSerializable<VkDeviceGroupSubmitInfoInput, VkDeviceGroupSubmitInfoDeserialized> {
        public constructor(data: VkDeviceGroupSubmitInfoInput){ super(data, "VkDeviceGroupSubmitInfo"); }
    }
export class VkDeviceGroupSubmitInfoKHR extends VkSerializable<VkDeviceGroupSubmitInfoKHRInput, VkDeviceGroupSubmitInfoKHRDeserialized> {
        public constructor(data: VkDeviceGroupSubmitInfoKHRInput){ super(data, "VkDeviceGroupSubmitInfoKHR"); }
    }
export class VkDeviceGroupBindSparseInfo extends VkSerializable<VkDeviceGroupBindSparseInfoInput, VkDeviceGroupBindSparseInfoDeserialized> {
        public constructor(data: VkDeviceGroupBindSparseInfoInput){ super(data, "VkDeviceGroupBindSparseInfo"); }
    }
export class VkDeviceGroupBindSparseInfoKHR extends VkSerializable<VkDeviceGroupBindSparseInfoKHRInput, VkDeviceGroupBindSparseInfoKHRDeserialized> {
        public constructor(data: VkDeviceGroupBindSparseInfoKHRInput){ super(data, "VkDeviceGroupBindSparseInfoKHR"); }
    }
export class VkDeviceGroupPresentCapabilitiesKHR extends VkSerializable<VkDeviceGroupPresentCapabilitiesKHRInput, VkDeviceGroupPresentCapabilitiesKHRDeserialized> {
        public constructor(data: VkDeviceGroupPresentCapabilitiesKHRInput){ super(data, "VkDeviceGroupPresentCapabilitiesKHR"); }
    }
export class VkImageSwapchainCreateInfoKHR extends VkSerializable<VkImageSwapchainCreateInfoKHRInput, VkImageSwapchainCreateInfoKHRDeserialized> {
        public constructor(data: VkImageSwapchainCreateInfoKHRInput){ super(data, "VkImageSwapchainCreateInfoKHR"); }
    }
export class VkBindImageMemorySwapchainInfoKHR extends VkSerializable<VkBindImageMemorySwapchainInfoKHRInput, VkBindImageMemorySwapchainInfoKHRDeserialized> {
        public constructor(data: VkBindImageMemorySwapchainInfoKHRInput){ super(data, "VkBindImageMemorySwapchainInfoKHR"); }
    }
export class VkAcquireNextImageInfoKHR extends VkSerializable<VkAcquireNextImageInfoKHRInput, VkAcquireNextImageInfoKHRDeserialized> {
        public constructor(data: VkAcquireNextImageInfoKHRInput){ super(data, "VkAcquireNextImageInfoKHR"); }
    }
export class VkDeviceGroupPresentInfoKHR extends VkSerializable<VkDeviceGroupPresentInfoKHRInput, VkDeviceGroupPresentInfoKHRDeserialized> {
        public constructor(data: VkDeviceGroupPresentInfoKHRInput){ super(data, "VkDeviceGroupPresentInfoKHR"); }
    }
export class VkDeviceGroupDeviceCreateInfo extends VkSerializable<VkDeviceGroupDeviceCreateInfoInput, VkDeviceGroupDeviceCreateInfoDeserialized> {
        public constructor(data: VkDeviceGroupDeviceCreateInfoInput){ super(data, "VkDeviceGroupDeviceCreateInfo"); }
    }
export class VkDeviceGroupDeviceCreateInfoKHR extends VkSerializable<VkDeviceGroupDeviceCreateInfoKHRInput, VkDeviceGroupDeviceCreateInfoKHRDeserialized> {
        public constructor(data: VkDeviceGroupDeviceCreateInfoKHRInput){ super(data, "VkDeviceGroupDeviceCreateInfoKHR"); }
    }
export class VkDeviceGroupSwapchainCreateInfoKHR extends VkSerializable<VkDeviceGroupSwapchainCreateInfoKHRInput, VkDeviceGroupSwapchainCreateInfoKHRDeserialized> {
        public constructor(data: VkDeviceGroupSwapchainCreateInfoKHRInput){ super(data, "VkDeviceGroupSwapchainCreateInfoKHR"); }
    }
export class VkDescriptorUpdateTemplateEntry extends VkSerializable<VkDescriptorUpdateTemplateEntryInput, VkDescriptorUpdateTemplateEntryDeserialized> {
        public constructor(data: VkDescriptorUpdateTemplateEntryInput){ super(data, "VkDescriptorUpdateTemplateEntry"); }
    }
export class VkDescriptorUpdateTemplateEntryKHR extends VkSerializable<VkDescriptorUpdateTemplateEntryKHRInput, VkDescriptorUpdateTemplateEntryKHRDeserialized> {
        public constructor(data: VkDescriptorUpdateTemplateEntryKHRInput){ super(data, "VkDescriptorUpdateTemplateEntryKHR"); }
    }
export class VkDescriptorUpdateTemplateCreateInfo extends VkSerializable<VkDescriptorUpdateTemplateCreateInfoInput, VkDescriptorUpdateTemplateCreateInfoDeserialized> {
        public constructor(data: VkDescriptorUpdateTemplateCreateInfoInput){ super(data, "VkDescriptorUpdateTemplateCreateInfo"); }
    }
export class VkDescriptorUpdateTemplateCreateInfoKHR extends VkSerializable<VkDescriptorUpdateTemplateCreateInfoKHRInput, VkDescriptorUpdateTemplateCreateInfoKHRDeserialized> {
        public constructor(data: VkDescriptorUpdateTemplateCreateInfoKHRInput){ super(data, "VkDescriptorUpdateTemplateCreateInfoKHR"); }
    }
export class VkXYColorEXT extends VkSerializable<VkXYColorEXTInput, VkXYColorEXTDeserialized> {
        public constructor(data: VkXYColorEXTInput){ super(data, "VkXYColorEXT"); }
    }
export class VkPhysicalDevicePresentIdFeaturesKHR extends VkSerializable<VkPhysicalDevicePresentIdFeaturesKHRInput, VkPhysicalDevicePresentIdFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDevicePresentIdFeaturesKHRInput){ super(data, "VkPhysicalDevicePresentIdFeaturesKHR"); }
    }
export class VkPresentIdKHR extends VkSerializable<VkPresentIdKHRInput, VkPresentIdKHRDeserialized> {
        public constructor(data: VkPresentIdKHRInput){ super(data, "VkPresentIdKHR"); }
    }
export class VkPhysicalDevicePresentWaitFeaturesKHR extends VkSerializable<VkPhysicalDevicePresentWaitFeaturesKHRInput, VkPhysicalDevicePresentWaitFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDevicePresentWaitFeaturesKHRInput){ super(data, "VkPhysicalDevicePresentWaitFeaturesKHR"); }
    }
export class VkHdrMetadataEXT extends VkSerializable<VkHdrMetadataEXTInput, VkHdrMetadataEXTDeserialized> {
        public constructor(data: VkHdrMetadataEXTInput){ super(data, "VkHdrMetadataEXT"); }
    }
export class VkInputAttachmentAspectReference extends VkSerializable<VkInputAttachmentAspectReferenceInput, VkInputAttachmentAspectReferenceDeserialized> {
        public constructor(data: VkInputAttachmentAspectReferenceInput){ super(data, "VkInputAttachmentAspectReference"); }
    }
export class VkRenderPassInputAttachmentAspectCreateInfo extends VkSerializable<VkRenderPassInputAttachmentAspectCreateInfoInput, VkRenderPassInputAttachmentAspectCreateInfoDeserialized> {
        public constructor(data: VkRenderPassInputAttachmentAspectCreateInfoInput){ super(data, "VkRenderPassInputAttachmentAspectCreateInfo"); }
    }
export class VkPhysicalDeviceSurfaceInfo2KHR extends VkSerializable<VkPhysicalDeviceSurfaceInfo2KHRInput, VkPhysicalDeviceSurfaceInfo2KHRDeserialized> {
        public constructor(data: VkPhysicalDeviceSurfaceInfo2KHRInput){ super(data, "VkPhysicalDeviceSurfaceInfo2KHR"); }
    }
export class VkSurfaceCapabilities2KHR extends VkSerializable<VkSurfaceCapabilities2KHRInput, VkSurfaceCapabilities2KHRDeserialized> {
        public constructor(data: VkSurfaceCapabilities2KHRInput){ super(data, "VkSurfaceCapabilities2KHR"); }
    }
export class VkSurfaceFormat2KHR extends VkSerializable<VkSurfaceFormat2KHRInput, VkSurfaceFormat2KHRDeserialized> {
        public constructor(data: VkSurfaceFormat2KHRInput){ super(data, "VkSurfaceFormat2KHR"); }
    }
export class VkDisplayProperties2KHR extends VkSerializable<VkDisplayProperties2KHRInput, VkDisplayProperties2KHRDeserialized> {
        public constructor(data: VkDisplayProperties2KHRInput){ super(data, "VkDisplayProperties2KHR"); }
    }
export class VkDisplayPlaneProperties2KHR extends VkSerializable<VkDisplayPlaneProperties2KHRInput, VkDisplayPlaneProperties2KHRDeserialized> {
        public constructor(data: VkDisplayPlaneProperties2KHRInput){ super(data, "VkDisplayPlaneProperties2KHR"); }
    }
export class VkDisplayModeProperties2KHR extends VkSerializable<VkDisplayModeProperties2KHRInput, VkDisplayModeProperties2KHRDeserialized> {
        public constructor(data: VkDisplayModeProperties2KHRInput){ super(data, "VkDisplayModeProperties2KHR"); }
    }
export class VkDisplayPlaneInfo2KHR extends VkSerializable<VkDisplayPlaneInfo2KHRInput, VkDisplayPlaneInfo2KHRDeserialized> {
        public constructor(data: VkDisplayPlaneInfo2KHRInput){ super(data, "VkDisplayPlaneInfo2KHR"); }
    }
export class VkDisplayPlaneCapabilities2KHR extends VkSerializable<VkDisplayPlaneCapabilities2KHRInput, VkDisplayPlaneCapabilities2KHRDeserialized> {
        public constructor(data: VkDisplayPlaneCapabilities2KHRInput){ super(data, "VkDisplayPlaneCapabilities2KHR"); }
    }
export class VkSharedPresentSurfaceCapabilitiesKHR extends VkSerializable<VkSharedPresentSurfaceCapabilitiesKHRInput, VkSharedPresentSurfaceCapabilitiesKHRDeserialized> {
        public constructor(data: VkSharedPresentSurfaceCapabilitiesKHRInput){ super(data, "VkSharedPresentSurfaceCapabilitiesKHR"); }
    }
export class VkPhysicalDevice16BitStorageFeatures extends VkSerializable<VkPhysicalDevice16BitStorageFeaturesInput, VkPhysicalDevice16BitStorageFeaturesDeserialized> {
        public constructor(data: VkPhysicalDevice16BitStorageFeaturesInput){ super(data, "VkPhysicalDevice16BitStorageFeatures"); }
    }
export class VkPhysicalDevice16BitStorageFeaturesKHR extends VkSerializable<VkPhysicalDevice16BitStorageFeaturesKHRInput, VkPhysicalDevice16BitStorageFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDevice16BitStorageFeaturesKHRInput){ super(data, "VkPhysicalDevice16BitStorageFeaturesKHR"); }
    }
export class VkPhysicalDeviceSubgroupProperties extends VkSerializable<VkPhysicalDeviceSubgroupPropertiesInput, VkPhysicalDeviceSubgroupPropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceSubgroupPropertiesInput){ super(data, "VkPhysicalDeviceSubgroupProperties"); }
    }
export class VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures extends VkSerializable<VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesInput, VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesInput){ super(data, "VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures"); }
    }
export class VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR extends VkSerializable<VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHRInput, VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHRInput){ super(data, "VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR"); }
    }
export class VkBufferMemoryRequirementsInfo2 extends VkSerializable<VkBufferMemoryRequirementsInfo2Input, VkBufferMemoryRequirementsInfo2Deserialized> {
        public constructor(data: VkBufferMemoryRequirementsInfo2Input){ super(data, "VkBufferMemoryRequirementsInfo2"); }
    }
export class VkBufferMemoryRequirementsInfo2KHR extends VkSerializable<VkBufferMemoryRequirementsInfo2KHRInput, VkBufferMemoryRequirementsInfo2KHRDeserialized> {
        public constructor(data: VkBufferMemoryRequirementsInfo2KHRInput){ super(data, "VkBufferMemoryRequirementsInfo2KHR"); }
    }
export class VkDeviceBufferMemoryRequirements extends VkSerializable<VkDeviceBufferMemoryRequirementsInput, VkDeviceBufferMemoryRequirementsDeserialized> {
        public constructor(data: VkDeviceBufferMemoryRequirementsInput){ super(data, "VkDeviceBufferMemoryRequirements"); }
    }
export class VkImageMemoryRequirementsInfo2 extends VkSerializable<VkImageMemoryRequirementsInfo2Input, VkImageMemoryRequirementsInfo2Deserialized> {
        public constructor(data: VkImageMemoryRequirementsInfo2Input){ super(data, "VkImageMemoryRequirementsInfo2"); }
    }
export class VkImageMemoryRequirementsInfo2KHR extends VkSerializable<VkImageMemoryRequirementsInfo2KHRInput, VkImageMemoryRequirementsInfo2KHRDeserialized> {
        public constructor(data: VkImageMemoryRequirementsInfo2KHRInput){ super(data, "VkImageMemoryRequirementsInfo2KHR"); }
    }
export class VkImageSparseMemoryRequirementsInfo2 extends VkSerializable<VkImageSparseMemoryRequirementsInfo2Input, VkImageSparseMemoryRequirementsInfo2Deserialized> {
        public constructor(data: VkImageSparseMemoryRequirementsInfo2Input){ super(data, "VkImageSparseMemoryRequirementsInfo2"); }
    }
export class VkImageSparseMemoryRequirementsInfo2KHR extends VkSerializable<VkImageSparseMemoryRequirementsInfo2KHRInput, VkImageSparseMemoryRequirementsInfo2KHRDeserialized> {
        public constructor(data: VkImageSparseMemoryRequirementsInfo2KHRInput){ super(data, "VkImageSparseMemoryRequirementsInfo2KHR"); }
    }
export class VkDeviceImageMemoryRequirements extends VkSerializable<VkDeviceImageMemoryRequirementsInput, VkDeviceImageMemoryRequirementsDeserialized> {
        public constructor(data: VkDeviceImageMemoryRequirementsInput){ super(data, "VkDeviceImageMemoryRequirements"); }
    }
export class VkMemoryRequirements2 extends VkSerializable<VkMemoryRequirements2Input, VkMemoryRequirements2Deserialized> {
        public constructor(data: VkMemoryRequirements2Input){ super(data, "VkMemoryRequirements2"); }
    }
export class VkSparseImageMemoryRequirements2 extends VkSerializable<VkSparseImageMemoryRequirements2Input, VkSparseImageMemoryRequirements2Deserialized> {
        public constructor(data: VkSparseImageMemoryRequirements2Input){ super(data, "VkSparseImageMemoryRequirements2"); }
    }
export class VkSparseImageMemoryRequirements2KHR extends VkSerializable<VkSparseImageMemoryRequirements2KHRInput, VkSparseImageMemoryRequirements2KHRDeserialized> {
        public constructor(data: VkSparseImageMemoryRequirements2KHRInput){ super(data, "VkSparseImageMemoryRequirements2KHR"); }
    }
export class VkPhysicalDevicePointClippingProperties extends VkSerializable<VkPhysicalDevicePointClippingPropertiesInput, VkPhysicalDevicePointClippingPropertiesDeserialized> {
        public constructor(data: VkPhysicalDevicePointClippingPropertiesInput){ super(data, "VkPhysicalDevicePointClippingProperties"); }
    }
export class VkMemoryDedicatedRequirements extends VkSerializable<VkMemoryDedicatedRequirementsInput, VkMemoryDedicatedRequirementsDeserialized> {
        public constructor(data: VkMemoryDedicatedRequirementsInput){ super(data, "VkMemoryDedicatedRequirements"); }
    }
export class VkMemoryDedicatedRequirementsKHR extends VkSerializable<VkMemoryDedicatedRequirementsKHRInput, VkMemoryDedicatedRequirementsKHRDeserialized> {
        public constructor(data: VkMemoryDedicatedRequirementsKHRInput){ super(data, "VkMemoryDedicatedRequirementsKHR"); }
    }
export class VkMemoryDedicatedAllocateInfo extends VkSerializable<VkMemoryDedicatedAllocateInfoInput, VkMemoryDedicatedAllocateInfoDeserialized> {
        public constructor(data: VkMemoryDedicatedAllocateInfoInput){ super(data, "VkMemoryDedicatedAllocateInfo"); }
    }
export class VkMemoryDedicatedAllocateInfoKHR extends VkSerializable<VkMemoryDedicatedAllocateInfoKHRInput, VkMemoryDedicatedAllocateInfoKHRDeserialized> {
        public constructor(data: VkMemoryDedicatedAllocateInfoKHRInput){ super(data, "VkMemoryDedicatedAllocateInfoKHR"); }
    }
export class VkImageViewUsageCreateInfo extends VkSerializable<VkImageViewUsageCreateInfoInput, VkImageViewUsageCreateInfoDeserialized> {
        public constructor(data: VkImageViewUsageCreateInfoInput){ super(data, "VkImageViewUsageCreateInfo"); }
    }
export class VkPipelineTessellationDomainOriginStateCreateInfo extends VkSerializable<VkPipelineTessellationDomainOriginStateCreateInfoInput, VkPipelineTessellationDomainOriginStateCreateInfoDeserialized> {
        public constructor(data: VkPipelineTessellationDomainOriginStateCreateInfoInput){ super(data, "VkPipelineTessellationDomainOriginStateCreateInfo"); }
    }
export class VkSamplerYcbcrConversionInfo extends VkSerializable<VkSamplerYcbcrConversionInfoInput, VkSamplerYcbcrConversionInfoDeserialized> {
        public constructor(data: VkSamplerYcbcrConversionInfoInput){ super(data, "VkSamplerYcbcrConversionInfo"); }
    }
export class VkSamplerYcbcrConversionInfoKHR extends VkSerializable<VkSamplerYcbcrConversionInfoKHRInput, VkSamplerYcbcrConversionInfoKHRDeserialized> {
        public constructor(data: VkSamplerYcbcrConversionInfoKHRInput){ super(data, "VkSamplerYcbcrConversionInfoKHR"); }
    }
export class VkSamplerYcbcrConversionCreateInfo extends VkSerializable<VkSamplerYcbcrConversionCreateInfoInput, VkSamplerYcbcrConversionCreateInfoDeserialized> {
        public constructor(data: VkSamplerYcbcrConversionCreateInfoInput){ super(data, "VkSamplerYcbcrConversionCreateInfo"); }
    }
export class VkSamplerYcbcrConversionCreateInfoKHR extends VkSerializable<VkSamplerYcbcrConversionCreateInfoKHRInput, VkSamplerYcbcrConversionCreateInfoKHRDeserialized> {
        public constructor(data: VkSamplerYcbcrConversionCreateInfoKHRInput){ super(data, "VkSamplerYcbcrConversionCreateInfoKHR"); }
    }
export class VkBindImagePlaneMemoryInfo extends VkSerializable<VkBindImagePlaneMemoryInfoInput, VkBindImagePlaneMemoryInfoDeserialized> {
        public constructor(data: VkBindImagePlaneMemoryInfoInput){ super(data, "VkBindImagePlaneMemoryInfo"); }
    }
export class VkBindImagePlaneMemoryInfoKHR extends VkSerializable<VkBindImagePlaneMemoryInfoKHRInput, VkBindImagePlaneMemoryInfoKHRDeserialized> {
        public constructor(data: VkBindImagePlaneMemoryInfoKHRInput){ super(data, "VkBindImagePlaneMemoryInfoKHR"); }
    }
export class VkImagePlaneMemoryRequirementsInfo extends VkSerializable<VkImagePlaneMemoryRequirementsInfoInput, VkImagePlaneMemoryRequirementsInfoDeserialized> {
        public constructor(data: VkImagePlaneMemoryRequirementsInfoInput){ super(data, "VkImagePlaneMemoryRequirementsInfo"); }
    }
export class VkImagePlaneMemoryRequirementsInfoKHR extends VkSerializable<VkImagePlaneMemoryRequirementsInfoKHRInput, VkImagePlaneMemoryRequirementsInfoKHRDeserialized> {
        public constructor(data: VkImagePlaneMemoryRequirementsInfoKHRInput){ super(data, "VkImagePlaneMemoryRequirementsInfoKHR"); }
    }
export class VkPhysicalDeviceSamplerYcbcrConversionFeatures extends VkSerializable<VkPhysicalDeviceSamplerYcbcrConversionFeaturesInput, VkPhysicalDeviceSamplerYcbcrConversionFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceSamplerYcbcrConversionFeaturesInput){ super(data, "VkPhysicalDeviceSamplerYcbcrConversionFeatures"); }
    }
export class VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR extends VkSerializable<VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHRInput, VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHRInput){ super(data, "VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR"); }
    }
export class VkSamplerYcbcrConversionImageFormatProperties extends VkSerializable<VkSamplerYcbcrConversionImageFormatPropertiesInput, VkSamplerYcbcrConversionImageFormatPropertiesDeserialized> {
        public constructor(data: VkSamplerYcbcrConversionImageFormatPropertiesInput){ super(data, "VkSamplerYcbcrConversionImageFormatProperties"); }
    }
export class VkSamplerYcbcrConversionImageFormatPropertiesKHR extends VkSerializable<VkSamplerYcbcrConversionImageFormatPropertiesKHRInput, VkSamplerYcbcrConversionImageFormatPropertiesKHRDeserialized> {
        public constructor(data: VkSamplerYcbcrConversionImageFormatPropertiesKHRInput){ super(data, "VkSamplerYcbcrConversionImageFormatPropertiesKHR"); }
    }
export class VkProtectedSubmitInfo extends VkSerializable<VkProtectedSubmitInfoInput, VkProtectedSubmitInfoDeserialized> {
        public constructor(data: VkProtectedSubmitInfoInput){ super(data, "VkProtectedSubmitInfo"); }
    }
export class VkPhysicalDeviceProtectedMemoryFeatures extends VkSerializable<VkPhysicalDeviceProtectedMemoryFeaturesInput, VkPhysicalDeviceProtectedMemoryFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceProtectedMemoryFeaturesInput){ super(data, "VkPhysicalDeviceProtectedMemoryFeatures"); }
    }
export class VkPhysicalDeviceProtectedMemoryProperties extends VkSerializable<VkPhysicalDeviceProtectedMemoryPropertiesInput, VkPhysicalDeviceProtectedMemoryPropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceProtectedMemoryPropertiesInput){ super(data, "VkPhysicalDeviceProtectedMemoryProperties"); }
    }
export class VkDeviceQueueInfo2 extends VkSerializable<VkDeviceQueueInfo2Input, VkDeviceQueueInfo2Deserialized> {
        public constructor(data: VkDeviceQueueInfo2Input){ super(data, "VkDeviceQueueInfo2"); }
    }
export class VkPhysicalDeviceSamplerFilterMinmaxProperties extends VkSerializable<VkPhysicalDeviceSamplerFilterMinmaxPropertiesInput, VkPhysicalDeviceSamplerFilterMinmaxPropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceSamplerFilterMinmaxPropertiesInput){ super(data, "VkPhysicalDeviceSamplerFilterMinmaxProperties"); }
    }
export class VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT extends VkSerializable<VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXTInput, VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXTInput){ super(data, "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT"); }
    }
export class VkSampleLocationEXT extends VkSerializable<VkSampleLocationEXTInput, VkSampleLocationEXTDeserialized> {
        public constructor(data: VkSampleLocationEXTInput){ super(data, "VkSampleLocationEXT"); }
    }
export class VkSampleLocationsInfoEXT extends VkSerializable<VkSampleLocationsInfoEXTInput, VkSampleLocationsInfoEXTDeserialized> {
        public constructor(data: VkSampleLocationsInfoEXTInput){ super(data, "VkSampleLocationsInfoEXT"); }
    }
export class VkAttachmentSampleLocationsEXT extends VkSerializable<VkAttachmentSampleLocationsEXTInput, VkAttachmentSampleLocationsEXTDeserialized> {
        public constructor(data: VkAttachmentSampleLocationsEXTInput){ super(data, "VkAttachmentSampleLocationsEXT"); }
    }
export class VkSubpassSampleLocationsEXT extends VkSerializable<VkSubpassSampleLocationsEXTInput, VkSubpassSampleLocationsEXTDeserialized> {
        public constructor(data: VkSubpassSampleLocationsEXTInput){ super(data, "VkSubpassSampleLocationsEXT"); }
    }
export class VkRenderPassSampleLocationsBeginInfoEXT extends VkSerializable<VkRenderPassSampleLocationsBeginInfoEXTInput, VkRenderPassSampleLocationsBeginInfoEXTDeserialized> {
        public constructor(data: VkRenderPassSampleLocationsBeginInfoEXTInput){ super(data, "VkRenderPassSampleLocationsBeginInfoEXT"); }
    }
export class VkPipelineSampleLocationsStateCreateInfoEXT extends VkSerializable<VkPipelineSampleLocationsStateCreateInfoEXTInput, VkPipelineSampleLocationsStateCreateInfoEXTDeserialized> {
        public constructor(data: VkPipelineSampleLocationsStateCreateInfoEXTInput){ super(data, "VkPipelineSampleLocationsStateCreateInfoEXT"); }
    }
export class VkPhysicalDeviceSampleLocationsPropertiesEXT extends VkSerializable<VkPhysicalDeviceSampleLocationsPropertiesEXTInput, VkPhysicalDeviceSampleLocationsPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceSampleLocationsPropertiesEXTInput){ super(data, "VkPhysicalDeviceSampleLocationsPropertiesEXT"); }
    }
export class VkMultisamplePropertiesEXT extends VkSerializable<VkMultisamplePropertiesEXTInput, VkMultisamplePropertiesEXTDeserialized> {
        public constructor(data: VkMultisamplePropertiesEXTInput){ super(data, "VkMultisamplePropertiesEXT"); }
    }
export class VkSamplerReductionModeCreateInfo extends VkSerializable<VkSamplerReductionModeCreateInfoInput, VkSamplerReductionModeCreateInfoDeserialized> {
        public constructor(data: VkSamplerReductionModeCreateInfoInput){ super(data, "VkSamplerReductionModeCreateInfo"); }
    }
export class VkSamplerReductionModeCreateInfoEXT extends VkSerializable<VkSamplerReductionModeCreateInfoEXTInput, VkSamplerReductionModeCreateInfoEXTDeserialized> {
        public constructor(data: VkSamplerReductionModeCreateInfoEXTInput){ super(data, "VkSamplerReductionModeCreateInfoEXT"); }
    }
export class VkPhysicalDeviceMultiDrawFeaturesEXT extends VkSerializable<VkPhysicalDeviceMultiDrawFeaturesEXTInput, VkPhysicalDeviceMultiDrawFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceMultiDrawFeaturesEXTInput){ super(data, "VkPhysicalDeviceMultiDrawFeaturesEXT"); }
    }
export class VkPhysicalDeviceInlineUniformBlockFeatures extends VkSerializable<VkPhysicalDeviceInlineUniformBlockFeaturesInput, VkPhysicalDeviceInlineUniformBlockFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceInlineUniformBlockFeaturesInput){ super(data, "VkPhysicalDeviceInlineUniformBlockFeatures"); }
    }
export class VkPhysicalDeviceInlineUniformBlockFeaturesEXT extends VkSerializable<VkPhysicalDeviceInlineUniformBlockFeaturesEXTInput, VkPhysicalDeviceInlineUniformBlockFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceInlineUniformBlockFeaturesEXTInput){ super(data, "VkPhysicalDeviceInlineUniformBlockFeaturesEXT"); }
    }
export class VkPhysicalDeviceInlineUniformBlockProperties extends VkSerializable<VkPhysicalDeviceInlineUniformBlockPropertiesInput, VkPhysicalDeviceInlineUniformBlockPropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceInlineUniformBlockPropertiesInput){ super(data, "VkPhysicalDeviceInlineUniformBlockProperties"); }
    }
export class VkPhysicalDeviceInlineUniformBlockPropertiesEXT extends VkSerializable<VkPhysicalDeviceInlineUniformBlockPropertiesEXTInput, VkPhysicalDeviceInlineUniformBlockPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceInlineUniformBlockPropertiesEXTInput){ super(data, "VkPhysicalDeviceInlineUniformBlockPropertiesEXT"); }
    }
export class VkWriteDescriptorSetInlineUniformBlock extends VkSerializable<VkWriteDescriptorSetInlineUniformBlockInput, VkWriteDescriptorSetInlineUniformBlockDeserialized> {
        public constructor(data: VkWriteDescriptorSetInlineUniformBlockInput){ super(data, "VkWriteDescriptorSetInlineUniformBlock"); }
    }
export class VkWriteDescriptorSetInlineUniformBlockEXT extends VkSerializable<VkWriteDescriptorSetInlineUniformBlockEXTInput, VkWriteDescriptorSetInlineUniformBlockEXTDeserialized> {
        public constructor(data: VkWriteDescriptorSetInlineUniformBlockEXTInput){ super(data, "VkWriteDescriptorSetInlineUniformBlockEXT"); }
    }
export class VkDescriptorPoolInlineUniformBlockCreateInfo extends VkSerializable<VkDescriptorPoolInlineUniformBlockCreateInfoInput, VkDescriptorPoolInlineUniformBlockCreateInfoDeserialized> {
        public constructor(data: VkDescriptorPoolInlineUniformBlockCreateInfoInput){ super(data, "VkDescriptorPoolInlineUniformBlockCreateInfo"); }
    }
export class VkDescriptorPoolInlineUniformBlockCreateInfoEXT extends VkSerializable<VkDescriptorPoolInlineUniformBlockCreateInfoEXTInput, VkDescriptorPoolInlineUniformBlockCreateInfoEXTDeserialized> {
        public constructor(data: VkDescriptorPoolInlineUniformBlockCreateInfoEXTInput){ super(data, "VkDescriptorPoolInlineUniformBlockCreateInfoEXT"); }
    }
export class VkImageFormatListCreateInfo extends VkSerializable<VkImageFormatListCreateInfoInput, VkImageFormatListCreateInfoDeserialized> {
        public constructor(data: VkImageFormatListCreateInfoInput){ super(data, "VkImageFormatListCreateInfo"); }
    }
export class VkImageFormatListCreateInfoKHR extends VkSerializable<VkImageFormatListCreateInfoKHRInput, VkImageFormatListCreateInfoKHRDeserialized> {
        public constructor(data: VkImageFormatListCreateInfoKHRInput){ super(data, "VkImageFormatListCreateInfoKHR"); }
    }
export class VkValidationCacheCreateInfoEXT extends VkSerializable<VkValidationCacheCreateInfoEXTInput, VkValidationCacheCreateInfoEXTDeserialized> {
        public constructor(data: VkValidationCacheCreateInfoEXTInput){ super(data, "VkValidationCacheCreateInfoEXT"); }
    }
export class VkShaderModuleValidationCacheCreateInfoEXT extends VkSerializable<VkShaderModuleValidationCacheCreateInfoEXTInput, VkShaderModuleValidationCacheCreateInfoEXTDeserialized> {
        public constructor(data: VkShaderModuleValidationCacheCreateInfoEXTInput){ super(data, "VkShaderModuleValidationCacheCreateInfoEXT"); }
    }
export class VkPhysicalDeviceMaintenance3Properties extends VkSerializable<VkPhysicalDeviceMaintenance3PropertiesInput, VkPhysicalDeviceMaintenance3PropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceMaintenance3PropertiesInput){ super(data, "VkPhysicalDeviceMaintenance3Properties"); }
    }
export class VkPhysicalDeviceMaintenance4Features extends VkSerializable<VkPhysicalDeviceMaintenance4FeaturesInput, VkPhysicalDeviceMaintenance4FeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceMaintenance4FeaturesInput){ super(data, "VkPhysicalDeviceMaintenance4Features"); }
    }
export class VkPhysicalDeviceMaintenance4Properties extends VkSerializable<VkPhysicalDeviceMaintenance4PropertiesInput, VkPhysicalDeviceMaintenance4PropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceMaintenance4PropertiesInput){ super(data, "VkPhysicalDeviceMaintenance4Properties"); }
    }
export class VkDescriptorSetLayoutSupport extends VkSerializable<VkDescriptorSetLayoutSupportInput, VkDescriptorSetLayoutSupportDeserialized> {
        public constructor(data: VkDescriptorSetLayoutSupportInput){ super(data, "VkDescriptorSetLayoutSupport"); }
    }
export class VkPhysicalDeviceShaderDrawParametersFeatures extends VkSerializable<VkPhysicalDeviceShaderDrawParametersFeaturesInput, VkPhysicalDeviceShaderDrawParametersFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderDrawParametersFeaturesInput){ super(data, "VkPhysicalDeviceShaderDrawParametersFeatures"); }
    }
export class VkPhysicalDeviceShaderDrawParameterFeatures extends VkSerializable<VkPhysicalDeviceShaderDrawParameterFeaturesInput, VkPhysicalDeviceShaderDrawParameterFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderDrawParameterFeaturesInput){ super(data, "VkPhysicalDeviceShaderDrawParameterFeatures"); }
    }
export class VkPhysicalDeviceShaderFloat16Int8Features extends VkSerializable<VkPhysicalDeviceShaderFloat16Int8FeaturesInput, VkPhysicalDeviceShaderFloat16Int8FeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderFloat16Int8FeaturesInput){ super(data, "VkPhysicalDeviceShaderFloat16Int8Features"); }
    }
export class VkPhysicalDeviceShaderFloat16Int8FeaturesKHR extends VkSerializable<VkPhysicalDeviceShaderFloat16Int8FeaturesKHRInput, VkPhysicalDeviceShaderFloat16Int8FeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderFloat16Int8FeaturesKHRInput){ super(data, "VkPhysicalDeviceShaderFloat16Int8FeaturesKHR"); }
    }
export class VkPhysicalDeviceFloat16Int8FeaturesKHR extends VkSerializable<VkPhysicalDeviceFloat16Int8FeaturesKHRInput, VkPhysicalDeviceFloat16Int8FeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceFloat16Int8FeaturesKHRInput){ super(data, "VkPhysicalDeviceFloat16Int8FeaturesKHR"); }
    }
export class VkPhysicalDeviceFloatControlsProperties extends VkSerializable<VkPhysicalDeviceFloatControlsPropertiesInput, VkPhysicalDeviceFloatControlsPropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceFloatControlsPropertiesInput){ super(data, "VkPhysicalDeviceFloatControlsProperties"); }
    }
export class VkPhysicalDeviceFloatControlsPropertiesKHR extends VkSerializable<VkPhysicalDeviceFloatControlsPropertiesKHRInput, VkPhysicalDeviceFloatControlsPropertiesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceFloatControlsPropertiesKHRInput){ super(data, "VkPhysicalDeviceFloatControlsPropertiesKHR"); }
    }
export class VkPhysicalDeviceHostQueryResetFeatures extends VkSerializable<VkPhysicalDeviceHostQueryResetFeaturesInput, VkPhysicalDeviceHostQueryResetFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceHostQueryResetFeaturesInput){ super(data, "VkPhysicalDeviceHostQueryResetFeatures"); }
    }
export class VkPhysicalDeviceHostQueryResetFeaturesEXT extends VkSerializable<VkPhysicalDeviceHostQueryResetFeaturesEXTInput, VkPhysicalDeviceHostQueryResetFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceHostQueryResetFeaturesEXTInput){ super(data, "VkPhysicalDeviceHostQueryResetFeaturesEXT"); }
    }
export class VkDeviceQueueGlobalPriorityCreateInfoKHR extends VkSerializable<VkDeviceQueueGlobalPriorityCreateInfoKHRInput, VkDeviceQueueGlobalPriorityCreateInfoKHRDeserialized> {
        public constructor(data: VkDeviceQueueGlobalPriorityCreateInfoKHRInput){ super(data, "VkDeviceQueueGlobalPriorityCreateInfoKHR"); }
    }
export class VkDeviceQueueGlobalPriorityCreateInfoEXT extends VkSerializable<VkDeviceQueueGlobalPriorityCreateInfoEXTInput, VkDeviceQueueGlobalPriorityCreateInfoEXTDeserialized> {
        public constructor(data: VkDeviceQueueGlobalPriorityCreateInfoEXTInput){ super(data, "VkDeviceQueueGlobalPriorityCreateInfoEXT"); }
    }
export class VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR extends VkSerializable<VkPhysicalDeviceGlobalPriorityQueryFeaturesKHRInput, VkPhysicalDeviceGlobalPriorityQueryFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceGlobalPriorityQueryFeaturesKHRInput){ super(data, "VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR"); }
    }
export class VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT extends VkSerializable<VkPhysicalDeviceGlobalPriorityQueryFeaturesEXTInput, VkPhysicalDeviceGlobalPriorityQueryFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceGlobalPriorityQueryFeaturesEXTInput){ super(data, "VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT"); }
    }
export class VkQueueFamilyGlobalPriorityPropertiesKHR extends VkSerializable<VkQueueFamilyGlobalPriorityPropertiesKHRInput, VkQueueFamilyGlobalPriorityPropertiesKHRDeserialized> {
        public constructor(data: VkQueueFamilyGlobalPriorityPropertiesKHRInput){ super(data, "VkQueueFamilyGlobalPriorityPropertiesKHR"); }
    }
export class VkQueueFamilyGlobalPriorityPropertiesEXT extends VkSerializable<VkQueueFamilyGlobalPriorityPropertiesEXTInput, VkQueueFamilyGlobalPriorityPropertiesEXTDeserialized> {
        public constructor(data: VkQueueFamilyGlobalPriorityPropertiesEXTInput){ super(data, "VkQueueFamilyGlobalPriorityPropertiesEXT"); }
    }
export class VkImportMemoryHostPointerInfoEXT extends VkSerializable<VkImportMemoryHostPointerInfoEXTInput, VkImportMemoryHostPointerInfoEXTDeserialized> {
        public constructor(data: VkImportMemoryHostPointerInfoEXTInput){ super(data, "VkImportMemoryHostPointerInfoEXT"); }
    }
export class VkMemoryHostPointerPropertiesEXT extends VkSerializable<VkMemoryHostPointerPropertiesEXTInput, VkMemoryHostPointerPropertiesEXTDeserialized> {
        public constructor(data: VkMemoryHostPointerPropertiesEXTInput){ super(data, "VkMemoryHostPointerPropertiesEXT"); }
    }
export class VkPhysicalDeviceExternalMemoryHostPropertiesEXT extends VkSerializable<VkPhysicalDeviceExternalMemoryHostPropertiesEXTInput, VkPhysicalDeviceExternalMemoryHostPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceExternalMemoryHostPropertiesEXTInput){ super(data, "VkPhysicalDeviceExternalMemoryHostPropertiesEXT"); }
    }
export class VkPhysicalDeviceDescriptorIndexingFeatures extends VkSerializable<VkPhysicalDeviceDescriptorIndexingFeaturesInput, VkPhysicalDeviceDescriptorIndexingFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceDescriptorIndexingFeaturesInput){ super(data, "VkPhysicalDeviceDescriptorIndexingFeatures"); }
    }
export class VkPhysicalDeviceDescriptorIndexingProperties extends VkSerializable<VkPhysicalDeviceDescriptorIndexingPropertiesInput, VkPhysicalDeviceDescriptorIndexingPropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceDescriptorIndexingPropertiesInput){ super(data, "VkPhysicalDeviceDescriptorIndexingProperties"); }
    }
export class VkDescriptorSetLayoutBindingFlagsCreateInfo extends VkSerializable<VkDescriptorSetLayoutBindingFlagsCreateInfoInput, VkDescriptorSetLayoutBindingFlagsCreateInfoDeserialized> {
        public constructor(data: VkDescriptorSetLayoutBindingFlagsCreateInfoInput){ super(data, "VkDescriptorSetLayoutBindingFlagsCreateInfo"); }
    }
export class VkDescriptorSetVariableDescriptorCountAllocateInfo extends VkSerializable<VkDescriptorSetVariableDescriptorCountAllocateInfoInput, VkDescriptorSetVariableDescriptorCountAllocateInfoDeserialized> {
        public constructor(data: VkDescriptorSetVariableDescriptorCountAllocateInfoInput){ super(data, "VkDescriptorSetVariableDescriptorCountAllocateInfo"); }
    }
export class VkDescriptorSetVariableDescriptorCountLayoutSupport extends VkSerializable<VkDescriptorSetVariableDescriptorCountLayoutSupportInput, VkDescriptorSetVariableDescriptorCountLayoutSupportDeserialized> {
        public constructor(data: VkDescriptorSetVariableDescriptorCountLayoutSupportInput){ super(data, "VkDescriptorSetVariableDescriptorCountLayoutSupport"); }
    }
export class VkAttachmentDescription2 extends VkSerializable<VkAttachmentDescription2Input, VkAttachmentDescription2Deserialized> {
        public constructor(data: VkAttachmentDescription2Input){ super(data, "VkAttachmentDescription2"); }
    }
export class VkAttachmentDescription2KHR extends VkSerializable<VkAttachmentDescription2KHRInput, VkAttachmentDescription2KHRDeserialized> {
        public constructor(data: VkAttachmentDescription2KHRInput){ super(data, "VkAttachmentDescription2KHR"); }
    }
export class VkAttachmentReference2 extends VkSerializable<VkAttachmentReference2Input, VkAttachmentReference2Deserialized> {
        public constructor(data: VkAttachmentReference2Input){ super(data, "VkAttachmentReference2"); }
    }
export class VkAttachmentReference2KHR extends VkSerializable<VkAttachmentReference2KHRInput, VkAttachmentReference2KHRDeserialized> {
        public constructor(data: VkAttachmentReference2KHRInput){ super(data, "VkAttachmentReference2KHR"); }
    }
export class VkSubpassDescription2 extends VkSerializable<VkSubpassDescription2Input, VkSubpassDescription2Deserialized> {
        public constructor(data: VkSubpassDescription2Input){ super(data, "VkSubpassDescription2"); }
    }
export class VkSubpassDescription2KHR extends VkSerializable<VkSubpassDescription2KHRInput, VkSubpassDescription2KHRDeserialized> {
        public constructor(data: VkSubpassDescription2KHRInput){ super(data, "VkSubpassDescription2KHR"); }
    }
export class VkSubpassDependency2 extends VkSerializable<VkSubpassDependency2Input, VkSubpassDependency2Deserialized> {
        public constructor(data: VkSubpassDependency2Input){ super(data, "VkSubpassDependency2"); }
    }
export class VkSubpassDependency2KHR extends VkSerializable<VkSubpassDependency2KHRInput, VkSubpassDependency2KHRDeserialized> {
        public constructor(data: VkSubpassDependency2KHRInput){ super(data, "VkSubpassDependency2KHR"); }
    }
export class VkRenderPassCreateInfo2 extends VkSerializable<VkRenderPassCreateInfo2Input, VkRenderPassCreateInfo2Deserialized> {
        public constructor(data: VkRenderPassCreateInfo2Input){ super(data, "VkRenderPassCreateInfo2"); }
    }
export class VkRenderPassCreateInfo2KHR extends VkSerializable<VkRenderPassCreateInfo2KHRInput, VkRenderPassCreateInfo2KHRDeserialized> {
        public constructor(data: VkRenderPassCreateInfo2KHRInput){ super(data, "VkRenderPassCreateInfo2KHR"); }
    }
export class VkSubpassBeginInfo extends VkSerializable<VkSubpassBeginInfoInput, VkSubpassBeginInfoDeserialized> {
        public constructor(data: VkSubpassBeginInfoInput){ super(data, "VkSubpassBeginInfo"); }
    }
export class VkSubpassBeginInfoKHR extends VkSerializable<VkSubpassBeginInfoKHRInput, VkSubpassBeginInfoKHRDeserialized> {
        public constructor(data: VkSubpassBeginInfoKHRInput){ super(data, "VkSubpassBeginInfoKHR"); }
    }
export class VkSubpassEndInfo extends VkSerializable<VkSubpassEndInfoInput, VkSubpassEndInfoDeserialized> {
        public constructor(data: VkSubpassEndInfoInput){ super(data, "VkSubpassEndInfo"); }
    }
export class VkSubpassEndInfoKHR extends VkSerializable<VkSubpassEndInfoKHRInput, VkSubpassEndInfoKHRDeserialized> {
        public constructor(data: VkSubpassEndInfoKHRInput){ super(data, "VkSubpassEndInfoKHR"); }
    }
export class VkPhysicalDeviceTimelineSemaphoreFeatures extends VkSerializable<VkPhysicalDeviceTimelineSemaphoreFeaturesInput, VkPhysicalDeviceTimelineSemaphoreFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceTimelineSemaphoreFeaturesInput){ super(data, "VkPhysicalDeviceTimelineSemaphoreFeatures"); }
    }
export class VkPhysicalDeviceTimelineSemaphoreFeaturesKHR extends VkSerializable<VkPhysicalDeviceTimelineSemaphoreFeaturesKHRInput, VkPhysicalDeviceTimelineSemaphoreFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceTimelineSemaphoreFeaturesKHRInput){ super(data, "VkPhysicalDeviceTimelineSemaphoreFeaturesKHR"); }
    }
export class VkPhysicalDeviceTimelineSemaphoreProperties extends VkSerializable<VkPhysicalDeviceTimelineSemaphorePropertiesInput, VkPhysicalDeviceTimelineSemaphorePropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceTimelineSemaphorePropertiesInput){ super(data, "VkPhysicalDeviceTimelineSemaphoreProperties"); }
    }
export class VkPhysicalDeviceTimelineSemaphorePropertiesKHR extends VkSerializable<VkPhysicalDeviceTimelineSemaphorePropertiesKHRInput, VkPhysicalDeviceTimelineSemaphorePropertiesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceTimelineSemaphorePropertiesKHRInput){ super(data, "VkPhysicalDeviceTimelineSemaphorePropertiesKHR"); }
    }
export class VkSemaphoreTypeCreateInfo extends VkSerializable<VkSemaphoreTypeCreateInfoInput, VkSemaphoreTypeCreateInfoDeserialized> {
        public constructor(data: VkSemaphoreTypeCreateInfoInput){ super(data, "VkSemaphoreTypeCreateInfo"); }
    }
export class VkSemaphoreTypeCreateInfoKHR extends VkSerializable<VkSemaphoreTypeCreateInfoKHRInput, VkSemaphoreTypeCreateInfoKHRDeserialized> {
        public constructor(data: VkSemaphoreTypeCreateInfoKHRInput){ super(data, "VkSemaphoreTypeCreateInfoKHR"); }
    }
export class VkTimelineSemaphoreSubmitInfo extends VkSerializable<VkTimelineSemaphoreSubmitInfoInput, VkTimelineSemaphoreSubmitInfoDeserialized> {
        public constructor(data: VkTimelineSemaphoreSubmitInfoInput){ super(data, "VkTimelineSemaphoreSubmitInfo"); }
    }
export class VkTimelineSemaphoreSubmitInfoKHR extends VkSerializable<VkTimelineSemaphoreSubmitInfoKHRInput, VkTimelineSemaphoreSubmitInfoKHRDeserialized> {
        public constructor(data: VkTimelineSemaphoreSubmitInfoKHRInput){ super(data, "VkTimelineSemaphoreSubmitInfoKHR"); }
    }
export class VkSemaphoreWaitInfo extends VkSerializable<VkSemaphoreWaitInfoInput, VkSemaphoreWaitInfoDeserialized> {
        public constructor(data: VkSemaphoreWaitInfoInput){ super(data, "VkSemaphoreWaitInfo"); }
    }
export class VkSemaphoreWaitInfoKHR extends VkSerializable<VkSemaphoreWaitInfoKHRInput, VkSemaphoreWaitInfoKHRDeserialized> {
        public constructor(data: VkSemaphoreWaitInfoKHRInput){ super(data, "VkSemaphoreWaitInfoKHR"); }
    }
export class VkSemaphoreSignalInfo extends VkSerializable<VkSemaphoreSignalInfoInput, VkSemaphoreSignalInfoDeserialized> {
        public constructor(data: VkSemaphoreSignalInfoInput){ super(data, "VkSemaphoreSignalInfo"); }
    }
export class VkSemaphoreSignalInfoKHR extends VkSerializable<VkSemaphoreSignalInfoKHRInput, VkSemaphoreSignalInfoKHRDeserialized> {
        public constructor(data: VkSemaphoreSignalInfoKHRInput){ super(data, "VkSemaphoreSignalInfoKHR"); }
    }
export class VkVertexInputBindingDivisorDescriptionEXT extends VkSerializable<VkVertexInputBindingDivisorDescriptionEXTInput, VkVertexInputBindingDivisorDescriptionEXTDeserialized> {
        public constructor(data: VkVertexInputBindingDivisorDescriptionEXTInput){ super(data, "VkVertexInputBindingDivisorDescriptionEXT"); }
    }
export class VkPipelineVertexInputDivisorStateCreateInfoEXT extends VkSerializable<VkPipelineVertexInputDivisorStateCreateInfoEXTInput, VkPipelineVertexInputDivisorStateCreateInfoEXTDeserialized> {
        public constructor(data: VkPipelineVertexInputDivisorStateCreateInfoEXTInput){ super(data, "VkPipelineVertexInputDivisorStateCreateInfoEXT"); }
    }
export class VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT extends VkSerializable<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTInput, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceVertexAttributeDivisorPropertiesEXTInput){ super(data, "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT"); }
    }
export class VkPhysicalDevicePCIBusInfoPropertiesEXT extends VkSerializable<VkPhysicalDevicePCIBusInfoPropertiesEXTInput, VkPhysicalDevicePCIBusInfoPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDevicePCIBusInfoPropertiesEXTInput){ super(data, "VkPhysicalDevicePCIBusInfoPropertiesEXT"); }
    }
export class VkPhysicalDevice8BitStorageFeatures extends VkSerializable<VkPhysicalDevice8BitStorageFeaturesInput, VkPhysicalDevice8BitStorageFeaturesDeserialized> {
        public constructor(data: VkPhysicalDevice8BitStorageFeaturesInput){ super(data, "VkPhysicalDevice8BitStorageFeatures"); }
    }
export class VkPhysicalDevice8BitStorageFeaturesKHR extends VkSerializable<VkPhysicalDevice8BitStorageFeaturesKHRInput, VkPhysicalDevice8BitStorageFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDevice8BitStorageFeaturesKHRInput){ super(data, "VkPhysicalDevice8BitStorageFeaturesKHR"); }
    }
export class VkPhysicalDeviceVulkanMemoryModelFeatures extends VkSerializable<VkPhysicalDeviceVulkanMemoryModelFeaturesInput, VkPhysicalDeviceVulkanMemoryModelFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceVulkanMemoryModelFeaturesInput){ super(data, "VkPhysicalDeviceVulkanMemoryModelFeatures"); }
    }
export class VkPhysicalDeviceVulkanMemoryModelFeaturesKHR extends VkSerializable<VkPhysicalDeviceVulkanMemoryModelFeaturesKHRInput, VkPhysicalDeviceVulkanMemoryModelFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceVulkanMemoryModelFeaturesKHRInput){ super(data, "VkPhysicalDeviceVulkanMemoryModelFeaturesKHR"); }
    }
export class VkPhysicalDeviceShaderAtomicInt64Features extends VkSerializable<VkPhysicalDeviceShaderAtomicInt64FeaturesInput, VkPhysicalDeviceShaderAtomicInt64FeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderAtomicInt64FeaturesInput){ super(data, "VkPhysicalDeviceShaderAtomicInt64Features"); }
    }
export class VkPhysicalDeviceShaderAtomicInt64FeaturesKHR extends VkSerializable<VkPhysicalDeviceShaderAtomicInt64FeaturesKHRInput, VkPhysicalDeviceShaderAtomicInt64FeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderAtomicInt64FeaturesKHRInput){ super(data, "VkPhysicalDeviceShaderAtomicInt64FeaturesKHR"); }
    }
export class VkPhysicalDeviceShaderAtomicFloatFeaturesEXT extends VkSerializable<VkPhysicalDeviceShaderAtomicFloatFeaturesEXTInput, VkPhysicalDeviceShaderAtomicFloatFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderAtomicFloatFeaturesEXTInput){ super(data, "VkPhysicalDeviceShaderAtomicFloatFeaturesEXT"); }
    }
export class VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT extends VkSerializable<VkPhysicalDeviceShaderAtomicFloat2FeaturesEXTInput, VkPhysicalDeviceShaderAtomicFloat2FeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderAtomicFloat2FeaturesEXTInput){ super(data, "VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT"); }
    }
export class VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT extends VkSerializable<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTInput, VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceVertexAttributeDivisorFeaturesEXTInput){ super(data, "VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT"); }
    }
export class VkPhysicalDeviceDepthStencilResolveProperties extends VkSerializable<VkPhysicalDeviceDepthStencilResolvePropertiesInput, VkPhysicalDeviceDepthStencilResolvePropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceDepthStencilResolvePropertiesInput){ super(data, "VkPhysicalDeviceDepthStencilResolveProperties"); }
    }
export class VkPhysicalDeviceDepthStencilResolvePropertiesKHR extends VkSerializable<VkPhysicalDeviceDepthStencilResolvePropertiesKHRInput, VkPhysicalDeviceDepthStencilResolvePropertiesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceDepthStencilResolvePropertiesKHRInput){ super(data, "VkPhysicalDeviceDepthStencilResolvePropertiesKHR"); }
    }
export class VkSubpassDescriptionDepthStencilResolve extends VkSerializable<VkSubpassDescriptionDepthStencilResolveInput, VkSubpassDescriptionDepthStencilResolveDeserialized> {
        public constructor(data: VkSubpassDescriptionDepthStencilResolveInput){ super(data, "VkSubpassDescriptionDepthStencilResolve"); }
    }
export class VkSubpassDescriptionDepthStencilResolveKHR extends VkSerializable<VkSubpassDescriptionDepthStencilResolveKHRInput, VkSubpassDescriptionDepthStencilResolveKHRDeserialized> {
        public constructor(data: VkSubpassDescriptionDepthStencilResolveKHRInput){ super(data, "VkSubpassDescriptionDepthStencilResolveKHR"); }
    }
export class VkPhysicalDeviceTransformFeedbackFeaturesEXT extends VkSerializable<VkPhysicalDeviceTransformFeedbackFeaturesEXTInput, VkPhysicalDeviceTransformFeedbackFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceTransformFeedbackFeaturesEXTInput){ super(data, "VkPhysicalDeviceTransformFeedbackFeaturesEXT"); }
    }
export class VkPhysicalDeviceTransformFeedbackPropertiesEXT extends VkSerializable<VkPhysicalDeviceTransformFeedbackPropertiesEXTInput, VkPhysicalDeviceTransformFeedbackPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceTransformFeedbackPropertiesEXTInput){ super(data, "VkPhysicalDeviceTransformFeedbackPropertiesEXT"); }
    }
export class VkPipelineRasterizationStateStreamCreateInfoEXT extends VkSerializable<VkPipelineRasterizationStateStreamCreateInfoEXTInput, VkPipelineRasterizationStateStreamCreateInfoEXTDeserialized> {
        public constructor(data: VkPipelineRasterizationStateStreamCreateInfoEXTInput){ super(data, "VkPipelineRasterizationStateStreamCreateInfoEXT"); }
    }
export class VkPhysicalDeviceMeshShaderFeaturesEXT extends VkSerializable<VkPhysicalDeviceMeshShaderFeaturesEXTInput, VkPhysicalDeviceMeshShaderFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceMeshShaderFeaturesEXTInput){ super(data, "VkPhysicalDeviceMeshShaderFeaturesEXT"); }
    }
export class VkPhysicalDeviceMeshShaderPropertiesEXT extends VkSerializable<VkPhysicalDeviceMeshShaderPropertiesEXTInput, VkPhysicalDeviceMeshShaderPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceMeshShaderPropertiesEXTInput){ super(data, "VkPhysicalDeviceMeshShaderPropertiesEXT"); }
    }
export class VkDrawMeshTasksIndirectCommandEXT extends VkSerializable<VkDrawMeshTasksIndirectCommandEXTInput, VkDrawMeshTasksIndirectCommandEXTDeserialized> {
        public constructor(data: VkDrawMeshTasksIndirectCommandEXTInput){ super(data, "VkDrawMeshTasksIndirectCommandEXT"); }
    }
export class VkRayTracingShaderGroupCreateInfoKHR extends VkSerializable<VkRayTracingShaderGroupCreateInfoKHRInput, VkRayTracingShaderGroupCreateInfoKHRDeserialized> {
        public constructor(data: VkRayTracingShaderGroupCreateInfoKHRInput){ super(data, "VkRayTracingShaderGroupCreateInfoKHR"); }
    }
export class VkRayTracingPipelineCreateInfoKHR extends VkSerializable<VkRayTracingPipelineCreateInfoKHRInput, VkRayTracingPipelineCreateInfoKHRDeserialized> {
        public constructor(data: VkRayTracingPipelineCreateInfoKHRInput){ super(data, "VkRayTracingPipelineCreateInfoKHR"); }
    }
export class VkPhysicalDeviceRayTracingPipelineFeaturesKHR extends VkSerializable<VkPhysicalDeviceRayTracingPipelineFeaturesKHRInput, VkPhysicalDeviceRayTracingPipelineFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceRayTracingPipelineFeaturesKHRInput){ super(data, "VkPhysicalDeviceRayTracingPipelineFeaturesKHR"); }
    }
export class VkPhysicalDeviceRayQueryFeaturesKHR extends VkSerializable<VkPhysicalDeviceRayQueryFeaturesKHRInput, VkPhysicalDeviceRayQueryFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceRayQueryFeaturesKHRInput){ super(data, "VkPhysicalDeviceRayQueryFeaturesKHR"); }
    }
export class VkPhysicalDeviceRayTracingPipelinePropertiesKHR extends VkSerializable<VkPhysicalDeviceRayTracingPipelinePropertiesKHRInput, VkPhysicalDeviceRayTracingPipelinePropertiesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceRayTracingPipelinePropertiesKHRInput){ super(data, "VkPhysicalDeviceRayTracingPipelinePropertiesKHR"); }
    }
export class VkStridedDeviceAddressRegionKHR extends VkSerializable<VkStridedDeviceAddressRegionKHRInput, VkStridedDeviceAddressRegionKHRDeserialized> {
        public constructor(data: VkStridedDeviceAddressRegionKHRInput){ super(data, "VkStridedDeviceAddressRegionKHR"); }
    }
export class VkTraceRaysIndirectCommandKHR extends VkSerializable<VkTraceRaysIndirectCommandKHRInput, VkTraceRaysIndirectCommandKHRDeserialized> {
        public constructor(data: VkTraceRaysIndirectCommandKHRInput){ super(data, "VkTraceRaysIndirectCommandKHR"); }
    }
export class VkTraceRaysIndirectCommand2KHR extends VkSerializable<VkTraceRaysIndirectCommand2KHRInput, VkTraceRaysIndirectCommand2KHRDeserialized> {
        public constructor(data: VkTraceRaysIndirectCommand2KHRInput){ super(data, "VkTraceRaysIndirectCommand2KHR"); }
    }
export class VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR extends VkSerializable<VkPhysicalDeviceRayTracingMaintenance1FeaturesKHRInput, VkPhysicalDeviceRayTracingMaintenance1FeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceRayTracingMaintenance1FeaturesKHRInput){ super(data, "VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR"); }
    }
export class VkDrmFormatModifierPropertiesListEXT extends VkSerializable<VkDrmFormatModifierPropertiesListEXTInput, VkDrmFormatModifierPropertiesListEXTDeserialized> {
        public constructor(data: VkDrmFormatModifierPropertiesListEXTInput){ super(data, "VkDrmFormatModifierPropertiesListEXT"); }
    }
export class VkDrmFormatModifierPropertiesEXT extends VkSerializable<VkDrmFormatModifierPropertiesEXTInput, VkDrmFormatModifierPropertiesEXTDeserialized> {
        public constructor(data: VkDrmFormatModifierPropertiesEXTInput){ super(data, "VkDrmFormatModifierPropertiesEXT"); }
    }
export class VkPhysicalDeviceImageDrmFormatModifierInfoEXT extends VkSerializable<VkPhysicalDeviceImageDrmFormatModifierInfoEXTInput, VkPhysicalDeviceImageDrmFormatModifierInfoEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceImageDrmFormatModifierInfoEXTInput){ super(data, "VkPhysicalDeviceImageDrmFormatModifierInfoEXT"); }
    }
export class VkImageDrmFormatModifierListCreateInfoEXT extends VkSerializable<VkImageDrmFormatModifierListCreateInfoEXTInput, VkImageDrmFormatModifierListCreateInfoEXTDeserialized> {
        public constructor(data: VkImageDrmFormatModifierListCreateInfoEXTInput){ super(data, "VkImageDrmFormatModifierListCreateInfoEXT"); }
    }
export class VkImageDrmFormatModifierExplicitCreateInfoEXT extends VkSerializable<VkImageDrmFormatModifierExplicitCreateInfoEXTInput, VkImageDrmFormatModifierExplicitCreateInfoEXTDeserialized> {
        public constructor(data: VkImageDrmFormatModifierExplicitCreateInfoEXTInput){ super(data, "VkImageDrmFormatModifierExplicitCreateInfoEXT"); }
    }
export class VkImageDrmFormatModifierPropertiesEXT extends VkSerializable<VkImageDrmFormatModifierPropertiesEXTInput, VkImageDrmFormatModifierPropertiesEXTDeserialized> {
        public constructor(data: VkImageDrmFormatModifierPropertiesEXTInput){ super(data, "VkImageDrmFormatModifierPropertiesEXT"); }
    }
export class VkImageStencilUsageCreateInfo extends VkSerializable<VkImageStencilUsageCreateInfoInput, VkImageStencilUsageCreateInfoDeserialized> {
        public constructor(data: VkImageStencilUsageCreateInfoInput){ super(data, "VkImageStencilUsageCreateInfo"); }
    }
export class VkImageStencilUsageCreateInfoEXT extends VkSerializable<VkImageStencilUsageCreateInfoEXTInput, VkImageStencilUsageCreateInfoEXTDeserialized> {
        public constructor(data: VkImageStencilUsageCreateInfoEXTInput){ super(data, "VkImageStencilUsageCreateInfoEXT"); }
    }
export class VkPhysicalDeviceFragmentDensityMapFeaturesEXT extends VkSerializable<VkPhysicalDeviceFragmentDensityMapFeaturesEXTInput, VkPhysicalDeviceFragmentDensityMapFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceFragmentDensityMapFeaturesEXTInput){ super(data, "VkPhysicalDeviceFragmentDensityMapFeaturesEXT"); }
    }
export class VkPhysicalDeviceFragmentDensityMap2FeaturesEXT extends VkSerializable<VkPhysicalDeviceFragmentDensityMap2FeaturesEXTInput, VkPhysicalDeviceFragmentDensityMap2FeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceFragmentDensityMap2FeaturesEXTInput){ super(data, "VkPhysicalDeviceFragmentDensityMap2FeaturesEXT"); }
    }
export class VkPhysicalDeviceFragmentDensityMapPropertiesEXT extends VkSerializable<VkPhysicalDeviceFragmentDensityMapPropertiesEXTInput, VkPhysicalDeviceFragmentDensityMapPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceFragmentDensityMapPropertiesEXTInput){ super(data, "VkPhysicalDeviceFragmentDensityMapPropertiesEXT"); }
    }
export class VkPhysicalDeviceFragmentDensityMap2PropertiesEXT extends VkSerializable<VkPhysicalDeviceFragmentDensityMap2PropertiesEXTInput, VkPhysicalDeviceFragmentDensityMap2PropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceFragmentDensityMap2PropertiesEXTInput){ super(data, "VkPhysicalDeviceFragmentDensityMap2PropertiesEXT"); }
    }
export class VkRenderPassFragmentDensityMapCreateInfoEXT extends VkSerializable<VkRenderPassFragmentDensityMapCreateInfoEXTInput, VkRenderPassFragmentDensityMapCreateInfoEXTDeserialized> {
        public constructor(data: VkRenderPassFragmentDensityMapCreateInfoEXTInput){ super(data, "VkRenderPassFragmentDensityMapCreateInfoEXT"); }
    }
export class VkPhysicalDeviceScalarBlockLayoutFeatures extends VkSerializable<VkPhysicalDeviceScalarBlockLayoutFeaturesInput, VkPhysicalDeviceScalarBlockLayoutFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceScalarBlockLayoutFeaturesInput){ super(data, "VkPhysicalDeviceScalarBlockLayoutFeatures"); }
    }
export class VkPhysicalDeviceScalarBlockLayoutFeaturesEXT extends VkSerializable<VkPhysicalDeviceScalarBlockLayoutFeaturesEXTInput, VkPhysicalDeviceScalarBlockLayoutFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceScalarBlockLayoutFeaturesEXTInput){ super(data, "VkPhysicalDeviceScalarBlockLayoutFeaturesEXT"); }
    }
export class VkSurfaceProtectedCapabilitiesKHR extends VkSerializable<VkSurfaceProtectedCapabilitiesKHRInput, VkSurfaceProtectedCapabilitiesKHRDeserialized> {
        public constructor(data: VkSurfaceProtectedCapabilitiesKHRInput){ super(data, "VkSurfaceProtectedCapabilitiesKHR"); }
    }
export class VkPhysicalDeviceUniformBufferStandardLayoutFeatures extends VkSerializable<VkPhysicalDeviceUniformBufferStandardLayoutFeaturesInput, VkPhysicalDeviceUniformBufferStandardLayoutFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceUniformBufferStandardLayoutFeaturesInput){ super(data, "VkPhysicalDeviceUniformBufferStandardLayoutFeatures"); }
    }
export class VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR extends VkSerializable<VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHRInput, VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHRInput){ super(data, "VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR"); }
    }
export class VkPhysicalDeviceMemoryBudgetPropertiesEXT extends VkSerializable<VkPhysicalDeviceMemoryBudgetPropertiesEXTInput, VkPhysicalDeviceMemoryBudgetPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceMemoryBudgetPropertiesEXTInput){ super(data, "VkPhysicalDeviceMemoryBudgetPropertiesEXT"); }
    }
export class VkPhysicalDeviceMemoryPriorityFeaturesEXT extends VkSerializable<VkPhysicalDeviceMemoryPriorityFeaturesEXTInput, VkPhysicalDeviceMemoryPriorityFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceMemoryPriorityFeaturesEXTInput){ super(data, "VkPhysicalDeviceMemoryPriorityFeaturesEXT"); }
    }
export class VkMemoryPriorityAllocateInfoEXT extends VkSerializable<VkMemoryPriorityAllocateInfoEXTInput, VkMemoryPriorityAllocateInfoEXTDeserialized> {
        public constructor(data: VkMemoryPriorityAllocateInfoEXTInput){ super(data, "VkMemoryPriorityAllocateInfoEXT"); }
    }
export class VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT extends VkSerializable<VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXTInput, VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXTInput){ super(data, "VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT"); }
    }
export class VkPhysicalDeviceBufferDeviceAddressFeatures extends VkSerializable<VkPhysicalDeviceBufferDeviceAddressFeaturesInput, VkPhysicalDeviceBufferDeviceAddressFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceBufferDeviceAddressFeaturesInput){ super(data, "VkPhysicalDeviceBufferDeviceAddressFeatures"); }
    }
export class VkPhysicalDeviceBufferDeviceAddressFeaturesKHR extends VkSerializable<VkPhysicalDeviceBufferDeviceAddressFeaturesKHRInput, VkPhysicalDeviceBufferDeviceAddressFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceBufferDeviceAddressFeaturesKHRInput){ super(data, "VkPhysicalDeviceBufferDeviceAddressFeaturesKHR"); }
    }
export class VkBufferDeviceAddressInfo extends VkSerializable<VkBufferDeviceAddressInfoInput, VkBufferDeviceAddressInfoDeserialized> {
        public constructor(data: VkBufferDeviceAddressInfoInput){ super(data, "VkBufferDeviceAddressInfo"); }
    }
export class VkBufferDeviceAddressInfoKHR extends VkSerializable<VkBufferDeviceAddressInfoKHRInput, VkBufferDeviceAddressInfoKHRDeserialized> {
        public constructor(data: VkBufferDeviceAddressInfoKHRInput){ super(data, "VkBufferDeviceAddressInfoKHR"); }
    }
export class VkBufferOpaqueCaptureAddressCreateInfo extends VkSerializable<VkBufferOpaqueCaptureAddressCreateInfoInput, VkBufferOpaqueCaptureAddressCreateInfoDeserialized> {
        public constructor(data: VkBufferOpaqueCaptureAddressCreateInfoInput){ super(data, "VkBufferOpaqueCaptureAddressCreateInfo"); }
    }
export class VkBufferOpaqueCaptureAddressCreateInfoKHR extends VkSerializable<VkBufferOpaqueCaptureAddressCreateInfoKHRInput, VkBufferOpaqueCaptureAddressCreateInfoKHRDeserialized> {
        public constructor(data: VkBufferOpaqueCaptureAddressCreateInfoKHRInput){ super(data, "VkBufferOpaqueCaptureAddressCreateInfoKHR"); }
    }
export class VkPhysicalDeviceImageViewImageFormatInfoEXT extends VkSerializable<VkPhysicalDeviceImageViewImageFormatInfoEXTInput, VkPhysicalDeviceImageViewImageFormatInfoEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceImageViewImageFormatInfoEXTInput){ super(data, "VkPhysicalDeviceImageViewImageFormatInfoEXT"); }
    }
export class VkFilterCubicImageViewImageFormatPropertiesEXT extends VkSerializable<VkFilterCubicImageViewImageFormatPropertiesEXTInput, VkFilterCubicImageViewImageFormatPropertiesEXTDeserialized> {
        public constructor(data: VkFilterCubicImageViewImageFormatPropertiesEXTInput){ super(data, "VkFilterCubicImageViewImageFormatPropertiesEXT"); }
    }
export class VkPhysicalDeviceImagelessFramebufferFeatures extends VkSerializable<VkPhysicalDeviceImagelessFramebufferFeaturesInput, VkPhysicalDeviceImagelessFramebufferFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceImagelessFramebufferFeaturesInput){ super(data, "VkPhysicalDeviceImagelessFramebufferFeatures"); }
    }
export class VkPhysicalDeviceImagelessFramebufferFeaturesKHR extends VkSerializable<VkPhysicalDeviceImagelessFramebufferFeaturesKHRInput, VkPhysicalDeviceImagelessFramebufferFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceImagelessFramebufferFeaturesKHRInput){ super(data, "VkPhysicalDeviceImagelessFramebufferFeaturesKHR"); }
    }
export class VkFramebufferAttachmentsCreateInfo extends VkSerializable<VkFramebufferAttachmentsCreateInfoInput, VkFramebufferAttachmentsCreateInfoDeserialized> {
        public constructor(data: VkFramebufferAttachmentsCreateInfoInput){ super(data, "VkFramebufferAttachmentsCreateInfo"); }
    }
export class VkFramebufferAttachmentsCreateInfoKHR extends VkSerializable<VkFramebufferAttachmentsCreateInfoKHRInput, VkFramebufferAttachmentsCreateInfoKHRDeserialized> {
        public constructor(data: VkFramebufferAttachmentsCreateInfoKHRInput){ super(data, "VkFramebufferAttachmentsCreateInfoKHR"); }
    }
export class VkFramebufferAttachmentImageInfo extends VkSerializable<VkFramebufferAttachmentImageInfoInput, VkFramebufferAttachmentImageInfoDeserialized> {
        public constructor(data: VkFramebufferAttachmentImageInfoInput){ super(data, "VkFramebufferAttachmentImageInfo"); }
    }
export class VkFramebufferAttachmentImageInfoKHR extends VkSerializable<VkFramebufferAttachmentImageInfoKHRInput, VkFramebufferAttachmentImageInfoKHRDeserialized> {
        public constructor(data: VkFramebufferAttachmentImageInfoKHRInput){ super(data, "VkFramebufferAttachmentImageInfoKHR"); }
    }
export class VkRenderPassAttachmentBeginInfo extends VkSerializable<VkRenderPassAttachmentBeginInfoInput, VkRenderPassAttachmentBeginInfoDeserialized> {
        public constructor(data: VkRenderPassAttachmentBeginInfoInput){ super(data, "VkRenderPassAttachmentBeginInfo"); }
    }
export class VkRenderPassAttachmentBeginInfoKHR extends VkSerializable<VkRenderPassAttachmentBeginInfoKHRInput, VkRenderPassAttachmentBeginInfoKHRDeserialized> {
        public constructor(data: VkRenderPassAttachmentBeginInfoKHRInput){ super(data, "VkRenderPassAttachmentBeginInfoKHR"); }
    }
export class VkPhysicalDeviceTextureCompressionASTCHDRFeatures extends VkSerializable<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesInput, VkPhysicalDeviceTextureCompressionASTCHDRFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceTextureCompressionASTCHDRFeaturesInput){ super(data, "VkPhysicalDeviceTextureCompressionASTCHDRFeatures"); }
    }
export class VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT extends VkSerializable<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTInput, VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTInput){ super(data, "VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT"); }
    }
export class VkPhysicalDeviceYcbcrImageArraysFeaturesEXT extends VkSerializable<VkPhysicalDeviceYcbcrImageArraysFeaturesEXTInput, VkPhysicalDeviceYcbcrImageArraysFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceYcbcrImageArraysFeaturesEXTInput){ super(data, "VkPhysicalDeviceYcbcrImageArraysFeaturesEXT"); }
    }
export class VkPipelineCreationFeedback extends VkSerializable<VkPipelineCreationFeedbackInput, VkPipelineCreationFeedbackDeserialized> {
        public constructor(data: VkPipelineCreationFeedbackInput){ super(data, "VkPipelineCreationFeedback"); }
    }
export class VkPipelineCreationFeedbackEXT extends VkSerializable<VkPipelineCreationFeedbackEXTInput, VkPipelineCreationFeedbackEXTDeserialized> {
        public constructor(data: VkPipelineCreationFeedbackEXTInput){ super(data, "VkPipelineCreationFeedbackEXT"); }
    }
export class VkPipelineCreationFeedbackCreateInfo extends VkSerializable<VkPipelineCreationFeedbackCreateInfoInput, VkPipelineCreationFeedbackCreateInfoDeserialized> {
        public constructor(data: VkPipelineCreationFeedbackCreateInfoInput){ super(data, "VkPipelineCreationFeedbackCreateInfo"); }
    }
export class VkPipelineCreationFeedbackCreateInfoEXT extends VkSerializable<VkPipelineCreationFeedbackCreateInfoEXTInput, VkPipelineCreationFeedbackCreateInfoEXTDeserialized> {
        public constructor(data: VkPipelineCreationFeedbackCreateInfoEXTInput){ super(data, "VkPipelineCreationFeedbackCreateInfoEXT"); }
    }
export class VkHeadlessSurfaceCreateInfoEXT extends VkSerializable<VkHeadlessSurfaceCreateInfoEXTInput, VkHeadlessSurfaceCreateInfoEXTDeserialized> {
        public constructor(data: VkHeadlessSurfaceCreateInfoEXTInput){ super(data, "VkHeadlessSurfaceCreateInfoEXT"); }
    }
export class VkPhysicalDeviceShaderClockFeaturesKHR extends VkSerializable<VkPhysicalDeviceShaderClockFeaturesKHRInput, VkPhysicalDeviceShaderClockFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderClockFeaturesKHRInput){ super(data, "VkPhysicalDeviceShaderClockFeaturesKHR"); }
    }
export class VkPhysicalDeviceIndexTypeUint8FeaturesEXT extends VkSerializable<VkPhysicalDeviceIndexTypeUint8FeaturesEXTInput, VkPhysicalDeviceIndexTypeUint8FeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceIndexTypeUint8FeaturesEXTInput){ super(data, "VkPhysicalDeviceIndexTypeUint8FeaturesEXT"); }
    }
export class VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT extends VkSerializable<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTInput, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceFragmentShaderInterlockFeaturesEXTInput){ super(data, "VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT"); }
    }
export class VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures extends VkSerializable<VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesInput, VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesInput){ super(data, "VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures"); }
    }
export class VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR extends VkSerializable<VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHRInput, VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHRInput){ super(data, "VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR"); }
    }
export class VkAttachmentReferenceStencilLayout extends VkSerializable<VkAttachmentReferenceStencilLayoutInput, VkAttachmentReferenceStencilLayoutDeserialized> {
        public constructor(data: VkAttachmentReferenceStencilLayoutInput){ super(data, "VkAttachmentReferenceStencilLayout"); }
    }
export class VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT extends VkSerializable<VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXTInput, VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXTInput){ super(data, "VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT"); }
    }
export class VkAttachmentReferenceStencilLayoutKHR extends VkSerializable<VkAttachmentReferenceStencilLayoutKHRInput, VkAttachmentReferenceStencilLayoutKHRDeserialized> {
        public constructor(data: VkAttachmentReferenceStencilLayoutKHRInput){ super(data, "VkAttachmentReferenceStencilLayoutKHR"); }
    }
export class VkAttachmentDescriptionStencilLayout extends VkSerializable<VkAttachmentDescriptionStencilLayoutInput, VkAttachmentDescriptionStencilLayoutDeserialized> {
        public constructor(data: VkAttachmentDescriptionStencilLayoutInput){ super(data, "VkAttachmentDescriptionStencilLayout"); }
    }
export class VkAttachmentDescriptionStencilLayoutKHR extends VkSerializable<VkAttachmentDescriptionStencilLayoutKHRInput, VkAttachmentDescriptionStencilLayoutKHRDeserialized> {
        public constructor(data: VkAttachmentDescriptionStencilLayoutKHRInput){ super(data, "VkAttachmentDescriptionStencilLayoutKHR"); }
    }
export class VkPipelineInfoEXT extends VkSerializable<VkPipelineInfoEXTInput, VkPipelineInfoEXTDeserialized> {
        public constructor(data: VkPipelineInfoEXTInput){ super(data, "VkPipelineInfoEXT"); }
    }
export class VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures extends VkSerializable<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesInput, VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesInput){ super(data, "VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures"); }
    }
export class VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT extends VkSerializable<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTInput, VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTInput){ super(data, "VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT"); }
    }
export class VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT extends VkSerializable<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTInput, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceTexelBufferAlignmentFeaturesEXTInput){ super(data, "VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT"); }
    }
export class VkPhysicalDeviceTexelBufferAlignmentProperties extends VkSerializable<VkPhysicalDeviceTexelBufferAlignmentPropertiesInput, VkPhysicalDeviceTexelBufferAlignmentPropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceTexelBufferAlignmentPropertiesInput){ super(data, "VkPhysicalDeviceTexelBufferAlignmentProperties"); }
    }
export class VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT extends VkSerializable<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTInput, VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceTexelBufferAlignmentPropertiesEXTInput){ super(data, "VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT"); }
    }
export class VkPhysicalDeviceSubgroupSizeControlFeatures extends VkSerializable<VkPhysicalDeviceSubgroupSizeControlFeaturesInput, VkPhysicalDeviceSubgroupSizeControlFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceSubgroupSizeControlFeaturesInput){ super(data, "VkPhysicalDeviceSubgroupSizeControlFeatures"); }
    }
export class VkPhysicalDeviceSubgroupSizeControlFeaturesEXT extends VkSerializable<VkPhysicalDeviceSubgroupSizeControlFeaturesEXTInput, VkPhysicalDeviceSubgroupSizeControlFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceSubgroupSizeControlFeaturesEXTInput){ super(data, "VkPhysicalDeviceSubgroupSizeControlFeaturesEXT"); }
    }
export class VkPhysicalDeviceSubgroupSizeControlProperties extends VkSerializable<VkPhysicalDeviceSubgroupSizeControlPropertiesInput, VkPhysicalDeviceSubgroupSizeControlPropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceSubgroupSizeControlPropertiesInput){ super(data, "VkPhysicalDeviceSubgroupSizeControlProperties"); }
    }
export class VkPhysicalDeviceSubgroupSizeControlPropertiesEXT extends VkSerializable<VkPhysicalDeviceSubgroupSizeControlPropertiesEXTInput, VkPhysicalDeviceSubgroupSizeControlPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceSubgroupSizeControlPropertiesEXTInput){ super(data, "VkPhysicalDeviceSubgroupSizeControlPropertiesEXT"); }
    }
export class VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT extends VkSerializable<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTInput, VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTDeserialized> {
        public constructor(data: VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTInput){ super(data, "VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT"); }
    }
export class VkMemoryOpaqueCaptureAddressAllocateInfo extends VkSerializable<VkMemoryOpaqueCaptureAddressAllocateInfoInput, VkMemoryOpaqueCaptureAddressAllocateInfoDeserialized> {
        public constructor(data: VkMemoryOpaqueCaptureAddressAllocateInfoInput){ super(data, "VkMemoryOpaqueCaptureAddressAllocateInfo"); }
    }
export class VkMemoryOpaqueCaptureAddressAllocateInfoKHR extends VkSerializable<VkMemoryOpaqueCaptureAddressAllocateInfoKHRInput, VkMemoryOpaqueCaptureAddressAllocateInfoKHRDeserialized> {
        public constructor(data: VkMemoryOpaqueCaptureAddressAllocateInfoKHRInput){ super(data, "VkMemoryOpaqueCaptureAddressAllocateInfoKHR"); }
    }
export class VkDeviceMemoryOpaqueCaptureAddressInfo extends VkSerializable<VkDeviceMemoryOpaqueCaptureAddressInfoInput, VkDeviceMemoryOpaqueCaptureAddressInfoDeserialized> {
        public constructor(data: VkDeviceMemoryOpaqueCaptureAddressInfoInput){ super(data, "VkDeviceMemoryOpaqueCaptureAddressInfo"); }
    }
export class VkDeviceMemoryOpaqueCaptureAddressInfoKHR extends VkSerializable<VkDeviceMemoryOpaqueCaptureAddressInfoKHRInput, VkDeviceMemoryOpaqueCaptureAddressInfoKHRDeserialized> {
        public constructor(data: VkDeviceMemoryOpaqueCaptureAddressInfoKHRInput){ super(data, "VkDeviceMemoryOpaqueCaptureAddressInfoKHR"); }
    }
export class VkPhysicalDeviceLineRasterizationFeaturesEXT extends VkSerializable<VkPhysicalDeviceLineRasterizationFeaturesEXTInput, VkPhysicalDeviceLineRasterizationFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceLineRasterizationFeaturesEXTInput){ super(data, "VkPhysicalDeviceLineRasterizationFeaturesEXT"); }
    }
export class VkPhysicalDeviceLineRasterizationPropertiesEXT extends VkSerializable<VkPhysicalDeviceLineRasterizationPropertiesEXTInput, VkPhysicalDeviceLineRasterizationPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceLineRasterizationPropertiesEXTInput){ super(data, "VkPhysicalDeviceLineRasterizationPropertiesEXT"); }
    }
export class VkPipelineRasterizationLineStateCreateInfoEXT extends VkSerializable<VkPipelineRasterizationLineStateCreateInfoEXTInput, VkPipelineRasterizationLineStateCreateInfoEXTDeserialized> {
        public constructor(data: VkPipelineRasterizationLineStateCreateInfoEXTInput){ super(data, "VkPipelineRasterizationLineStateCreateInfoEXT"); }
    }
export class VkPhysicalDevicePipelineCreationCacheControlFeatures extends VkSerializable<VkPhysicalDevicePipelineCreationCacheControlFeaturesInput, VkPhysicalDevicePipelineCreationCacheControlFeaturesDeserialized> {
        public constructor(data: VkPhysicalDevicePipelineCreationCacheControlFeaturesInput){ super(data, "VkPhysicalDevicePipelineCreationCacheControlFeatures"); }
    }
export class VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT extends VkSerializable<VkPhysicalDevicePipelineCreationCacheControlFeaturesEXTInput, VkPhysicalDevicePipelineCreationCacheControlFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDevicePipelineCreationCacheControlFeaturesEXTInput){ super(data, "VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT"); }
    }
export class VkPhysicalDeviceVulkan11Features extends VkSerializable<VkPhysicalDeviceVulkan11FeaturesInput, VkPhysicalDeviceVulkan11FeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceVulkan11FeaturesInput){ super(data, "VkPhysicalDeviceVulkan11Features"); }
    }
export class VkPhysicalDeviceVulkan11Properties extends VkSerializable<VkPhysicalDeviceVulkan11PropertiesInput, VkPhysicalDeviceVulkan11PropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceVulkan11PropertiesInput){ super(data, "VkPhysicalDeviceVulkan11Properties"); }
    }
export class VkPhysicalDeviceVulkan12Features extends VkSerializable<VkPhysicalDeviceVulkan12FeaturesInput, VkPhysicalDeviceVulkan12FeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceVulkan12FeaturesInput){ super(data, "VkPhysicalDeviceVulkan12Features"); }
    }
export class VkPhysicalDeviceVulkan12Properties extends VkSerializable<VkPhysicalDeviceVulkan12PropertiesInput, VkPhysicalDeviceVulkan12PropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceVulkan12PropertiesInput){ super(data, "VkPhysicalDeviceVulkan12Properties"); }
    }
export class VkPhysicalDeviceVulkan13Features extends VkSerializable<VkPhysicalDeviceVulkan13FeaturesInput, VkPhysicalDeviceVulkan13FeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceVulkan13FeaturesInput){ super(data, "VkPhysicalDeviceVulkan13Features"); }
    }
export class VkPhysicalDeviceVulkan13Properties extends VkSerializable<VkPhysicalDeviceVulkan13PropertiesInput, VkPhysicalDeviceVulkan13PropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceVulkan13PropertiesInput){ super(data, "VkPhysicalDeviceVulkan13Properties"); }
    }
export class VkPhysicalDeviceToolProperties extends VkSerializable<VkPhysicalDeviceToolPropertiesInput, VkPhysicalDeviceToolPropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceToolPropertiesInput){ super(data, "VkPhysicalDeviceToolProperties"); }
    }
export class VkPhysicalDeviceToolPropertiesEXT extends VkSerializable<VkPhysicalDeviceToolPropertiesEXTInput, VkPhysicalDeviceToolPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceToolPropertiesEXTInput){ super(data, "VkPhysicalDeviceToolPropertiesEXT"); }
    }
export class VkRayTracingPipelineInterfaceCreateInfoKHR extends VkSerializable<VkRayTracingPipelineInterfaceCreateInfoKHRInput, VkRayTracingPipelineInterfaceCreateInfoKHRDeserialized> {
        public constructor(data: VkRayTracingPipelineInterfaceCreateInfoKHRInput){ super(data, "VkRayTracingPipelineInterfaceCreateInfoKHR"); }
    }
export class VkPipelineLibraryCreateInfoKHR extends VkSerializable<VkPipelineLibraryCreateInfoKHRInput, VkPipelineLibraryCreateInfoKHRDeserialized> {
        public constructor(data: VkPipelineLibraryCreateInfoKHRInput){ super(data, "VkPipelineLibraryCreateInfoKHR"); }
    }
export class VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures extends VkSerializable<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesInput, VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesInput){ super(data, "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures"); }
    }
export class VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR extends VkSerializable<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHRInput, VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHRInput){ super(data, "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR"); }
    }
export class VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR extends VkSerializable<VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRInput, VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRInput){ super(data, "VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR"); }
    }
export class VkPhysicalDeviceRobustness2FeaturesEXT extends VkSerializable<VkPhysicalDeviceRobustness2FeaturesEXTInput, VkPhysicalDeviceRobustness2FeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceRobustness2FeaturesEXTInput){ super(data, "VkPhysicalDeviceRobustness2FeaturesEXT"); }
    }
export class VkPhysicalDeviceRobustness2PropertiesEXT extends VkSerializable<VkPhysicalDeviceRobustness2PropertiesEXTInput, VkPhysicalDeviceRobustness2PropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceRobustness2PropertiesEXTInput){ super(data, "VkPhysicalDeviceRobustness2PropertiesEXT"); }
    }
export class VkPhysicalDeviceImageRobustnessFeatures extends VkSerializable<VkPhysicalDeviceImageRobustnessFeaturesInput, VkPhysicalDeviceImageRobustnessFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceImageRobustnessFeaturesInput){ super(data, "VkPhysicalDeviceImageRobustnessFeatures"); }
    }
export class VkPhysicalDeviceImageRobustnessFeaturesEXT extends VkSerializable<VkPhysicalDeviceImageRobustnessFeaturesEXTInput, VkPhysicalDeviceImageRobustnessFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceImageRobustnessFeaturesEXTInput){ super(data, "VkPhysicalDeviceImageRobustnessFeaturesEXT"); }
    }
export class VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR extends VkSerializable<VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRInput, VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRInput){ super(data, "VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR"); }
    }
export class VkBufferCopy2 extends VkSerializable<VkBufferCopy2Input, VkBufferCopy2Deserialized> {
        public constructor(data: VkBufferCopy2Input){ super(data, "VkBufferCopy2"); }
    }
export class VkBufferCopy2KHR extends VkSerializable<VkBufferCopy2KHRInput, VkBufferCopy2KHRDeserialized> {
        public constructor(data: VkBufferCopy2KHRInput){ super(data, "VkBufferCopy2KHR"); }
    }
export class VkImageCopy2 extends VkSerializable<VkImageCopy2Input, VkImageCopy2Deserialized> {
        public constructor(data: VkImageCopy2Input){ super(data, "VkImageCopy2"); }
    }
export class VkImageCopy2KHR extends VkSerializable<VkImageCopy2KHRInput, VkImageCopy2KHRDeserialized> {
        public constructor(data: VkImageCopy2KHRInput){ super(data, "VkImageCopy2KHR"); }
    }
export class VkImageBlit2 extends VkSerializable<VkImageBlit2Input, VkImageBlit2Deserialized> {
        public constructor(data: VkImageBlit2Input){ super(data, "VkImageBlit2"); }
    }
export class VkImageBlit2KHR extends VkSerializable<VkImageBlit2KHRInput, VkImageBlit2KHRDeserialized> {
        public constructor(data: VkImageBlit2KHRInput){ super(data, "VkImageBlit2KHR"); }
    }
export class VkBufferImageCopy2 extends VkSerializable<VkBufferImageCopy2Input, VkBufferImageCopy2Deserialized> {
        public constructor(data: VkBufferImageCopy2Input){ super(data, "VkBufferImageCopy2"); }
    }
export class VkBufferImageCopy2KHR extends VkSerializable<VkBufferImageCopy2KHRInput, VkBufferImageCopy2KHRDeserialized> {
        public constructor(data: VkBufferImageCopy2KHRInput){ super(data, "VkBufferImageCopy2KHR"); }
    }
export class VkImageResolve2 extends VkSerializable<VkImageResolve2Input, VkImageResolve2Deserialized> {
        public constructor(data: VkImageResolve2Input){ super(data, "VkImageResolve2"); }
    }
export class VkImageResolve2KHR extends VkSerializable<VkImageResolve2KHRInput, VkImageResolve2KHRDeserialized> {
        public constructor(data: VkImageResolve2KHRInput){ super(data, "VkImageResolve2KHR"); }
    }
export class VkCopyBufferInfo2 extends VkSerializable<VkCopyBufferInfo2Input, VkCopyBufferInfo2Deserialized> {
        public constructor(data: VkCopyBufferInfo2Input){ super(data, "VkCopyBufferInfo2"); }
    }
export class VkCopyBufferInfo2KHR extends VkSerializable<VkCopyBufferInfo2KHRInput, VkCopyBufferInfo2KHRDeserialized> {
        public constructor(data: VkCopyBufferInfo2KHRInput){ super(data, "VkCopyBufferInfo2KHR"); }
    }
export class VkCopyImageInfo2 extends VkSerializable<VkCopyImageInfo2Input, VkCopyImageInfo2Deserialized> {
        public constructor(data: VkCopyImageInfo2Input){ super(data, "VkCopyImageInfo2"); }
    }
export class VkCopyImageInfo2KHR extends VkSerializable<VkCopyImageInfo2KHRInput, VkCopyImageInfo2KHRDeserialized> {
        public constructor(data: VkCopyImageInfo2KHRInput){ super(data, "VkCopyImageInfo2KHR"); }
    }
export class VkBlitImageInfo2 extends VkSerializable<VkBlitImageInfo2Input, VkBlitImageInfo2Deserialized> {
        public constructor(data: VkBlitImageInfo2Input){ super(data, "VkBlitImageInfo2"); }
    }
export class VkBlitImageInfo2KHR extends VkSerializable<VkBlitImageInfo2KHRInput, VkBlitImageInfo2KHRDeserialized> {
        public constructor(data: VkBlitImageInfo2KHRInput){ super(data, "VkBlitImageInfo2KHR"); }
    }
export class VkCopyBufferToImageInfo2 extends VkSerializable<VkCopyBufferToImageInfo2Input, VkCopyBufferToImageInfo2Deserialized> {
        public constructor(data: VkCopyBufferToImageInfo2Input){ super(data, "VkCopyBufferToImageInfo2"); }
    }
export class VkCopyBufferToImageInfo2KHR extends VkSerializable<VkCopyBufferToImageInfo2KHRInput, VkCopyBufferToImageInfo2KHRDeserialized> {
        public constructor(data: VkCopyBufferToImageInfo2KHRInput){ super(data, "VkCopyBufferToImageInfo2KHR"); }
    }
export class VkCopyImageToBufferInfo2 extends VkSerializable<VkCopyImageToBufferInfo2Input, VkCopyImageToBufferInfo2Deserialized> {
        public constructor(data: VkCopyImageToBufferInfo2Input){ super(data, "VkCopyImageToBufferInfo2"); }
    }
export class VkCopyImageToBufferInfo2KHR extends VkSerializable<VkCopyImageToBufferInfo2KHRInput, VkCopyImageToBufferInfo2KHRDeserialized> {
        public constructor(data: VkCopyImageToBufferInfo2KHRInput){ super(data, "VkCopyImageToBufferInfo2KHR"); }
    }
export class VkResolveImageInfo2 extends VkSerializable<VkResolveImageInfo2Input, VkResolveImageInfo2Deserialized> {
        public constructor(data: VkResolveImageInfo2Input){ super(data, "VkResolveImageInfo2"); }
    }
export class VkResolveImageInfo2KHR extends VkSerializable<VkResolveImageInfo2KHRInput, VkResolveImageInfo2KHRDeserialized> {
        public constructor(data: VkResolveImageInfo2KHRInput){ super(data, "VkResolveImageInfo2KHR"); }
    }
export class VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT extends VkSerializable<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTInput, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTInput){ super(data, "VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT"); }
    }
export class VkFragmentShadingRateAttachmentInfoKHR extends VkSerializable<VkFragmentShadingRateAttachmentInfoKHRInput, VkFragmentShadingRateAttachmentInfoKHRDeserialized> {
        public constructor(data: VkFragmentShadingRateAttachmentInfoKHRInput){ super(data, "VkFragmentShadingRateAttachmentInfoKHR"); }
    }
export class VkPipelineFragmentShadingRateStateCreateInfoKHR extends VkSerializable<VkPipelineFragmentShadingRateStateCreateInfoKHRInput, VkPipelineFragmentShadingRateStateCreateInfoKHRDeserialized> {
        public constructor(data: VkPipelineFragmentShadingRateStateCreateInfoKHRInput){ super(data, "VkPipelineFragmentShadingRateStateCreateInfoKHR"); }
    }
export class VkPhysicalDeviceFragmentShadingRateFeaturesKHR extends VkSerializable<VkPhysicalDeviceFragmentShadingRateFeaturesKHRInput, VkPhysicalDeviceFragmentShadingRateFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceFragmentShadingRateFeaturesKHRInput){ super(data, "VkPhysicalDeviceFragmentShadingRateFeaturesKHR"); }
    }
export class VkPhysicalDeviceFragmentShadingRatePropertiesKHR extends VkSerializable<VkPhysicalDeviceFragmentShadingRatePropertiesKHRInput, VkPhysicalDeviceFragmentShadingRatePropertiesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceFragmentShadingRatePropertiesKHRInput){ super(data, "VkPhysicalDeviceFragmentShadingRatePropertiesKHR"); }
    }
export class VkPhysicalDeviceFragmentShadingRateKHR extends VkSerializable<VkPhysicalDeviceFragmentShadingRateKHRInput, VkPhysicalDeviceFragmentShadingRateKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceFragmentShadingRateKHRInput){ super(data, "VkPhysicalDeviceFragmentShadingRateKHR"); }
    }
export class VkPhysicalDeviceShaderTerminateInvocationFeatures extends VkSerializable<VkPhysicalDeviceShaderTerminateInvocationFeaturesInput, VkPhysicalDeviceShaderTerminateInvocationFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderTerminateInvocationFeaturesInput){ super(data, "VkPhysicalDeviceShaderTerminateInvocationFeatures"); }
    }
export class VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR extends VkSerializable<VkPhysicalDeviceShaderTerminateInvocationFeaturesKHRInput, VkPhysicalDeviceShaderTerminateInvocationFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderTerminateInvocationFeaturesKHRInput){ super(data, "VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR"); }
    }
export class VkPhysicalDeviceImage2DViewOf3DFeaturesEXT extends VkSerializable<VkPhysicalDeviceImage2DViewOf3DFeaturesEXTInput, VkPhysicalDeviceImage2DViewOf3DFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceImage2DViewOf3DFeaturesEXTInput){ super(data, "VkPhysicalDeviceImage2DViewOf3DFeaturesEXT"); }
    }
export class VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT extends VkSerializable<VkPhysicalDeviceMutableDescriptorTypeFeaturesEXTInput, VkPhysicalDeviceMutableDescriptorTypeFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceMutableDescriptorTypeFeaturesEXTInput){ super(data, "VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT"); }
    }
export class VkMutableDescriptorTypeListEXT extends VkSerializable<VkMutableDescriptorTypeListEXTInput, VkMutableDescriptorTypeListEXTDeserialized> {
        public constructor(data: VkMutableDescriptorTypeListEXTInput){ super(data, "VkMutableDescriptorTypeListEXT"); }
    }
export class VkMutableDescriptorTypeCreateInfoEXT extends VkSerializable<VkMutableDescriptorTypeCreateInfoEXTInput, VkMutableDescriptorTypeCreateInfoEXTDeserialized> {
        public constructor(data: VkMutableDescriptorTypeCreateInfoEXTInput){ super(data, "VkMutableDescriptorTypeCreateInfoEXT"); }
    }
export class VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT extends VkSerializable<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXTInput, VkPhysicalDeviceVertexInputDynamicStateFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceVertexInputDynamicStateFeaturesEXTInput){ super(data, "VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT"); }
    }
export class VkMemoryBarrier2 extends VkSerializable<VkMemoryBarrier2Input, VkMemoryBarrier2Deserialized> {
        public constructor(data: VkMemoryBarrier2Input){ super(data, "VkMemoryBarrier2"); }
    }
export class VkMemoryBarrier2KHR extends VkSerializable<VkMemoryBarrier2KHRInput, VkMemoryBarrier2KHRDeserialized> {
        public constructor(data: VkMemoryBarrier2KHRInput){ super(data, "VkMemoryBarrier2KHR"); }
    }
export class VkImageMemoryBarrier2 extends VkSerializable<VkImageMemoryBarrier2Input, VkImageMemoryBarrier2Deserialized> {
        public constructor(data: VkImageMemoryBarrier2Input){ super(data, "VkImageMemoryBarrier2"); }
    }
export class VkImageMemoryBarrier2KHR extends VkSerializable<VkImageMemoryBarrier2KHRInput, VkImageMemoryBarrier2KHRDeserialized> {
        public constructor(data: VkImageMemoryBarrier2KHRInput){ super(data, "VkImageMemoryBarrier2KHR"); }
    }
export class VkBufferMemoryBarrier2 extends VkSerializable<VkBufferMemoryBarrier2Input, VkBufferMemoryBarrier2Deserialized> {
        public constructor(data: VkBufferMemoryBarrier2Input){ super(data, "VkBufferMemoryBarrier2"); }
    }
export class VkBufferMemoryBarrier2KHR extends VkSerializable<VkBufferMemoryBarrier2KHRInput, VkBufferMemoryBarrier2KHRDeserialized> {
        public constructor(data: VkBufferMemoryBarrier2KHRInput){ super(data, "VkBufferMemoryBarrier2KHR"); }
    }
export class VkDependencyInfo extends VkSerializable<VkDependencyInfoInput, VkDependencyInfoDeserialized> {
        public constructor(data: VkDependencyInfoInput){ super(data, "VkDependencyInfo"); }
    }
export class VkDependencyInfoKHR extends VkSerializable<VkDependencyInfoKHRInput, VkDependencyInfoKHRDeserialized> {
        public constructor(data: VkDependencyInfoKHRInput){ super(data, "VkDependencyInfoKHR"); }
    }
export class VkSemaphoreSubmitInfo extends VkSerializable<VkSemaphoreSubmitInfoInput, VkSemaphoreSubmitInfoDeserialized> {
        public constructor(data: VkSemaphoreSubmitInfoInput){ super(data, "VkSemaphoreSubmitInfo"); }
    }
export class VkSemaphoreSubmitInfoKHR extends VkSerializable<VkSemaphoreSubmitInfoKHRInput, VkSemaphoreSubmitInfoKHRDeserialized> {
        public constructor(data: VkSemaphoreSubmitInfoKHRInput){ super(data, "VkSemaphoreSubmitInfoKHR"); }
    }
export class VkCommandBufferSubmitInfo extends VkSerializable<VkCommandBufferSubmitInfoInput, VkCommandBufferSubmitInfoDeserialized> {
        public constructor(data: VkCommandBufferSubmitInfoInput){ super(data, "VkCommandBufferSubmitInfo"); }
    }
export class VkCommandBufferSubmitInfoKHR extends VkSerializable<VkCommandBufferSubmitInfoKHRInput, VkCommandBufferSubmitInfoKHRDeserialized> {
        public constructor(data: VkCommandBufferSubmitInfoKHRInput){ super(data, "VkCommandBufferSubmitInfoKHR"); }
    }
export class VkSubmitInfo2 extends VkSerializable<VkSubmitInfo2Input, VkSubmitInfo2Deserialized> {
        public constructor(data: VkSubmitInfo2Input){ super(data, "VkSubmitInfo2"); }
    }
export class VkSubmitInfo2KHR extends VkSerializable<VkSubmitInfo2KHRInput, VkSubmitInfo2KHRDeserialized> {
        public constructor(data: VkSubmitInfo2KHRInput){ super(data, "VkSubmitInfo2KHR"); }
    }
export class VkQueueFamilyCheckpointProperties2NV extends VkSerializable<VkQueueFamilyCheckpointProperties2NVInput, VkQueueFamilyCheckpointProperties2NVDeserialized> {
        public constructor(data: VkQueueFamilyCheckpointProperties2NVInput){ super(data, "VkQueueFamilyCheckpointProperties2NV"); }
    }
export class VkCheckpointData2NV extends VkSerializable<VkCheckpointData2NVInput, VkCheckpointData2NVDeserialized> {
        public constructor(data: VkCheckpointData2NVInput){ super(data, "VkCheckpointData2NV"); }
    }
export class VkPhysicalDeviceSynchronization2Features extends VkSerializable<VkPhysicalDeviceSynchronization2FeaturesInput, VkPhysicalDeviceSynchronization2FeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceSynchronization2FeaturesInput){ super(data, "VkPhysicalDeviceSynchronization2Features"); }
    }
export class VkPhysicalDeviceSynchronization2FeaturesKHR extends VkSerializable<VkPhysicalDeviceSynchronization2FeaturesKHRInput, VkPhysicalDeviceSynchronization2FeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceSynchronization2FeaturesKHRInput){ super(data, "VkPhysicalDeviceSynchronization2FeaturesKHR"); }
    }
export class VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT extends VkSerializable<VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXTInput, VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXTInput){ super(data, "VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT"); }
    }
export class VkPhysicalDeviceLegacyDitheringFeaturesEXT extends VkSerializable<VkPhysicalDeviceLegacyDitheringFeaturesEXTInput, VkPhysicalDeviceLegacyDitheringFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceLegacyDitheringFeaturesEXTInput){ super(data, "VkPhysicalDeviceLegacyDitheringFeaturesEXT"); }
    }
export class VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT extends VkSerializable<VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTInput, VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTInput){ super(data, "VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT"); }
    }
export class VkSubpassResolvePerformanceQueryEXT extends VkSerializable<VkSubpassResolvePerformanceQueryEXTInput, VkSubpassResolvePerformanceQueryEXTDeserialized> {
        public constructor(data: VkSubpassResolvePerformanceQueryEXTInput){ super(data, "VkSubpassResolvePerformanceQueryEXT"); }
    }
export class VkMultisampledRenderToSingleSampledInfoEXT extends VkSerializable<VkMultisampledRenderToSingleSampledInfoEXTInput, VkMultisampledRenderToSingleSampledInfoEXTDeserialized> {
        public constructor(data: VkMultisampledRenderToSingleSampledInfoEXTInput){ super(data, "VkMultisampledRenderToSingleSampledInfoEXT"); }
    }
export class VkPhysicalDevicePipelineProtectedAccessFeaturesEXT extends VkSerializable<VkPhysicalDevicePipelineProtectedAccessFeaturesEXTInput, VkPhysicalDevicePipelineProtectedAccessFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDevicePipelineProtectedAccessFeaturesEXTInput){ super(data, "VkPhysicalDevicePipelineProtectedAccessFeaturesEXT"); }
    }
export class VkQueueFamilyVideoPropertiesKHR extends VkSerializable<VkQueueFamilyVideoPropertiesKHRInput, VkQueueFamilyVideoPropertiesKHRDeserialized> {
        public constructor(data: VkQueueFamilyVideoPropertiesKHRInput){ super(data, "VkQueueFamilyVideoPropertiesKHR"); }
    }
export class VkQueueFamilyQueryResultStatusPropertiesKHR extends VkSerializable<VkQueueFamilyQueryResultStatusPropertiesKHRInput, VkQueueFamilyQueryResultStatusPropertiesKHRDeserialized> {
        public constructor(data: VkQueueFamilyQueryResultStatusPropertiesKHRInput){ super(data, "VkQueueFamilyQueryResultStatusPropertiesKHR"); }
    }
export class VkVideoProfileListInfoKHR extends VkSerializable<VkVideoProfileListInfoKHRInput, VkVideoProfileListInfoKHRDeserialized> {
        public constructor(data: VkVideoProfileListInfoKHRInput){ super(data, "VkVideoProfileListInfoKHR"); }
    }
export class VkPhysicalDeviceVideoFormatInfoKHR extends VkSerializable<VkPhysicalDeviceVideoFormatInfoKHRInput, VkPhysicalDeviceVideoFormatInfoKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceVideoFormatInfoKHRInput){ super(data, "VkPhysicalDeviceVideoFormatInfoKHR"); }
    }
export class VkVideoFormatPropertiesKHR extends VkSerializable<VkVideoFormatPropertiesKHRInput, VkVideoFormatPropertiesKHRDeserialized> {
        public constructor(data: VkVideoFormatPropertiesKHRInput){ super(data, "VkVideoFormatPropertiesKHR"); }
    }
export class VkVideoProfileInfoKHR extends VkSerializable<VkVideoProfileInfoKHRInput, VkVideoProfileInfoKHRDeserialized> {
        public constructor(data: VkVideoProfileInfoKHRInput){ super(data, "VkVideoProfileInfoKHR"); }
    }
export class VkVideoCapabilitiesKHR extends VkSerializable<VkVideoCapabilitiesKHRInput, VkVideoCapabilitiesKHRDeserialized> {
        public constructor(data: VkVideoCapabilitiesKHRInput){ super(data, "VkVideoCapabilitiesKHR"); }
    }
export class VkVideoSessionMemoryRequirementsKHR extends VkSerializable<VkVideoSessionMemoryRequirementsKHRInput, VkVideoSessionMemoryRequirementsKHRDeserialized> {
        public constructor(data: VkVideoSessionMemoryRequirementsKHRInput){ super(data, "VkVideoSessionMemoryRequirementsKHR"); }
    }
export class VkBindVideoSessionMemoryInfoKHR extends VkSerializable<VkBindVideoSessionMemoryInfoKHRInput, VkBindVideoSessionMemoryInfoKHRDeserialized> {
        public constructor(data: VkBindVideoSessionMemoryInfoKHRInput){ super(data, "VkBindVideoSessionMemoryInfoKHR"); }
    }
export class VkVideoPictureResourceInfoKHR extends VkSerializable<VkVideoPictureResourceInfoKHRInput, VkVideoPictureResourceInfoKHRDeserialized> {
        public constructor(data: VkVideoPictureResourceInfoKHRInput){ super(data, "VkVideoPictureResourceInfoKHR"); }
    }
export class VkVideoReferenceSlotInfoKHR extends VkSerializable<VkVideoReferenceSlotInfoKHRInput, VkVideoReferenceSlotInfoKHRDeserialized> {
        public constructor(data: VkVideoReferenceSlotInfoKHRInput){ super(data, "VkVideoReferenceSlotInfoKHR"); }
    }
export class VkVideoSessionCreateInfoKHR extends VkSerializable<VkVideoSessionCreateInfoKHRInput, VkVideoSessionCreateInfoKHRDeserialized> {
        public constructor(data: VkVideoSessionCreateInfoKHRInput){ super(data, "VkVideoSessionCreateInfoKHR"); }
    }
export class VkVideoSessionParametersCreateInfoKHR extends VkSerializable<VkVideoSessionParametersCreateInfoKHRInput, VkVideoSessionParametersCreateInfoKHRDeserialized> {
        public constructor(data: VkVideoSessionParametersCreateInfoKHRInput){ super(data, "VkVideoSessionParametersCreateInfoKHR"); }
    }
export class VkVideoSessionParametersUpdateInfoKHR extends VkSerializable<VkVideoSessionParametersUpdateInfoKHRInput, VkVideoSessionParametersUpdateInfoKHRDeserialized> {
        public constructor(data: VkVideoSessionParametersUpdateInfoKHRInput){ super(data, "VkVideoSessionParametersUpdateInfoKHR"); }
    }
export class VkVideoBeginCodingInfoKHR extends VkSerializable<VkVideoBeginCodingInfoKHRInput, VkVideoBeginCodingInfoKHRDeserialized> {
        public constructor(data: VkVideoBeginCodingInfoKHRInput){ super(data, "VkVideoBeginCodingInfoKHR"); }
    }
export class VkVideoEndCodingInfoKHR extends VkSerializable<VkVideoEndCodingInfoKHRInput, VkVideoEndCodingInfoKHRDeserialized> {
        public constructor(data: VkVideoEndCodingInfoKHRInput){ super(data, "VkVideoEndCodingInfoKHR"); }
    }
export class VkVideoCodingControlInfoKHR extends VkSerializable<VkVideoCodingControlInfoKHRInput, VkVideoCodingControlInfoKHRDeserialized> {
        public constructor(data: VkVideoCodingControlInfoKHRInput){ super(data, "VkVideoCodingControlInfoKHR"); }
    }
export class VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT extends VkSerializable<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTInput, VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTInput){ super(data, "VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT"); }
    }
export class VkPhysicalDeviceProvokingVertexFeaturesEXT extends VkSerializable<VkPhysicalDeviceProvokingVertexFeaturesEXTInput, VkPhysicalDeviceProvokingVertexFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceProvokingVertexFeaturesEXTInput){ super(data, "VkPhysicalDeviceProvokingVertexFeaturesEXT"); }
    }
export class VkPhysicalDeviceProvokingVertexPropertiesEXT extends VkSerializable<VkPhysicalDeviceProvokingVertexPropertiesEXTInput, VkPhysicalDeviceProvokingVertexPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceProvokingVertexPropertiesEXTInput){ super(data, "VkPhysicalDeviceProvokingVertexPropertiesEXT"); }
    }
export class VkPipelineRasterizationProvokingVertexStateCreateInfoEXT extends VkSerializable<VkPipelineRasterizationProvokingVertexStateCreateInfoEXTInput, VkPipelineRasterizationProvokingVertexStateCreateInfoEXTDeserialized> {
        public constructor(data: VkPipelineRasterizationProvokingVertexStateCreateInfoEXTInput){ super(data, "VkPipelineRasterizationProvokingVertexStateCreateInfoEXT"); }
    }
export class VkPhysicalDeviceShaderIntegerDotProductFeatures extends VkSerializable<VkPhysicalDeviceShaderIntegerDotProductFeaturesInput, VkPhysicalDeviceShaderIntegerDotProductFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderIntegerDotProductFeaturesInput){ super(data, "VkPhysicalDeviceShaderIntegerDotProductFeatures"); }
    }
export class VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR extends VkSerializable<VkPhysicalDeviceShaderIntegerDotProductFeaturesKHRInput, VkPhysicalDeviceShaderIntegerDotProductFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderIntegerDotProductFeaturesKHRInput){ super(data, "VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR"); }
    }
export class VkPhysicalDeviceShaderIntegerDotProductProperties extends VkSerializable<VkPhysicalDeviceShaderIntegerDotProductPropertiesInput, VkPhysicalDeviceShaderIntegerDotProductPropertiesDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderIntegerDotProductPropertiesInput){ super(data, "VkPhysicalDeviceShaderIntegerDotProductProperties"); }
    }
export class VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR extends VkSerializable<VkPhysicalDeviceShaderIntegerDotProductPropertiesKHRInput, VkPhysicalDeviceShaderIntegerDotProductPropertiesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderIntegerDotProductPropertiesKHRInput){ super(data, "VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR"); }
    }
export class VkPhysicalDeviceDrmPropertiesEXT extends VkSerializable<VkPhysicalDeviceDrmPropertiesEXTInput, VkPhysicalDeviceDrmPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceDrmPropertiesEXTInput){ super(data, "VkPhysicalDeviceDrmPropertiesEXT"); }
    }
export class VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR extends VkSerializable<VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHRInput, VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHRInput){ super(data, "VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR"); }
    }
export class VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR extends VkSerializable<VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHRInput, VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHRInput){ super(data, "VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR"); }
    }
export class VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT extends VkSerializable<VkPhysicalDeviceRGBA10X6FormatsFeaturesEXTInput, VkPhysicalDeviceRGBA10X6FormatsFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceRGBA10X6FormatsFeaturesEXTInput){ super(data, "VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT"); }
    }
export class VkFormatProperties3 extends VkSerializable<VkFormatProperties3Input, VkFormatProperties3Deserialized> {
        public constructor(data: VkFormatProperties3Input){ super(data, "VkFormatProperties3"); }
    }
export class VkFormatProperties3KHR extends VkSerializable<VkFormatProperties3KHRInput, VkFormatProperties3KHRDeserialized> {
        public constructor(data: VkFormatProperties3KHRInput){ super(data, "VkFormatProperties3KHR"); }
    }
export class VkDrmFormatModifierPropertiesList2EXT extends VkSerializable<VkDrmFormatModifierPropertiesList2EXTInput, VkDrmFormatModifierPropertiesList2EXTDeserialized> {
        public constructor(data: VkDrmFormatModifierPropertiesList2EXTInput){ super(data, "VkDrmFormatModifierPropertiesList2EXT"); }
    }
export class VkDrmFormatModifierProperties2EXT extends VkSerializable<VkDrmFormatModifierProperties2EXTInput, VkDrmFormatModifierProperties2EXTDeserialized> {
        public constructor(data: VkDrmFormatModifierProperties2EXTInput){ super(data, "VkDrmFormatModifierProperties2EXT"); }
    }
export class VkPipelineRenderingCreateInfo extends VkSerializable<VkPipelineRenderingCreateInfoInput, VkPipelineRenderingCreateInfoDeserialized> {
        public constructor(data: VkPipelineRenderingCreateInfoInput){ super(data, "VkPipelineRenderingCreateInfo"); }
    }
export class VkPipelineRenderingCreateInfoKHR extends VkSerializable<VkPipelineRenderingCreateInfoKHRInput, VkPipelineRenderingCreateInfoKHRDeserialized> {
        public constructor(data: VkPipelineRenderingCreateInfoKHRInput){ super(data, "VkPipelineRenderingCreateInfoKHR"); }
    }
export class VkRenderingInfo extends VkSerializable<VkRenderingInfoInput, VkRenderingInfoDeserialized> {
        public constructor(data: VkRenderingInfoInput){ super(data, "VkRenderingInfo"); }
    }
export class VkRenderingAttachmentInfo extends VkSerializable<VkRenderingAttachmentInfoInput, VkRenderingAttachmentInfoDeserialized> {
        public constructor(data: VkRenderingAttachmentInfoInput){ super(data, "VkRenderingAttachmentInfo"); }
    }
export class VkRenderingAttachmentInfoKHR extends VkSerializable<VkRenderingAttachmentInfoKHRInput, VkRenderingAttachmentInfoKHRDeserialized> {
        public constructor(data: VkRenderingAttachmentInfoKHRInput){ super(data, "VkRenderingAttachmentInfoKHR"); }
    }
export class VkRenderingFragmentShadingRateAttachmentInfoKHR extends VkSerializable<VkRenderingFragmentShadingRateAttachmentInfoKHRInput, VkRenderingFragmentShadingRateAttachmentInfoKHRDeserialized> {
        public constructor(data: VkRenderingFragmentShadingRateAttachmentInfoKHRInput){ super(data, "VkRenderingFragmentShadingRateAttachmentInfoKHR"); }
    }
export class VkRenderingFragmentDensityMapAttachmentInfoEXT extends VkSerializable<VkRenderingFragmentDensityMapAttachmentInfoEXTInput, VkRenderingFragmentDensityMapAttachmentInfoEXTDeserialized> {
        public constructor(data: VkRenderingFragmentDensityMapAttachmentInfoEXTInput){ super(data, "VkRenderingFragmentDensityMapAttachmentInfoEXT"); }
    }
export class VkPhysicalDeviceDynamicRenderingFeatures extends VkSerializable<VkPhysicalDeviceDynamicRenderingFeaturesInput, VkPhysicalDeviceDynamicRenderingFeaturesDeserialized> {
        public constructor(data: VkPhysicalDeviceDynamicRenderingFeaturesInput){ super(data, "VkPhysicalDeviceDynamicRenderingFeatures"); }
    }
export class VkPhysicalDeviceDynamicRenderingFeaturesKHR extends VkSerializable<VkPhysicalDeviceDynamicRenderingFeaturesKHRInput, VkPhysicalDeviceDynamicRenderingFeaturesKHRDeserialized> {
        public constructor(data: VkPhysicalDeviceDynamicRenderingFeaturesKHRInput){ super(data, "VkPhysicalDeviceDynamicRenderingFeaturesKHR"); }
    }
export class VkCommandBufferInheritanceRenderingInfo extends VkSerializable<VkCommandBufferInheritanceRenderingInfoInput, VkCommandBufferInheritanceRenderingInfoDeserialized> {
        public constructor(data: VkCommandBufferInheritanceRenderingInfoInput){ super(data, "VkCommandBufferInheritanceRenderingInfo"); }
    }
export class VkCommandBufferInheritanceRenderingInfoKHR extends VkSerializable<VkCommandBufferInheritanceRenderingInfoKHRInput, VkCommandBufferInheritanceRenderingInfoKHRDeserialized> {
        public constructor(data: VkCommandBufferInheritanceRenderingInfoKHRInput){ super(data, "VkCommandBufferInheritanceRenderingInfoKHR"); }
    }
export class VkAttachmentSampleCountInfoAMD extends VkSerializable<VkAttachmentSampleCountInfoAMDInput, VkAttachmentSampleCountInfoAMDDeserialized> {
        public constructor(data: VkAttachmentSampleCountInfoAMDInput){ super(data, "VkAttachmentSampleCountInfoAMD"); }
    }
export class VkAttachmentSampleCountInfoNV extends VkSerializable<VkAttachmentSampleCountInfoNVInput, VkAttachmentSampleCountInfoNVDeserialized> {
        public constructor(data: VkAttachmentSampleCountInfoNVInput){ super(data, "VkAttachmentSampleCountInfoNV"); }
    }
export class VkMultiviewPerViewAttributesInfoNVX extends VkSerializable<VkMultiviewPerViewAttributesInfoNVXInput, VkMultiviewPerViewAttributesInfoNVXDeserialized> {
        public constructor(data: VkMultiviewPerViewAttributesInfoNVXInput){ super(data, "VkMultiviewPerViewAttributesInfoNVX"); }
    }
export class VkPhysicalDeviceImageViewMinLodFeaturesEXT extends VkSerializable<VkPhysicalDeviceImageViewMinLodFeaturesEXTInput, VkPhysicalDeviceImageViewMinLodFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceImageViewMinLodFeaturesEXTInput){ super(data, "VkPhysicalDeviceImageViewMinLodFeaturesEXT"); }
    }
export class VkImageViewMinLodCreateInfoEXT extends VkSerializable<VkImageViewMinLodCreateInfoEXTInput, VkImageViewMinLodCreateInfoEXTDeserialized> {
        public constructor(data: VkImageViewMinLodCreateInfoEXTInput){ super(data, "VkImageViewMinLodCreateInfoEXT"); }
    }
export class VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT extends VkSerializable<VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTInput, VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTInput){ super(data, "VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT"); }
    }
export class VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT extends VkSerializable<VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXTInput, VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXTInput){ super(data, "VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT"); }
    }
export class VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT extends VkSerializable<VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXTInput, VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXTInput){ super(data, "VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT"); }
    }
export class VkGraphicsPipelineLibraryCreateInfoEXT extends VkSerializable<VkGraphicsPipelineLibraryCreateInfoEXTInput, VkGraphicsPipelineLibraryCreateInfoEXTDeserialized> {
        public constructor(data: VkGraphicsPipelineLibraryCreateInfoEXTInput){ super(data, "VkGraphicsPipelineLibraryCreateInfoEXT"); }
    }
export class VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT extends VkSerializable<VkPhysicalDeviceShaderModuleIdentifierFeaturesEXTInput, VkPhysicalDeviceShaderModuleIdentifierFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderModuleIdentifierFeaturesEXTInput){ super(data, "VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT"); }
    }
export class VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT extends VkSerializable<VkPhysicalDeviceShaderModuleIdentifierPropertiesEXTInput, VkPhysicalDeviceShaderModuleIdentifierPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceShaderModuleIdentifierPropertiesEXTInput){ super(data, "VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT"); }
    }
export class VkPipelineShaderStageModuleIdentifierCreateInfoEXT extends VkSerializable<VkPipelineShaderStageModuleIdentifierCreateInfoEXTInput, VkPipelineShaderStageModuleIdentifierCreateInfoEXTDeserialized> {
        public constructor(data: VkPipelineShaderStageModuleIdentifierCreateInfoEXTInput){ super(data, "VkPipelineShaderStageModuleIdentifierCreateInfoEXT"); }
    }
export class VkShaderModuleIdentifierEXT extends VkSerializable<VkShaderModuleIdentifierEXTInput, VkShaderModuleIdentifierEXTDeserialized> {
        public constructor(data: VkShaderModuleIdentifierEXTInput){ super(data, "VkShaderModuleIdentifierEXT"); }
    }
export class VkImageCompressionControlEXT extends VkSerializable<VkImageCompressionControlEXTInput, VkImageCompressionControlEXTDeserialized> {
        public constructor(data: VkImageCompressionControlEXTInput){ super(data, "VkImageCompressionControlEXT"); }
    }
export class VkPhysicalDeviceImageCompressionControlFeaturesEXT extends VkSerializable<VkPhysicalDeviceImageCompressionControlFeaturesEXTInput, VkPhysicalDeviceImageCompressionControlFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceImageCompressionControlFeaturesEXTInput){ super(data, "VkPhysicalDeviceImageCompressionControlFeaturesEXT"); }
    }
export class VkImageCompressionPropertiesEXT extends VkSerializable<VkImageCompressionPropertiesEXTInput, VkImageCompressionPropertiesEXTDeserialized> {
        public constructor(data: VkImageCompressionPropertiesEXTInput){ super(data, "VkImageCompressionPropertiesEXT"); }
    }
export class VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT extends VkSerializable<VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXTInput, VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXTInput){ super(data, "VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT"); }
    }
export class VkRenderPassCreationControlEXT extends VkSerializable<VkRenderPassCreationControlEXTInput, VkRenderPassCreationControlEXTDeserialized> {
        public constructor(data: VkRenderPassCreationControlEXTInput){ super(data, "VkRenderPassCreationControlEXT"); }
    }
export class VkRenderPassCreationFeedbackInfoEXT extends VkSerializable<VkRenderPassCreationFeedbackInfoEXTInput, VkRenderPassCreationFeedbackInfoEXTDeserialized> {
        public constructor(data: VkRenderPassCreationFeedbackInfoEXTInput){ super(data, "VkRenderPassCreationFeedbackInfoEXT"); }
    }
export class VkRenderPassCreationFeedbackCreateInfoEXT extends VkSerializable<VkRenderPassCreationFeedbackCreateInfoEXTInput, VkRenderPassCreationFeedbackCreateInfoEXTDeserialized> {
        public constructor(data: VkRenderPassCreationFeedbackCreateInfoEXTInput){ super(data, "VkRenderPassCreationFeedbackCreateInfoEXT"); }
    }
export class VkRenderPassSubpassFeedbackInfoEXT extends VkSerializable<VkRenderPassSubpassFeedbackInfoEXTInput, VkRenderPassSubpassFeedbackInfoEXTDeserialized> {
        public constructor(data: VkRenderPassSubpassFeedbackInfoEXTInput){ super(data, "VkRenderPassSubpassFeedbackInfoEXT"); }
    }
export class VkRenderPassSubpassFeedbackCreateInfoEXT extends VkSerializable<VkRenderPassSubpassFeedbackCreateInfoEXTInput, VkRenderPassSubpassFeedbackCreateInfoEXTDeserialized> {
        public constructor(data: VkRenderPassSubpassFeedbackCreateInfoEXTInput){ super(data, "VkRenderPassSubpassFeedbackCreateInfoEXT"); }
    }
export class VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT extends VkSerializable<VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXTInput, VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXTInput){ super(data, "VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT"); }
    }
export class VkPipelinePropertiesIdentifierEXT extends VkSerializable<VkPipelinePropertiesIdentifierEXTInput, VkPipelinePropertiesIdentifierEXTDeserialized> {
        public constructor(data: VkPipelinePropertiesIdentifierEXTInput){ super(data, "VkPipelinePropertiesIdentifierEXT"); }
    }
export class VkPhysicalDevicePipelinePropertiesFeaturesEXT extends VkSerializable<VkPhysicalDevicePipelinePropertiesFeaturesEXTInput, VkPhysicalDevicePipelinePropertiesFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDevicePipelinePropertiesFeaturesEXTInput){ super(data, "VkPhysicalDevicePipelinePropertiesFeaturesEXT"); }
    }
export class VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT extends VkSerializable<VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXTInput, VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXTInput){ super(data, "VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT"); }
    }
export class VkPhysicalDevicePipelineRobustnessFeaturesEXT extends VkSerializable<VkPhysicalDevicePipelineRobustnessFeaturesEXTInput, VkPhysicalDevicePipelineRobustnessFeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDevicePipelineRobustnessFeaturesEXTInput){ super(data, "VkPhysicalDevicePipelineRobustnessFeaturesEXT"); }
    }
export class VkPipelineRobustnessCreateInfoEXT extends VkSerializable<VkPipelineRobustnessCreateInfoEXTInput, VkPipelineRobustnessCreateInfoEXTDeserialized> {
        public constructor(data: VkPipelineRobustnessCreateInfoEXTInput){ super(data, "VkPipelineRobustnessCreateInfoEXT"); }
    }
export class VkPhysicalDevicePipelineRobustnessPropertiesEXT extends VkSerializable<VkPhysicalDevicePipelineRobustnessPropertiesEXTInput, VkPhysicalDevicePipelineRobustnessPropertiesEXTDeserialized> {
        public constructor(data: VkPhysicalDevicePipelineRobustnessPropertiesEXTInput){ super(data, "VkPhysicalDevicePipelineRobustnessPropertiesEXT"); }
    }
export class VkSurfacePresentModeEXT extends VkSerializable<VkSurfacePresentModeEXTInput, VkSurfacePresentModeEXTDeserialized> {
        public constructor(data: VkSurfacePresentModeEXTInput){ super(data, "VkSurfacePresentModeEXT"); }
    }
export class VkSurfacePresentScalingCapabilitiesEXT extends VkSerializable<VkSurfacePresentScalingCapabilitiesEXTInput, VkSurfacePresentScalingCapabilitiesEXTDeserialized> {
        public constructor(data: VkSurfacePresentScalingCapabilitiesEXTInput){ super(data, "VkSurfacePresentScalingCapabilitiesEXT"); }
    }
export class VkSurfacePresentModeCompatibilityEXT extends VkSerializable<VkSurfacePresentModeCompatibilityEXTInput, VkSurfacePresentModeCompatibilityEXTDeserialized> {
        public constructor(data: VkSurfacePresentModeCompatibilityEXTInput){ super(data, "VkSurfacePresentModeCompatibilityEXT"); }
    }
export class VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT extends VkSerializable<VkPhysicalDeviceSwapchainMaintenance1FeaturesEXTInput, VkPhysicalDeviceSwapchainMaintenance1FeaturesEXTDeserialized> {
        public constructor(data: VkPhysicalDeviceSwapchainMaintenance1FeaturesEXTInput){ super(data, "VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT"); }
    }
export class VkSwapchainPresentFenceInfoEXT extends VkSerializable<VkSwapchainPresentFenceInfoEXTInput, VkSwapchainPresentFenceInfoEXTDeserialized> {
        public constructor(data: VkSwapchainPresentFenceInfoEXTInput){ super(data, "VkSwapchainPresentFenceInfoEXT"); }
    }
export class VkSwapchainPresentModesCreateInfoEXT extends VkSerializable<VkSwapchainPresentModesCreateInfoEXTInput, VkSwapchainPresentModesCreateInfoEXTDeserialized> {
        public constructor(data: VkSwapchainPresentModesCreateInfoEXTInput){ super(data, "VkSwapchainPresentModesCreateInfoEXT"); }
    }
export class VkSwapchainPresentModeInfoEXT extends VkSerializable<VkSwapchainPresentModeInfoEXTInput, VkSwapchainPresentModeInfoEXTDeserialized> {
        public constructor(data: VkSwapchainPresentModeInfoEXTInput){ super(data, "VkSwapchainPresentModeInfoEXT"); }
    }
export class VkSwapchainPresentScalingCreateInfoEXT extends VkSerializable<VkSwapchainPresentScalingCreateInfoEXTInput, VkSwapchainPresentScalingCreateInfoEXTDeserialized> {
        public constructor(data: VkSwapchainPresentScalingCreateInfoEXTInput){ super(data, "VkSwapchainPresentScalingCreateInfoEXT"); }
    }
export class VkReleaseSwapchainImagesInfoEXT extends VkSerializable<VkReleaseSwapchainImagesInfoEXTInput, VkReleaseSwapchainImagesInfoEXTDeserialized> {
        public constructor(data: VkReleaseSwapchainImagesInfoEXTInput){ super(data, "VkReleaseSwapchainImagesInfoEXT"); }
    }
export const getEmptyVkBaseOutStructure = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBaseOutStructure"));
  buf.underlyingType = "VkBaseOutStructure";
  return buf;
};
export const getEmptyVkBaseInStructure = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBaseInStructure"));
  buf.underlyingType = "VkBaseInStructure";
  return buf;
};
export const getEmptyVkOffset2D = (): Membuf => {
  const buf = new Membuf(getStructSize("VkOffset2D"));
  buf.underlyingType = "VkOffset2D";
  return buf;
};
export const getEmptyVkOffset3D = (): Membuf => {
  const buf = new Membuf(getStructSize("VkOffset3D"));
  buf.underlyingType = "VkOffset3D";
  return buf;
};
export const getEmptyVkExtent2D = (): Membuf => {
  const buf = new Membuf(getStructSize("VkExtent2D"));
  buf.underlyingType = "VkExtent2D";
  return buf;
};
export const getEmptyVkExtent3D = (): Membuf => {
  const buf = new Membuf(getStructSize("VkExtent3D"));
  buf.underlyingType = "VkExtent3D";
  return buf;
};
export const getEmptyVkViewport = (): Membuf => {
  const buf = new Membuf(getStructSize("VkViewport"));
  buf.underlyingType = "VkViewport";
  return buf;
};
export const getEmptyVkRect2D = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRect2D"));
  buf.underlyingType = "VkRect2D";
  return buf;
};
export const getEmptyVkClearRect = (): Membuf => {
  const buf = new Membuf(getStructSize("VkClearRect"));
  buf.underlyingType = "VkClearRect";
  return buf;
};
export const getEmptyVkComponentMapping = (): Membuf => {
  const buf = new Membuf(getStructSize("VkComponentMapping"));
  buf.underlyingType = "VkComponentMapping";
  return buf;
};
export const getEmptyVkPhysicalDeviceProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceProperties"));
  buf.underlyingType = "VkPhysicalDeviceProperties";
  return buf;
};
export const getEmptyVkExtensionProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkExtensionProperties"));
  buf.underlyingType = "VkExtensionProperties";
  return buf;
};
export const getEmptyVkLayerProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkLayerProperties"));
  buf.underlyingType = "VkLayerProperties";
  return buf;
};
export const getEmptyVkApplicationInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkApplicationInfo"));
  buf.underlyingType = "VkApplicationInfo";
  return buf;
};
export const getEmptyVkAllocationCallbacks = (): Membuf => {
  const buf = new Membuf(getStructSize("VkAllocationCallbacks"));
  buf.underlyingType = "VkAllocationCallbacks";
  return buf;
};
export const getEmptyVkDeviceQueueCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceQueueCreateInfo"));
  buf.underlyingType = "VkDeviceQueueCreateInfo";
  return buf;
};
export const getEmptyVkDeviceCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceCreateInfo"));
  buf.underlyingType = "VkDeviceCreateInfo";
  return buf;
};
export const getEmptyVkInstanceCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkInstanceCreateInfo"));
  buf.underlyingType = "VkInstanceCreateInfo";
  return buf;
};
export const getEmptyVkQueueFamilyProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkQueueFamilyProperties"));
  buf.underlyingType = "VkQueueFamilyProperties";
  return buf;
};
export const getEmptyVkPhysicalDeviceMemoryProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMemoryProperties"));
  buf.underlyingType = "VkPhysicalDeviceMemoryProperties";
  return buf;
};
export const getEmptyVkMemoryAllocateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMemoryAllocateInfo"));
  buf.underlyingType = "VkMemoryAllocateInfo";
  return buf;
};
export const getEmptyVkMemoryRequirements = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMemoryRequirements"));
  buf.underlyingType = "VkMemoryRequirements";
  return buf;
};
export const getEmptyVkSparseImageFormatProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSparseImageFormatProperties"));
  buf.underlyingType = "VkSparseImageFormatProperties";
  return buf;
};
export const getEmptyVkSparseImageMemoryRequirements = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSparseImageMemoryRequirements"));
  buf.underlyingType = "VkSparseImageMemoryRequirements";
  return buf;
};
export const getEmptyVkMemoryType = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMemoryType"));
  buf.underlyingType = "VkMemoryType";
  return buf;
};
export const getEmptyVkMemoryHeap = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMemoryHeap"));
  buf.underlyingType = "VkMemoryHeap";
  return buf;
};
export const getEmptyVkMappedMemoryRange = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMappedMemoryRange"));
  buf.underlyingType = "VkMappedMemoryRange";
  return buf;
};
export const getEmptyVkFormatProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkFormatProperties"));
  buf.underlyingType = "VkFormatProperties";
  return buf;
};
export const getEmptyVkImageFormatProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageFormatProperties"));
  buf.underlyingType = "VkImageFormatProperties";
  return buf;
};
export const getEmptyVkDescriptorBufferInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDescriptorBufferInfo"));
  buf.underlyingType = "VkDescriptorBufferInfo";
  return buf;
};
export const getEmptyVkDescriptorImageInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDescriptorImageInfo"));
  buf.underlyingType = "VkDescriptorImageInfo";
  return buf;
};
export const getEmptyVkWriteDescriptorSet = (): Membuf => {
  const buf = new Membuf(getStructSize("VkWriteDescriptorSet"));
  buf.underlyingType = "VkWriteDescriptorSet";
  return buf;
};
export const getEmptyVkCopyDescriptorSet = (): Membuf => {
  const buf = new Membuf(getStructSize("VkCopyDescriptorSet"));
  buf.underlyingType = "VkCopyDescriptorSet";
  return buf;
};
export const getEmptyVkBufferCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBufferCreateInfo"));
  buf.underlyingType = "VkBufferCreateInfo";
  return buf;
};
export const getEmptyVkBufferViewCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBufferViewCreateInfo"));
  buf.underlyingType = "VkBufferViewCreateInfo";
  return buf;
};
export const getEmptyVkImageSubresource = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageSubresource"));
  buf.underlyingType = "VkImageSubresource";
  return buf;
};
export const getEmptyVkImageSubresourceLayers = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageSubresourceLayers"));
  buf.underlyingType = "VkImageSubresourceLayers";
  return buf;
};
export const getEmptyVkImageSubresourceRange = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageSubresourceRange"));
  buf.underlyingType = "VkImageSubresourceRange";
  return buf;
};
export const getEmptyVkMemoryBarrier = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMemoryBarrier"));
  buf.underlyingType = "VkMemoryBarrier";
  return buf;
};
export const getEmptyVkBufferMemoryBarrier = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBufferMemoryBarrier"));
  buf.underlyingType = "VkBufferMemoryBarrier";
  return buf;
};
export const getEmptyVkImageMemoryBarrier = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageMemoryBarrier"));
  buf.underlyingType = "VkImageMemoryBarrier";
  return buf;
};
export const getEmptyVkImageCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageCreateInfo"));
  buf.underlyingType = "VkImageCreateInfo";
  return buf;
};
export const getEmptyVkSubresourceLayout = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSubresourceLayout"));
  buf.underlyingType = "VkSubresourceLayout";
  return buf;
};
export const getEmptyVkImageViewCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageViewCreateInfo"));
  buf.underlyingType = "VkImageViewCreateInfo";
  return buf;
};
export const getEmptyVkBufferCopy = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBufferCopy"));
  buf.underlyingType = "VkBufferCopy";
  return buf;
};
export const getEmptyVkSparseMemoryBind = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSparseMemoryBind"));
  buf.underlyingType = "VkSparseMemoryBind";
  return buf;
};
export const getEmptyVkSparseImageMemoryBind = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSparseImageMemoryBind"));
  buf.underlyingType = "VkSparseImageMemoryBind";
  return buf;
};
export const getEmptyVkSparseBufferMemoryBindInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSparseBufferMemoryBindInfo"));
  buf.underlyingType = "VkSparseBufferMemoryBindInfo";
  return buf;
};
export const getEmptyVkSparseImageOpaqueMemoryBindInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSparseImageOpaqueMemoryBindInfo"));
  buf.underlyingType = "VkSparseImageOpaqueMemoryBindInfo";
  return buf;
};
export const getEmptyVkSparseImageMemoryBindInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSparseImageMemoryBindInfo"));
  buf.underlyingType = "VkSparseImageMemoryBindInfo";
  return buf;
};
export const getEmptyVkBindSparseInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBindSparseInfo"));
  buf.underlyingType = "VkBindSparseInfo";
  return buf;
};
export const getEmptyVkImageCopy = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageCopy"));
  buf.underlyingType = "VkImageCopy";
  return buf;
};
export const getEmptyVkImageBlit = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageBlit"));
  buf.underlyingType = "VkImageBlit";
  return buf;
};
export const getEmptyVkBufferImageCopy = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBufferImageCopy"));
  buf.underlyingType = "VkBufferImageCopy";
  return buf;
};
export const getEmptyVkImageResolve = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageResolve"));
  buf.underlyingType = "VkImageResolve";
  return buf;
};
export const getEmptyVkShaderModuleCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkShaderModuleCreateInfo"));
  buf.underlyingType = "VkShaderModuleCreateInfo";
  return buf;
};
export const getEmptyVkDescriptorSetLayoutBinding = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDescriptorSetLayoutBinding"));
  buf.underlyingType = "VkDescriptorSetLayoutBinding";
  return buf;
};
export const getEmptyVkDescriptorSetLayoutCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDescriptorSetLayoutCreateInfo"));
  buf.underlyingType = "VkDescriptorSetLayoutCreateInfo";
  return buf;
};
export const getEmptyVkDescriptorPoolSize = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDescriptorPoolSize"));
  buf.underlyingType = "VkDescriptorPoolSize";
  return buf;
};
export const getEmptyVkDescriptorPoolCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDescriptorPoolCreateInfo"));
  buf.underlyingType = "VkDescriptorPoolCreateInfo";
  return buf;
};
export const getEmptyVkDescriptorSetAllocateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDescriptorSetAllocateInfo"));
  buf.underlyingType = "VkDescriptorSetAllocateInfo";
  return buf;
};
export const getEmptyVkSpecializationMapEntry = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSpecializationMapEntry"));
  buf.underlyingType = "VkSpecializationMapEntry";
  return buf;
};
export const getEmptyVkSpecializationInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSpecializationInfo"));
  buf.underlyingType = "VkSpecializationInfo";
  return buf;
};
export const getEmptyVkPipelineShaderStageCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineShaderStageCreateInfo"));
  buf.underlyingType = "VkPipelineShaderStageCreateInfo";
  return buf;
};
export const getEmptyVkComputePipelineCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkComputePipelineCreateInfo"));
  buf.underlyingType = "VkComputePipelineCreateInfo";
  return buf;
};
export const getEmptyVkVertexInputBindingDescription = (): Membuf => {
  const buf = new Membuf(getStructSize("VkVertexInputBindingDescription"));
  buf.underlyingType = "VkVertexInputBindingDescription";
  return buf;
};
export const getEmptyVkVertexInputAttributeDescription = (): Membuf => {
  const buf = new Membuf(getStructSize("VkVertexInputAttributeDescription"));
  buf.underlyingType = "VkVertexInputAttributeDescription";
  return buf;
};
export const getEmptyVkPipelineVertexInputStateCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineVertexInputStateCreateInfo"));
  buf.underlyingType = "VkPipelineVertexInputStateCreateInfo";
  return buf;
};
export const getEmptyVkPipelineInputAssemblyStateCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineInputAssemblyStateCreateInfo"));
  buf.underlyingType = "VkPipelineInputAssemblyStateCreateInfo";
  return buf;
};
export const getEmptyVkPipelineTessellationStateCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineTessellationStateCreateInfo"));
  buf.underlyingType = "VkPipelineTessellationStateCreateInfo";
  return buf;
};
export const getEmptyVkPipelineViewportStateCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineViewportStateCreateInfo"));
  buf.underlyingType = "VkPipelineViewportStateCreateInfo";
  return buf;
};
export const getEmptyVkPipelineRasterizationStateCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineRasterizationStateCreateInfo"));
  buf.underlyingType = "VkPipelineRasterizationStateCreateInfo";
  return buf;
};
export const getEmptyVkPipelineMultisampleStateCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineMultisampleStateCreateInfo"));
  buf.underlyingType = "VkPipelineMultisampleStateCreateInfo";
  return buf;
};
export const getEmptyVkPipelineColorBlendAttachmentState = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineColorBlendAttachmentState"));
  buf.underlyingType = "VkPipelineColorBlendAttachmentState";
  return buf;
};
export const getEmptyVkPipelineColorBlendStateCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineColorBlendStateCreateInfo"));
  buf.underlyingType = "VkPipelineColorBlendStateCreateInfo";
  return buf;
};
export const getEmptyVkPipelineDynamicStateCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineDynamicStateCreateInfo"));
  buf.underlyingType = "VkPipelineDynamicStateCreateInfo";
  return buf;
};
export const getEmptyVkStencilOpState = (): Membuf => {
  const buf = new Membuf(getStructSize("VkStencilOpState"));
  buf.underlyingType = "VkStencilOpState";
  return buf;
};
export const getEmptyVkPipelineDepthStencilStateCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineDepthStencilStateCreateInfo"));
  buf.underlyingType = "VkPipelineDepthStencilStateCreateInfo";
  return buf;
};
export const getEmptyVkGraphicsPipelineCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkGraphicsPipelineCreateInfo"));
  buf.underlyingType = "VkGraphicsPipelineCreateInfo";
  return buf;
};
export const getEmptyVkPipelineCacheCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineCacheCreateInfo"));
  buf.underlyingType = "VkPipelineCacheCreateInfo";
  return buf;
};
export const getEmptyVkPipelineCacheHeaderVersionOne = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineCacheHeaderVersionOne"));
  buf.underlyingType = "VkPipelineCacheHeaderVersionOne";
  return buf;
};
export const getEmptyVkPushConstantRange = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPushConstantRange"));
  buf.underlyingType = "VkPushConstantRange";
  return buf;
};
export const getEmptyVkPipelineLayoutCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineLayoutCreateInfo"));
  buf.underlyingType = "VkPipelineLayoutCreateInfo";
  return buf;
};
export const getEmptyVkSamplerCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSamplerCreateInfo"));
  buf.underlyingType = "VkSamplerCreateInfo";
  return buf;
};
export const getEmptyVkCommandPoolCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkCommandPoolCreateInfo"));
  buf.underlyingType = "VkCommandPoolCreateInfo";
  return buf;
};
export const getEmptyVkCommandBufferAllocateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkCommandBufferAllocateInfo"));
  buf.underlyingType = "VkCommandBufferAllocateInfo";
  return buf;
};
export const getEmptyVkCommandBufferInheritanceInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkCommandBufferInheritanceInfo"));
  buf.underlyingType = "VkCommandBufferInheritanceInfo";
  return buf;
};
export const getEmptyVkCommandBufferBeginInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkCommandBufferBeginInfo"));
  buf.underlyingType = "VkCommandBufferBeginInfo";
  return buf;
};
export const getEmptyVkRenderPassBeginInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderPassBeginInfo"));
  buf.underlyingType = "VkRenderPassBeginInfo";
  return buf;
};
export const getEmptyVkClearDepthStencilValue = (): Membuf => {
  const buf = new Membuf(getStructSize("VkClearDepthStencilValue"));
  buf.underlyingType = "VkClearDepthStencilValue";
  return buf;
};
export const getEmptyVkClearAttachment = (): Membuf => {
  const buf = new Membuf(getStructSize("VkClearAttachment"));
  buf.underlyingType = "VkClearAttachment";
  return buf;
};
export const getEmptyVkAttachmentDescription = (): Membuf => {
  const buf = new Membuf(getStructSize("VkAttachmentDescription"));
  buf.underlyingType = "VkAttachmentDescription";
  return buf;
};
export const getEmptyVkAttachmentReference = (): Membuf => {
  const buf = new Membuf(getStructSize("VkAttachmentReference"));
  buf.underlyingType = "VkAttachmentReference";
  return buf;
};
export const getEmptyVkSubpassDescription = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSubpassDescription"));
  buf.underlyingType = "VkSubpassDescription";
  return buf;
};
export const getEmptyVkSubpassDependency = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSubpassDependency"));
  buf.underlyingType = "VkSubpassDependency";
  return buf;
};
export const getEmptyVkRenderPassCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderPassCreateInfo"));
  buf.underlyingType = "VkRenderPassCreateInfo";
  return buf;
};
export const getEmptyVkEventCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkEventCreateInfo"));
  buf.underlyingType = "VkEventCreateInfo";
  return buf;
};
export const getEmptyVkFenceCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkFenceCreateInfo"));
  buf.underlyingType = "VkFenceCreateInfo";
  return buf;
};
export const getEmptyVkPhysicalDeviceFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFeatures"));
  buf.underlyingType = "VkPhysicalDeviceFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceSparseProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSparseProperties"));
  buf.underlyingType = "VkPhysicalDeviceSparseProperties";
  return buf;
};
export const getEmptyVkPhysicalDeviceLimits = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceLimits"));
  buf.underlyingType = "VkPhysicalDeviceLimits";
  return buf;
};
export const getEmptyVkSemaphoreCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSemaphoreCreateInfo"));
  buf.underlyingType = "VkSemaphoreCreateInfo";
  return buf;
};
export const getEmptyVkQueryPoolCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkQueryPoolCreateInfo"));
  buf.underlyingType = "VkQueryPoolCreateInfo";
  return buf;
};
export const getEmptyVkFramebufferCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkFramebufferCreateInfo"));
  buf.underlyingType = "VkFramebufferCreateInfo";
  return buf;
};
export const getEmptyVkDrawIndirectCommand = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDrawIndirectCommand"));
  buf.underlyingType = "VkDrawIndirectCommand";
  return buf;
};
export const getEmptyVkDrawIndexedIndirectCommand = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDrawIndexedIndirectCommand"));
  buf.underlyingType = "VkDrawIndexedIndirectCommand";
  return buf;
};
export const getEmptyVkDispatchIndirectCommand = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDispatchIndirectCommand"));
  buf.underlyingType = "VkDispatchIndirectCommand";
  return buf;
};
export const getEmptyVkMultiDrawInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMultiDrawInfoEXT"));
  buf.underlyingType = "VkMultiDrawInfoEXT";
  return buf;
};
export const getEmptyVkMultiDrawIndexedInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMultiDrawIndexedInfoEXT"));
  buf.underlyingType = "VkMultiDrawIndexedInfoEXT";
  return buf;
};
export const getEmptyVkSubmitInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSubmitInfo"));
  buf.underlyingType = "VkSubmitInfo";
  return buf;
};
export const getEmptyVkDisplayPropertiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDisplayPropertiesKHR"));
  buf.underlyingType = "VkDisplayPropertiesKHR";
  return buf;
};
export const getEmptyVkDisplayPlanePropertiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDisplayPlanePropertiesKHR"));
  buf.underlyingType = "VkDisplayPlanePropertiesKHR";
  return buf;
};
export const getEmptyVkDisplayModeParametersKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDisplayModeParametersKHR"));
  buf.underlyingType = "VkDisplayModeParametersKHR";
  return buf;
};
export const getEmptyVkDisplayModePropertiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDisplayModePropertiesKHR"));
  buf.underlyingType = "VkDisplayModePropertiesKHR";
  return buf;
};
export const getEmptyVkDisplayModeCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDisplayModeCreateInfoKHR"));
  buf.underlyingType = "VkDisplayModeCreateInfoKHR";
  return buf;
};
export const getEmptyVkDisplayPlaneCapabilitiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDisplayPlaneCapabilitiesKHR"));
  buf.underlyingType = "VkDisplayPlaneCapabilitiesKHR";
  return buf;
};
export const getEmptyVkDisplaySurfaceCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDisplaySurfaceCreateInfoKHR"));
  buf.underlyingType = "VkDisplaySurfaceCreateInfoKHR";
  return buf;
};
export const getEmptyVkDisplayPresentInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDisplayPresentInfoKHR"));
  buf.underlyingType = "VkDisplayPresentInfoKHR";
  return buf;
};
export const getEmptyVkSurfaceCapabilitiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSurfaceCapabilitiesKHR"));
  buf.underlyingType = "VkSurfaceCapabilitiesKHR";
  return buf;
};
export const getEmptyVkSurfaceFormatKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSurfaceFormatKHR"));
  buf.underlyingType = "VkSurfaceFormatKHR";
  return buf;
};
export const getEmptyVkSwapchainCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSwapchainCreateInfoKHR"));
  buf.underlyingType = "VkSwapchainCreateInfoKHR";
  return buf;
};
export const getEmptyVkPresentInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPresentInfoKHR"));
  buf.underlyingType = "VkPresentInfoKHR";
  return buf;
};
export const getEmptyVkValidationFlagsEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkValidationFlagsEXT"));
  buf.underlyingType = "VkValidationFlagsEXT";
  return buf;
};
export const getEmptyVkValidationFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkValidationFeaturesEXT"));
  buf.underlyingType = "VkValidationFeaturesEXT";
  return buf;
};
export const getEmptyVkDevicePrivateDataCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDevicePrivateDataCreateInfo"));
  buf.underlyingType = "VkDevicePrivateDataCreateInfo";
  return buf;
};
export const getEmptyVkDevicePrivateDataCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDevicePrivateDataCreateInfoEXT"));
  buf.underlyingType = "VkDevicePrivateDataCreateInfoEXT";
  return buf;
};
export const getEmptyVkPrivateDataSlotCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPrivateDataSlotCreateInfo"));
  buf.underlyingType = "VkPrivateDataSlotCreateInfo";
  return buf;
};
export const getEmptyVkPrivateDataSlotCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPrivateDataSlotCreateInfoEXT"));
  buf.underlyingType = "VkPrivateDataSlotCreateInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDevicePrivateDataFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePrivateDataFeatures"));
  buf.underlyingType = "VkPhysicalDevicePrivateDataFeatures";
  return buf;
};
export const getEmptyVkPhysicalDevicePrivateDataFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePrivateDataFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDevicePrivateDataFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceMultiDrawPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMultiDrawPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceMultiDrawPropertiesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceFeatures2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFeatures2"));
  buf.underlyingType = "VkPhysicalDeviceFeatures2";
  return buf;
};
export const getEmptyVkPhysicalDeviceFeatures2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFeatures2KHR"));
  buf.underlyingType = "VkPhysicalDeviceFeatures2KHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceProperties2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceProperties2"));
  buf.underlyingType = "VkPhysicalDeviceProperties2";
  return buf;
};
export const getEmptyVkPhysicalDeviceProperties2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceProperties2KHR"));
  buf.underlyingType = "VkPhysicalDeviceProperties2KHR";
  return buf;
};
export const getEmptyVkFormatProperties2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkFormatProperties2"));
  buf.underlyingType = "VkFormatProperties2";
  return buf;
};
export const getEmptyVkFormatProperties2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkFormatProperties2KHR"));
  buf.underlyingType = "VkFormatProperties2KHR";
  return buf;
};
export const getEmptyVkImageFormatProperties2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageFormatProperties2"));
  buf.underlyingType = "VkImageFormatProperties2";
  return buf;
};
export const getEmptyVkImageFormatProperties2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageFormatProperties2KHR"));
  buf.underlyingType = "VkImageFormatProperties2KHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceImageFormatInfo2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImageFormatInfo2"));
  buf.underlyingType = "VkPhysicalDeviceImageFormatInfo2";
  return buf;
};
export const getEmptyVkPhysicalDeviceImageFormatInfo2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImageFormatInfo2KHR"));
  buf.underlyingType = "VkPhysicalDeviceImageFormatInfo2KHR";
  return buf;
};
export const getEmptyVkQueueFamilyProperties2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkQueueFamilyProperties2"));
  buf.underlyingType = "VkQueueFamilyProperties2";
  return buf;
};
export const getEmptyVkQueueFamilyProperties2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkQueueFamilyProperties2KHR"));
  buf.underlyingType = "VkQueueFamilyProperties2KHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceMemoryProperties2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMemoryProperties2"));
  buf.underlyingType = "VkPhysicalDeviceMemoryProperties2";
  return buf;
};
export const getEmptyVkPhysicalDeviceMemoryProperties2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMemoryProperties2KHR"));
  buf.underlyingType = "VkPhysicalDeviceMemoryProperties2KHR";
  return buf;
};
export const getEmptyVkSparseImageFormatProperties2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSparseImageFormatProperties2"));
  buf.underlyingType = "VkSparseImageFormatProperties2";
  return buf;
};
export const getEmptyVkSparseImageFormatProperties2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSparseImageFormatProperties2KHR"));
  buf.underlyingType = "VkSparseImageFormatProperties2KHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceSparseImageFormatInfo2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSparseImageFormatInfo2"));
  buf.underlyingType = "VkPhysicalDeviceSparseImageFormatInfo2";
  return buf;
};
export const getEmptyVkPhysicalDeviceSparseImageFormatInfo2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSparseImageFormatInfo2KHR"));
  buf.underlyingType = "VkPhysicalDeviceSparseImageFormatInfo2KHR";
  return buf;
};
export const getEmptyVkPhysicalDevicePushDescriptorPropertiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePushDescriptorPropertiesKHR"));
  buf.underlyingType = "VkPhysicalDevicePushDescriptorPropertiesKHR";
  return buf;
};
export const getEmptyVkConformanceVersion = (): Membuf => {
  const buf = new Membuf(getStructSize("VkConformanceVersion"));
  buf.underlyingType = "VkConformanceVersion";
  return buf;
};
export const getEmptyVkConformanceVersionKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkConformanceVersionKHR"));
  buf.underlyingType = "VkConformanceVersionKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceDriverProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceDriverProperties"));
  buf.underlyingType = "VkPhysicalDeviceDriverProperties";
  return buf;
};
export const getEmptyVkPhysicalDeviceDriverPropertiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceDriverPropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceDriverPropertiesKHR";
  return buf;
};
export const getEmptyVkPresentRegionsKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPresentRegionsKHR"));
  buf.underlyingType = "VkPresentRegionsKHR";
  return buf;
};
export const getEmptyVkPresentRegionKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPresentRegionKHR"));
  buf.underlyingType = "VkPresentRegionKHR";
  return buf;
};
export const getEmptyVkRectLayerKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRectLayerKHR"));
  buf.underlyingType = "VkRectLayerKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceVariablePointersFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVariablePointersFeatures"));
  buf.underlyingType = "VkPhysicalDeviceVariablePointersFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceVariablePointersFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVariablePointersFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceVariablePointersFeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceVariablePointerFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVariablePointerFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceVariablePointerFeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceVariablePointerFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVariablePointerFeatures"));
  buf.underlyingType = "VkPhysicalDeviceVariablePointerFeatures";
  return buf;
};
export const getEmptyVkExternalMemoryProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkExternalMemoryProperties"));
  buf.underlyingType = "VkExternalMemoryProperties";
  return buf;
};
export const getEmptyVkPhysicalDeviceExternalImageFormatInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceExternalImageFormatInfo"));
  buf.underlyingType = "VkPhysicalDeviceExternalImageFormatInfo";
  return buf;
};
export const getEmptyVkExternalImageFormatProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkExternalImageFormatProperties"));
  buf.underlyingType = "VkExternalImageFormatProperties";
  return buf;
};
export const getEmptyVkPhysicalDeviceExternalBufferInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceExternalBufferInfo"));
  buf.underlyingType = "VkPhysicalDeviceExternalBufferInfo";
  return buf;
};
export const getEmptyVkExternalBufferProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkExternalBufferProperties"));
  buf.underlyingType = "VkExternalBufferProperties";
  return buf;
};
export const getEmptyVkPhysicalDeviceIDProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceIDProperties"));
  buf.underlyingType = "VkPhysicalDeviceIDProperties";
  return buf;
};
export const getEmptyVkExternalMemoryImageCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkExternalMemoryImageCreateInfo"));
  buf.underlyingType = "VkExternalMemoryImageCreateInfo";
  return buf;
};
export const getEmptyVkExternalMemoryBufferCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkExternalMemoryBufferCreateInfo"));
  buf.underlyingType = "VkExternalMemoryBufferCreateInfo";
  return buf;
};
export const getEmptyVkExportMemoryAllocateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkExportMemoryAllocateInfo"));
  buf.underlyingType = "VkExportMemoryAllocateInfo";
  return buf;
};
export const getEmptyVkPhysicalDeviceExternalSemaphoreInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceExternalSemaphoreInfo"));
  buf.underlyingType = "VkPhysicalDeviceExternalSemaphoreInfo";
  return buf;
};
export const getEmptyVkExternalSemaphoreProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkExternalSemaphoreProperties"));
  buf.underlyingType = "VkExternalSemaphoreProperties";
  return buf;
};
export const getEmptyVkExportSemaphoreCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkExportSemaphoreCreateInfo"));
  buf.underlyingType = "VkExportSemaphoreCreateInfo";
  return buf;
};
export const getEmptyVkPhysicalDeviceExternalFenceInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceExternalFenceInfo"));
  buf.underlyingType = "VkPhysicalDeviceExternalFenceInfo";
  return buf;
};
export const getEmptyVkExternalFenceProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkExternalFenceProperties"));
  buf.underlyingType = "VkExternalFenceProperties";
  return buf;
};
export const getEmptyVkExportFenceCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkExportFenceCreateInfo"));
  buf.underlyingType = "VkExportFenceCreateInfo";
  return buf;
};
export const getEmptyVkPhysicalDeviceMultiviewFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMultiviewFeatures"));
  buf.underlyingType = "VkPhysicalDeviceMultiviewFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceMultiviewFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMultiviewFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceMultiviewFeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceMultiviewProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMultiviewProperties"));
  buf.underlyingType = "VkPhysicalDeviceMultiviewProperties";
  return buf;
};
export const getEmptyVkPhysicalDeviceMultiviewPropertiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMultiviewPropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceMultiviewPropertiesKHR";
  return buf;
};
export const getEmptyVkRenderPassMultiviewCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderPassMultiviewCreateInfo"));
  buf.underlyingType = "VkRenderPassMultiviewCreateInfo";
  return buf;
};
export const getEmptyVkRenderPassMultiviewCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderPassMultiviewCreateInfoKHR"));
  buf.underlyingType = "VkRenderPassMultiviewCreateInfoKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceGroupProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceGroupProperties"));
  buf.underlyingType = "VkPhysicalDeviceGroupProperties";
  return buf;
};
export const getEmptyVkPhysicalDeviceGroupPropertiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceGroupPropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceGroupPropertiesKHR";
  return buf;
};
export const getEmptyVkMemoryAllocateFlagsInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMemoryAllocateFlagsInfo"));
  buf.underlyingType = "VkMemoryAllocateFlagsInfo";
  return buf;
};
export const getEmptyVkMemoryAllocateFlagsInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMemoryAllocateFlagsInfoKHR"));
  buf.underlyingType = "VkMemoryAllocateFlagsInfoKHR";
  return buf;
};
export const getEmptyVkBindBufferMemoryInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBindBufferMemoryInfo"));
  buf.underlyingType = "VkBindBufferMemoryInfo";
  return buf;
};
export const getEmptyVkBindBufferMemoryInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBindBufferMemoryInfoKHR"));
  buf.underlyingType = "VkBindBufferMemoryInfoKHR";
  return buf;
};
export const getEmptyVkBindBufferMemoryDeviceGroupInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBindBufferMemoryDeviceGroupInfo"));
  buf.underlyingType = "VkBindBufferMemoryDeviceGroupInfo";
  return buf;
};
export const getEmptyVkBindBufferMemoryDeviceGroupInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBindBufferMemoryDeviceGroupInfoKHR"));
  buf.underlyingType = "VkBindBufferMemoryDeviceGroupInfoKHR";
  return buf;
};
export const getEmptyVkBindImageMemoryInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBindImageMemoryInfo"));
  buf.underlyingType = "VkBindImageMemoryInfo";
  return buf;
};
export const getEmptyVkBindImageMemoryInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBindImageMemoryInfoKHR"));
  buf.underlyingType = "VkBindImageMemoryInfoKHR";
  return buf;
};
export const getEmptyVkBindImageMemoryDeviceGroupInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBindImageMemoryDeviceGroupInfo"));
  buf.underlyingType = "VkBindImageMemoryDeviceGroupInfo";
  return buf;
};
export const getEmptyVkBindImageMemoryDeviceGroupInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBindImageMemoryDeviceGroupInfoKHR"));
  buf.underlyingType = "VkBindImageMemoryDeviceGroupInfoKHR";
  return buf;
};
export const getEmptyVkDeviceGroupRenderPassBeginInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceGroupRenderPassBeginInfo"));
  buf.underlyingType = "VkDeviceGroupRenderPassBeginInfo";
  return buf;
};
export const getEmptyVkDeviceGroupRenderPassBeginInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceGroupRenderPassBeginInfoKHR"));
  buf.underlyingType = "VkDeviceGroupRenderPassBeginInfoKHR";
  return buf;
};
export const getEmptyVkDeviceGroupCommandBufferBeginInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceGroupCommandBufferBeginInfo"));
  buf.underlyingType = "VkDeviceGroupCommandBufferBeginInfo";
  return buf;
};
export const getEmptyVkDeviceGroupCommandBufferBeginInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceGroupCommandBufferBeginInfoKHR"));
  buf.underlyingType = "VkDeviceGroupCommandBufferBeginInfoKHR";
  return buf;
};
export const getEmptyVkDeviceGroupSubmitInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceGroupSubmitInfo"));
  buf.underlyingType = "VkDeviceGroupSubmitInfo";
  return buf;
};
export const getEmptyVkDeviceGroupSubmitInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceGroupSubmitInfoKHR"));
  buf.underlyingType = "VkDeviceGroupSubmitInfoKHR";
  return buf;
};
export const getEmptyVkDeviceGroupBindSparseInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceGroupBindSparseInfo"));
  buf.underlyingType = "VkDeviceGroupBindSparseInfo";
  return buf;
};
export const getEmptyVkDeviceGroupBindSparseInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceGroupBindSparseInfoKHR"));
  buf.underlyingType = "VkDeviceGroupBindSparseInfoKHR";
  return buf;
};
export const getEmptyVkDeviceGroupPresentCapabilitiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceGroupPresentCapabilitiesKHR"));
  buf.underlyingType = "VkDeviceGroupPresentCapabilitiesKHR";
  return buf;
};
export const getEmptyVkImageSwapchainCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageSwapchainCreateInfoKHR"));
  buf.underlyingType = "VkImageSwapchainCreateInfoKHR";
  return buf;
};
export const getEmptyVkBindImageMemorySwapchainInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBindImageMemorySwapchainInfoKHR"));
  buf.underlyingType = "VkBindImageMemorySwapchainInfoKHR";
  return buf;
};
export const getEmptyVkAcquireNextImageInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkAcquireNextImageInfoKHR"));
  buf.underlyingType = "VkAcquireNextImageInfoKHR";
  return buf;
};
export const getEmptyVkDeviceGroupPresentInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceGroupPresentInfoKHR"));
  buf.underlyingType = "VkDeviceGroupPresentInfoKHR";
  return buf;
};
export const getEmptyVkDeviceGroupDeviceCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceGroupDeviceCreateInfo"));
  buf.underlyingType = "VkDeviceGroupDeviceCreateInfo";
  return buf;
};
export const getEmptyVkDeviceGroupDeviceCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceGroupDeviceCreateInfoKHR"));
  buf.underlyingType = "VkDeviceGroupDeviceCreateInfoKHR";
  return buf;
};
export const getEmptyVkDeviceGroupSwapchainCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceGroupSwapchainCreateInfoKHR"));
  buf.underlyingType = "VkDeviceGroupSwapchainCreateInfoKHR";
  return buf;
};
export const getEmptyVkDescriptorUpdateTemplateEntry = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDescriptorUpdateTemplateEntry"));
  buf.underlyingType = "VkDescriptorUpdateTemplateEntry";
  return buf;
};
export const getEmptyVkDescriptorUpdateTemplateEntryKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDescriptorUpdateTemplateEntryKHR"));
  buf.underlyingType = "VkDescriptorUpdateTemplateEntryKHR";
  return buf;
};
export const getEmptyVkDescriptorUpdateTemplateCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDescriptorUpdateTemplateCreateInfo"));
  buf.underlyingType = "VkDescriptorUpdateTemplateCreateInfo";
  return buf;
};
export const getEmptyVkDescriptorUpdateTemplateCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDescriptorUpdateTemplateCreateInfoKHR"));
  buf.underlyingType = "VkDescriptorUpdateTemplateCreateInfoKHR";
  return buf;
};
export const getEmptyVkXYColorEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkXYColorEXT"));
  buf.underlyingType = "VkXYColorEXT";
  return buf;
};
export const getEmptyVkPhysicalDevicePresentIdFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePresentIdFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDevicePresentIdFeaturesKHR";
  return buf;
};
export const getEmptyVkPresentIdKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPresentIdKHR"));
  buf.underlyingType = "VkPresentIdKHR";
  return buf;
};
export const getEmptyVkPhysicalDevicePresentWaitFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePresentWaitFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDevicePresentWaitFeaturesKHR";
  return buf;
};
export const getEmptyVkHdrMetadataEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkHdrMetadataEXT"));
  buf.underlyingType = "VkHdrMetadataEXT";
  return buf;
};
export const getEmptyVkInputAttachmentAspectReference = (): Membuf => {
  const buf = new Membuf(getStructSize("VkInputAttachmentAspectReference"));
  buf.underlyingType = "VkInputAttachmentAspectReference";
  return buf;
};
export const getEmptyVkRenderPassInputAttachmentAspectCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderPassInputAttachmentAspectCreateInfo"));
  buf.underlyingType = "VkRenderPassInputAttachmentAspectCreateInfo";
  return buf;
};
export const getEmptyVkPhysicalDeviceSurfaceInfo2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSurfaceInfo2KHR"));
  buf.underlyingType = "VkPhysicalDeviceSurfaceInfo2KHR";
  return buf;
};
export const getEmptyVkSurfaceCapabilities2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSurfaceCapabilities2KHR"));
  buf.underlyingType = "VkSurfaceCapabilities2KHR";
  return buf;
};
export const getEmptyVkSurfaceFormat2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSurfaceFormat2KHR"));
  buf.underlyingType = "VkSurfaceFormat2KHR";
  return buf;
};
export const getEmptyVkDisplayProperties2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDisplayProperties2KHR"));
  buf.underlyingType = "VkDisplayProperties2KHR";
  return buf;
};
export const getEmptyVkDisplayPlaneProperties2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDisplayPlaneProperties2KHR"));
  buf.underlyingType = "VkDisplayPlaneProperties2KHR";
  return buf;
};
export const getEmptyVkDisplayModeProperties2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDisplayModeProperties2KHR"));
  buf.underlyingType = "VkDisplayModeProperties2KHR";
  return buf;
};
export const getEmptyVkDisplayPlaneInfo2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDisplayPlaneInfo2KHR"));
  buf.underlyingType = "VkDisplayPlaneInfo2KHR";
  return buf;
};
export const getEmptyVkDisplayPlaneCapabilities2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDisplayPlaneCapabilities2KHR"));
  buf.underlyingType = "VkDisplayPlaneCapabilities2KHR";
  return buf;
};
export const getEmptyVkSharedPresentSurfaceCapabilitiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSharedPresentSurfaceCapabilitiesKHR"));
  buf.underlyingType = "VkSharedPresentSurfaceCapabilitiesKHR";
  return buf;
};
export const getEmptyVkPhysicalDevice16BitStorageFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevice16BitStorageFeatures"));
  buf.underlyingType = "VkPhysicalDevice16BitStorageFeatures";
  return buf;
};
export const getEmptyVkPhysicalDevice16BitStorageFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevice16BitStorageFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDevice16BitStorageFeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceSubgroupProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSubgroupProperties"));
  buf.underlyingType = "VkPhysicalDeviceSubgroupProperties";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderSubgroupExtendedTypesFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures"));
  buf.underlyingType = "VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR";
  return buf;
};
export const getEmptyVkBufferMemoryRequirementsInfo2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBufferMemoryRequirementsInfo2"));
  buf.underlyingType = "VkBufferMemoryRequirementsInfo2";
  return buf;
};
export const getEmptyVkBufferMemoryRequirementsInfo2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBufferMemoryRequirementsInfo2KHR"));
  buf.underlyingType = "VkBufferMemoryRequirementsInfo2KHR";
  return buf;
};
export const getEmptyVkDeviceBufferMemoryRequirements = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceBufferMemoryRequirements"));
  buf.underlyingType = "VkDeviceBufferMemoryRequirements";
  return buf;
};
export const getEmptyVkImageMemoryRequirementsInfo2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageMemoryRequirementsInfo2"));
  buf.underlyingType = "VkImageMemoryRequirementsInfo2";
  return buf;
};
export const getEmptyVkImageMemoryRequirementsInfo2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageMemoryRequirementsInfo2KHR"));
  buf.underlyingType = "VkImageMemoryRequirementsInfo2KHR";
  return buf;
};
export const getEmptyVkImageSparseMemoryRequirementsInfo2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageSparseMemoryRequirementsInfo2"));
  buf.underlyingType = "VkImageSparseMemoryRequirementsInfo2";
  return buf;
};
export const getEmptyVkImageSparseMemoryRequirementsInfo2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageSparseMemoryRequirementsInfo2KHR"));
  buf.underlyingType = "VkImageSparseMemoryRequirementsInfo2KHR";
  return buf;
};
export const getEmptyVkDeviceImageMemoryRequirements = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceImageMemoryRequirements"));
  buf.underlyingType = "VkDeviceImageMemoryRequirements";
  return buf;
};
export const getEmptyVkMemoryRequirements2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMemoryRequirements2"));
  buf.underlyingType = "VkMemoryRequirements2";
  return buf;
};
export const getEmptyVkSparseImageMemoryRequirements2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSparseImageMemoryRequirements2"));
  buf.underlyingType = "VkSparseImageMemoryRequirements2";
  return buf;
};
export const getEmptyVkSparseImageMemoryRequirements2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSparseImageMemoryRequirements2KHR"));
  buf.underlyingType = "VkSparseImageMemoryRequirements2KHR";
  return buf;
};
export const getEmptyVkPhysicalDevicePointClippingProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePointClippingProperties"));
  buf.underlyingType = "VkPhysicalDevicePointClippingProperties";
  return buf;
};
export const getEmptyVkMemoryDedicatedRequirements = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMemoryDedicatedRequirements"));
  buf.underlyingType = "VkMemoryDedicatedRequirements";
  return buf;
};
export const getEmptyVkMemoryDedicatedRequirementsKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMemoryDedicatedRequirementsKHR"));
  buf.underlyingType = "VkMemoryDedicatedRequirementsKHR";
  return buf;
};
export const getEmptyVkMemoryDedicatedAllocateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMemoryDedicatedAllocateInfo"));
  buf.underlyingType = "VkMemoryDedicatedAllocateInfo";
  return buf;
};
export const getEmptyVkMemoryDedicatedAllocateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMemoryDedicatedAllocateInfoKHR"));
  buf.underlyingType = "VkMemoryDedicatedAllocateInfoKHR";
  return buf;
};
export const getEmptyVkImageViewUsageCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageViewUsageCreateInfo"));
  buf.underlyingType = "VkImageViewUsageCreateInfo";
  return buf;
};
export const getEmptyVkPipelineTessellationDomainOriginStateCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineTessellationDomainOriginStateCreateInfo"));
  buf.underlyingType = "VkPipelineTessellationDomainOriginStateCreateInfo";
  return buf;
};
export const getEmptyVkSamplerYcbcrConversionInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSamplerYcbcrConversionInfo"));
  buf.underlyingType = "VkSamplerYcbcrConversionInfo";
  return buf;
};
export const getEmptyVkSamplerYcbcrConversionInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSamplerYcbcrConversionInfoKHR"));
  buf.underlyingType = "VkSamplerYcbcrConversionInfoKHR";
  return buf;
};
export const getEmptyVkSamplerYcbcrConversionCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSamplerYcbcrConversionCreateInfo"));
  buf.underlyingType = "VkSamplerYcbcrConversionCreateInfo";
  return buf;
};
export const getEmptyVkSamplerYcbcrConversionCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSamplerYcbcrConversionCreateInfoKHR"));
  buf.underlyingType = "VkSamplerYcbcrConversionCreateInfoKHR";
  return buf;
};
export const getEmptyVkBindImagePlaneMemoryInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBindImagePlaneMemoryInfo"));
  buf.underlyingType = "VkBindImagePlaneMemoryInfo";
  return buf;
};
export const getEmptyVkBindImagePlaneMemoryInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBindImagePlaneMemoryInfoKHR"));
  buf.underlyingType = "VkBindImagePlaneMemoryInfoKHR";
  return buf;
};
export const getEmptyVkImagePlaneMemoryRequirementsInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImagePlaneMemoryRequirementsInfo"));
  buf.underlyingType = "VkImagePlaneMemoryRequirementsInfo";
  return buf;
};
export const getEmptyVkImagePlaneMemoryRequirementsInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImagePlaneMemoryRequirementsInfoKHR"));
  buf.underlyingType = "VkImagePlaneMemoryRequirementsInfoKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceSamplerYcbcrConversionFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSamplerYcbcrConversionFeatures"));
  buf.underlyingType = "VkPhysicalDeviceSamplerYcbcrConversionFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR";
  return buf;
};
export const getEmptyVkSamplerYcbcrConversionImageFormatProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSamplerYcbcrConversionImageFormatProperties"));
  buf.underlyingType = "VkSamplerYcbcrConversionImageFormatProperties";
  return buf;
};
export const getEmptyVkSamplerYcbcrConversionImageFormatPropertiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSamplerYcbcrConversionImageFormatPropertiesKHR"));
  buf.underlyingType = "VkSamplerYcbcrConversionImageFormatPropertiesKHR";
  return buf;
};
export const getEmptyVkProtectedSubmitInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkProtectedSubmitInfo"));
  buf.underlyingType = "VkProtectedSubmitInfo";
  return buf;
};
export const getEmptyVkPhysicalDeviceProtectedMemoryFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceProtectedMemoryFeatures"));
  buf.underlyingType = "VkPhysicalDeviceProtectedMemoryFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceProtectedMemoryProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceProtectedMemoryProperties"));
  buf.underlyingType = "VkPhysicalDeviceProtectedMemoryProperties";
  return buf;
};
export const getEmptyVkDeviceQueueInfo2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceQueueInfo2"));
  buf.underlyingType = "VkDeviceQueueInfo2";
  return buf;
};
export const getEmptyVkPhysicalDeviceSamplerFilterMinmaxProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSamplerFilterMinmaxProperties"));
  buf.underlyingType = "VkPhysicalDeviceSamplerFilterMinmaxProperties";
  return buf;
};
export const getEmptyVkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT";
  return buf;
};
export const getEmptyVkSampleLocationEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSampleLocationEXT"));
  buf.underlyingType = "VkSampleLocationEXT";
  return buf;
};
export const getEmptyVkSampleLocationsInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSampleLocationsInfoEXT"));
  buf.underlyingType = "VkSampleLocationsInfoEXT";
  return buf;
};
export const getEmptyVkAttachmentSampleLocationsEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkAttachmentSampleLocationsEXT"));
  buf.underlyingType = "VkAttachmentSampleLocationsEXT";
  return buf;
};
export const getEmptyVkSubpassSampleLocationsEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSubpassSampleLocationsEXT"));
  buf.underlyingType = "VkSubpassSampleLocationsEXT";
  return buf;
};
export const getEmptyVkRenderPassSampleLocationsBeginInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderPassSampleLocationsBeginInfoEXT"));
  buf.underlyingType = "VkRenderPassSampleLocationsBeginInfoEXT";
  return buf;
};
export const getEmptyVkPipelineSampleLocationsStateCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineSampleLocationsStateCreateInfoEXT"));
  buf.underlyingType = "VkPipelineSampleLocationsStateCreateInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceSampleLocationsPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSampleLocationsPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceSampleLocationsPropertiesEXT";
  return buf;
};
export const getEmptyVkMultisamplePropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMultisamplePropertiesEXT"));
  buf.underlyingType = "VkMultisamplePropertiesEXT";
  return buf;
};
export const getEmptyVkSamplerReductionModeCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSamplerReductionModeCreateInfo"));
  buf.underlyingType = "VkSamplerReductionModeCreateInfo";
  return buf;
};
export const getEmptyVkSamplerReductionModeCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSamplerReductionModeCreateInfoEXT"));
  buf.underlyingType = "VkSamplerReductionModeCreateInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceMultiDrawFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMultiDrawFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceMultiDrawFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceInlineUniformBlockFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceInlineUniformBlockFeatures"));
  buf.underlyingType = "VkPhysicalDeviceInlineUniformBlockFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceInlineUniformBlockFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceInlineUniformBlockFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceInlineUniformBlockFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceInlineUniformBlockProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceInlineUniformBlockProperties"));
  buf.underlyingType = "VkPhysicalDeviceInlineUniformBlockProperties";
  return buf;
};
export const getEmptyVkPhysicalDeviceInlineUniformBlockPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceInlineUniformBlockPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceInlineUniformBlockPropertiesEXT";
  return buf;
};
export const getEmptyVkWriteDescriptorSetInlineUniformBlock = (): Membuf => {
  const buf = new Membuf(getStructSize("VkWriteDescriptorSetInlineUniformBlock"));
  buf.underlyingType = "VkWriteDescriptorSetInlineUniformBlock";
  return buf;
};
export const getEmptyVkWriteDescriptorSetInlineUniformBlockEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkWriteDescriptorSetInlineUniformBlockEXT"));
  buf.underlyingType = "VkWriteDescriptorSetInlineUniformBlockEXT";
  return buf;
};
export const getEmptyVkDescriptorPoolInlineUniformBlockCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDescriptorPoolInlineUniformBlockCreateInfo"));
  buf.underlyingType = "VkDescriptorPoolInlineUniformBlockCreateInfo";
  return buf;
};
export const getEmptyVkDescriptorPoolInlineUniformBlockCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDescriptorPoolInlineUniformBlockCreateInfoEXT"));
  buf.underlyingType = "VkDescriptorPoolInlineUniformBlockCreateInfoEXT";
  return buf;
};
export const getEmptyVkImageFormatListCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageFormatListCreateInfo"));
  buf.underlyingType = "VkImageFormatListCreateInfo";
  return buf;
};
export const getEmptyVkImageFormatListCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageFormatListCreateInfoKHR"));
  buf.underlyingType = "VkImageFormatListCreateInfoKHR";
  return buf;
};
export const getEmptyVkValidationCacheCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkValidationCacheCreateInfoEXT"));
  buf.underlyingType = "VkValidationCacheCreateInfoEXT";
  return buf;
};
export const getEmptyVkShaderModuleValidationCacheCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkShaderModuleValidationCacheCreateInfoEXT"));
  buf.underlyingType = "VkShaderModuleValidationCacheCreateInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceMaintenance3Properties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMaintenance3Properties"));
  buf.underlyingType = "VkPhysicalDeviceMaintenance3Properties";
  return buf;
};
export const getEmptyVkPhysicalDeviceMaintenance4Features = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMaintenance4Features"));
  buf.underlyingType = "VkPhysicalDeviceMaintenance4Features";
  return buf;
};
export const getEmptyVkPhysicalDeviceMaintenance4Properties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMaintenance4Properties"));
  buf.underlyingType = "VkPhysicalDeviceMaintenance4Properties";
  return buf;
};
export const getEmptyVkDescriptorSetLayoutSupport = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDescriptorSetLayoutSupport"));
  buf.underlyingType = "VkDescriptorSetLayoutSupport";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderDrawParametersFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderDrawParametersFeatures"));
  buf.underlyingType = "VkPhysicalDeviceShaderDrawParametersFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderDrawParameterFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderDrawParameterFeatures"));
  buf.underlyingType = "VkPhysicalDeviceShaderDrawParameterFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderFloat16Int8Features = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderFloat16Int8Features"));
  buf.underlyingType = "VkPhysicalDeviceShaderFloat16Int8Features";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderFloat16Int8FeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderFloat16Int8FeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceShaderFloat16Int8FeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceFloat16Int8FeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFloat16Int8FeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceFloat16Int8FeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceFloatControlsProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFloatControlsProperties"));
  buf.underlyingType = "VkPhysicalDeviceFloatControlsProperties";
  return buf;
};
export const getEmptyVkPhysicalDeviceFloatControlsPropertiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFloatControlsPropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceFloatControlsPropertiesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceHostQueryResetFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceHostQueryResetFeatures"));
  buf.underlyingType = "VkPhysicalDeviceHostQueryResetFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceHostQueryResetFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceHostQueryResetFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceHostQueryResetFeaturesEXT";
  return buf;
};
export const getEmptyVkDeviceQueueGlobalPriorityCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceQueueGlobalPriorityCreateInfoKHR"));
  buf.underlyingType = "VkDeviceQueueGlobalPriorityCreateInfoKHR";
  return buf;
};
export const getEmptyVkDeviceQueueGlobalPriorityCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceQueueGlobalPriorityCreateInfoEXT"));
  buf.underlyingType = "VkDeviceQueueGlobalPriorityCreateInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceGlobalPriorityQueryFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceGlobalPriorityQueryFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT";
  return buf;
};
export const getEmptyVkQueueFamilyGlobalPriorityPropertiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkQueueFamilyGlobalPriorityPropertiesKHR"));
  buf.underlyingType = "VkQueueFamilyGlobalPriorityPropertiesKHR";
  return buf;
};
export const getEmptyVkQueueFamilyGlobalPriorityPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkQueueFamilyGlobalPriorityPropertiesEXT"));
  buf.underlyingType = "VkQueueFamilyGlobalPriorityPropertiesEXT";
  return buf;
};
export const getEmptyVkImportMemoryHostPointerInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImportMemoryHostPointerInfoEXT"));
  buf.underlyingType = "VkImportMemoryHostPointerInfoEXT";
  return buf;
};
export const getEmptyVkMemoryHostPointerPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMemoryHostPointerPropertiesEXT"));
  buf.underlyingType = "VkMemoryHostPointerPropertiesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceExternalMemoryHostPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceExternalMemoryHostPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceExternalMemoryHostPropertiesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceDescriptorIndexingFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceDescriptorIndexingFeatures"));
  buf.underlyingType = "VkPhysicalDeviceDescriptorIndexingFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceDescriptorIndexingProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceDescriptorIndexingProperties"));
  buf.underlyingType = "VkPhysicalDeviceDescriptorIndexingProperties";
  return buf;
};
export const getEmptyVkDescriptorSetLayoutBindingFlagsCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDescriptorSetLayoutBindingFlagsCreateInfo"));
  buf.underlyingType = "VkDescriptorSetLayoutBindingFlagsCreateInfo";
  return buf;
};
export const getEmptyVkDescriptorSetVariableDescriptorCountAllocateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDescriptorSetVariableDescriptorCountAllocateInfo"));
  buf.underlyingType = "VkDescriptorSetVariableDescriptorCountAllocateInfo";
  return buf;
};
export const getEmptyVkDescriptorSetVariableDescriptorCountLayoutSupport = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDescriptorSetVariableDescriptorCountLayoutSupport"));
  buf.underlyingType = "VkDescriptorSetVariableDescriptorCountLayoutSupport";
  return buf;
};
export const getEmptyVkAttachmentDescription2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkAttachmentDescription2"));
  buf.underlyingType = "VkAttachmentDescription2";
  return buf;
};
export const getEmptyVkAttachmentDescription2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkAttachmentDescription2KHR"));
  buf.underlyingType = "VkAttachmentDescription2KHR";
  return buf;
};
export const getEmptyVkAttachmentReference2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkAttachmentReference2"));
  buf.underlyingType = "VkAttachmentReference2";
  return buf;
};
export const getEmptyVkAttachmentReference2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkAttachmentReference2KHR"));
  buf.underlyingType = "VkAttachmentReference2KHR";
  return buf;
};
export const getEmptyVkSubpassDescription2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSubpassDescription2"));
  buf.underlyingType = "VkSubpassDescription2";
  return buf;
};
export const getEmptyVkSubpassDescription2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSubpassDescription2KHR"));
  buf.underlyingType = "VkSubpassDescription2KHR";
  return buf;
};
export const getEmptyVkSubpassDependency2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSubpassDependency2"));
  buf.underlyingType = "VkSubpassDependency2";
  return buf;
};
export const getEmptyVkSubpassDependency2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSubpassDependency2KHR"));
  buf.underlyingType = "VkSubpassDependency2KHR";
  return buf;
};
export const getEmptyVkRenderPassCreateInfo2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderPassCreateInfo2"));
  buf.underlyingType = "VkRenderPassCreateInfo2";
  return buf;
};
export const getEmptyVkRenderPassCreateInfo2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderPassCreateInfo2KHR"));
  buf.underlyingType = "VkRenderPassCreateInfo2KHR";
  return buf;
};
export const getEmptyVkSubpassBeginInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSubpassBeginInfo"));
  buf.underlyingType = "VkSubpassBeginInfo";
  return buf;
};
export const getEmptyVkSubpassBeginInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSubpassBeginInfoKHR"));
  buf.underlyingType = "VkSubpassBeginInfoKHR";
  return buf;
};
export const getEmptyVkSubpassEndInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSubpassEndInfo"));
  buf.underlyingType = "VkSubpassEndInfo";
  return buf;
};
export const getEmptyVkSubpassEndInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSubpassEndInfoKHR"));
  buf.underlyingType = "VkSubpassEndInfoKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceTimelineSemaphoreFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTimelineSemaphoreFeatures"));
  buf.underlyingType = "VkPhysicalDeviceTimelineSemaphoreFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceTimelineSemaphoreFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTimelineSemaphoreFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceTimelineSemaphoreFeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceTimelineSemaphoreProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTimelineSemaphoreProperties"));
  buf.underlyingType = "VkPhysicalDeviceTimelineSemaphoreProperties";
  return buf;
};
export const getEmptyVkPhysicalDeviceTimelineSemaphorePropertiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTimelineSemaphorePropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceTimelineSemaphorePropertiesKHR";
  return buf;
};
export const getEmptyVkSemaphoreTypeCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSemaphoreTypeCreateInfo"));
  buf.underlyingType = "VkSemaphoreTypeCreateInfo";
  return buf;
};
export const getEmptyVkSemaphoreTypeCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSemaphoreTypeCreateInfoKHR"));
  buf.underlyingType = "VkSemaphoreTypeCreateInfoKHR";
  return buf;
};
export const getEmptyVkTimelineSemaphoreSubmitInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkTimelineSemaphoreSubmitInfo"));
  buf.underlyingType = "VkTimelineSemaphoreSubmitInfo";
  return buf;
};
export const getEmptyVkTimelineSemaphoreSubmitInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkTimelineSemaphoreSubmitInfoKHR"));
  buf.underlyingType = "VkTimelineSemaphoreSubmitInfoKHR";
  return buf;
};
export const getEmptyVkSemaphoreWaitInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSemaphoreWaitInfo"));
  buf.underlyingType = "VkSemaphoreWaitInfo";
  return buf;
};
export const getEmptyVkSemaphoreWaitInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSemaphoreWaitInfoKHR"));
  buf.underlyingType = "VkSemaphoreWaitInfoKHR";
  return buf;
};
export const getEmptyVkSemaphoreSignalInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSemaphoreSignalInfo"));
  buf.underlyingType = "VkSemaphoreSignalInfo";
  return buf;
};
export const getEmptyVkSemaphoreSignalInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSemaphoreSignalInfoKHR"));
  buf.underlyingType = "VkSemaphoreSignalInfoKHR";
  return buf;
};
export const getEmptyVkVertexInputBindingDivisorDescriptionEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkVertexInputBindingDivisorDescriptionEXT"));
  buf.underlyingType = "VkVertexInputBindingDivisorDescriptionEXT";
  return buf;
};
export const getEmptyVkPipelineVertexInputDivisorStateCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineVertexInputDivisorStateCreateInfoEXT"));
  buf.underlyingType = "VkPipelineVertexInputDivisorStateCreateInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceVertexAttributeDivisorPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT";
  return buf;
};
export const getEmptyVkPhysicalDevicePCIBusInfoPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePCIBusInfoPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDevicePCIBusInfoPropertiesEXT";
  return buf;
};
export const getEmptyVkPhysicalDevice8BitStorageFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevice8BitStorageFeatures"));
  buf.underlyingType = "VkPhysicalDevice8BitStorageFeatures";
  return buf;
};
export const getEmptyVkPhysicalDevice8BitStorageFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevice8BitStorageFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDevice8BitStorageFeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceVulkanMemoryModelFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVulkanMemoryModelFeatures"));
  buf.underlyingType = "VkPhysicalDeviceVulkanMemoryModelFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceVulkanMemoryModelFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVulkanMemoryModelFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceVulkanMemoryModelFeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderAtomicInt64Features = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderAtomicInt64Features"));
  buf.underlyingType = "VkPhysicalDeviceShaderAtomicInt64Features";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderAtomicInt64FeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderAtomicInt64FeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceShaderAtomicInt64FeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderAtomicFloatFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderAtomicFloatFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceShaderAtomicFloatFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderAtomicFloat2FeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceVertexAttributeDivisorFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceDepthStencilResolveProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceDepthStencilResolveProperties"));
  buf.underlyingType = "VkPhysicalDeviceDepthStencilResolveProperties";
  return buf;
};
export const getEmptyVkPhysicalDeviceDepthStencilResolvePropertiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceDepthStencilResolvePropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceDepthStencilResolvePropertiesKHR";
  return buf;
};
export const getEmptyVkSubpassDescriptionDepthStencilResolve = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSubpassDescriptionDepthStencilResolve"));
  buf.underlyingType = "VkSubpassDescriptionDepthStencilResolve";
  return buf;
};
export const getEmptyVkSubpassDescriptionDepthStencilResolveKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSubpassDescriptionDepthStencilResolveKHR"));
  buf.underlyingType = "VkSubpassDescriptionDepthStencilResolveKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceTransformFeedbackFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTransformFeedbackFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceTransformFeedbackFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceTransformFeedbackPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTransformFeedbackPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceTransformFeedbackPropertiesEXT";
  return buf;
};
export const getEmptyVkPipelineRasterizationStateStreamCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineRasterizationStateStreamCreateInfoEXT"));
  buf.underlyingType = "VkPipelineRasterizationStateStreamCreateInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceMeshShaderFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMeshShaderFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceMeshShaderFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceMeshShaderPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMeshShaderPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceMeshShaderPropertiesEXT";
  return buf;
};
export const getEmptyVkDrawMeshTasksIndirectCommandEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDrawMeshTasksIndirectCommandEXT"));
  buf.underlyingType = "VkDrawMeshTasksIndirectCommandEXT";
  return buf;
};
export const getEmptyVkRayTracingShaderGroupCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRayTracingShaderGroupCreateInfoKHR"));
  buf.underlyingType = "VkRayTracingShaderGroupCreateInfoKHR";
  return buf;
};
export const getEmptyVkRayTracingPipelineCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRayTracingPipelineCreateInfoKHR"));
  buf.underlyingType = "VkRayTracingPipelineCreateInfoKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceRayTracingPipelineFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceRayTracingPipelineFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceRayTracingPipelineFeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceRayQueryFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceRayQueryFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceRayQueryFeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceRayTracingPipelinePropertiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceRayTracingPipelinePropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceRayTracingPipelinePropertiesKHR";
  return buf;
};
export const getEmptyVkStridedDeviceAddressRegionKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkStridedDeviceAddressRegionKHR"));
  buf.underlyingType = "VkStridedDeviceAddressRegionKHR";
  return buf;
};
export const getEmptyVkTraceRaysIndirectCommandKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkTraceRaysIndirectCommandKHR"));
  buf.underlyingType = "VkTraceRaysIndirectCommandKHR";
  return buf;
};
export const getEmptyVkTraceRaysIndirectCommand2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkTraceRaysIndirectCommand2KHR"));
  buf.underlyingType = "VkTraceRaysIndirectCommand2KHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceRayTracingMaintenance1FeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR";
  return buf;
};
export const getEmptyVkDrmFormatModifierPropertiesListEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDrmFormatModifierPropertiesListEXT"));
  buf.underlyingType = "VkDrmFormatModifierPropertiesListEXT";
  return buf;
};
export const getEmptyVkDrmFormatModifierPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDrmFormatModifierPropertiesEXT"));
  buf.underlyingType = "VkDrmFormatModifierPropertiesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceImageDrmFormatModifierInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImageDrmFormatModifierInfoEXT"));
  buf.underlyingType = "VkPhysicalDeviceImageDrmFormatModifierInfoEXT";
  return buf;
};
export const getEmptyVkImageDrmFormatModifierListCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageDrmFormatModifierListCreateInfoEXT"));
  buf.underlyingType = "VkImageDrmFormatModifierListCreateInfoEXT";
  return buf;
};
export const getEmptyVkImageDrmFormatModifierExplicitCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageDrmFormatModifierExplicitCreateInfoEXT"));
  buf.underlyingType = "VkImageDrmFormatModifierExplicitCreateInfoEXT";
  return buf;
};
export const getEmptyVkImageDrmFormatModifierPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageDrmFormatModifierPropertiesEXT"));
  buf.underlyingType = "VkImageDrmFormatModifierPropertiesEXT";
  return buf;
};
export const getEmptyVkImageStencilUsageCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageStencilUsageCreateInfo"));
  buf.underlyingType = "VkImageStencilUsageCreateInfo";
  return buf;
};
export const getEmptyVkImageStencilUsageCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageStencilUsageCreateInfoEXT"));
  buf.underlyingType = "VkImageStencilUsageCreateInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceFragmentDensityMapFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentDensityMapFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceFragmentDensityMapFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceFragmentDensityMap2FeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentDensityMap2FeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceFragmentDensityMap2FeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceFragmentDensityMapPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentDensityMapPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceFragmentDensityMapPropertiesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceFragmentDensityMap2PropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentDensityMap2PropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceFragmentDensityMap2PropertiesEXT";
  return buf;
};
export const getEmptyVkRenderPassFragmentDensityMapCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderPassFragmentDensityMapCreateInfoEXT"));
  buf.underlyingType = "VkRenderPassFragmentDensityMapCreateInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceScalarBlockLayoutFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceScalarBlockLayoutFeatures"));
  buf.underlyingType = "VkPhysicalDeviceScalarBlockLayoutFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceScalarBlockLayoutFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceScalarBlockLayoutFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceScalarBlockLayoutFeaturesEXT";
  return buf;
};
export const getEmptyVkSurfaceProtectedCapabilitiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSurfaceProtectedCapabilitiesKHR"));
  buf.underlyingType = "VkSurfaceProtectedCapabilitiesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceUniformBufferStandardLayoutFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceUniformBufferStandardLayoutFeatures"));
  buf.underlyingType = "VkPhysicalDeviceUniformBufferStandardLayoutFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceMemoryBudgetPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMemoryBudgetPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceMemoryBudgetPropertiesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceMemoryPriorityFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMemoryPriorityFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceMemoryPriorityFeaturesEXT";
  return buf;
};
export const getEmptyVkMemoryPriorityAllocateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMemoryPriorityAllocateInfoEXT"));
  buf.underlyingType = "VkMemoryPriorityAllocateInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceBufferDeviceAddressFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceBufferDeviceAddressFeatures"));
  buf.underlyingType = "VkPhysicalDeviceBufferDeviceAddressFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceBufferDeviceAddressFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceBufferDeviceAddressFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceBufferDeviceAddressFeaturesKHR";
  return buf;
};
export const getEmptyVkBufferDeviceAddressInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBufferDeviceAddressInfo"));
  buf.underlyingType = "VkBufferDeviceAddressInfo";
  return buf;
};
export const getEmptyVkBufferDeviceAddressInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBufferDeviceAddressInfoKHR"));
  buf.underlyingType = "VkBufferDeviceAddressInfoKHR";
  return buf;
};
export const getEmptyVkBufferOpaqueCaptureAddressCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBufferOpaqueCaptureAddressCreateInfo"));
  buf.underlyingType = "VkBufferOpaqueCaptureAddressCreateInfo";
  return buf;
};
export const getEmptyVkBufferOpaqueCaptureAddressCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBufferOpaqueCaptureAddressCreateInfoKHR"));
  buf.underlyingType = "VkBufferOpaqueCaptureAddressCreateInfoKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceImageViewImageFormatInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImageViewImageFormatInfoEXT"));
  buf.underlyingType = "VkPhysicalDeviceImageViewImageFormatInfoEXT";
  return buf;
};
export const getEmptyVkFilterCubicImageViewImageFormatPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkFilterCubicImageViewImageFormatPropertiesEXT"));
  buf.underlyingType = "VkFilterCubicImageViewImageFormatPropertiesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceImagelessFramebufferFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImagelessFramebufferFeatures"));
  buf.underlyingType = "VkPhysicalDeviceImagelessFramebufferFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceImagelessFramebufferFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImagelessFramebufferFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceImagelessFramebufferFeaturesKHR";
  return buf;
};
export const getEmptyVkFramebufferAttachmentsCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkFramebufferAttachmentsCreateInfo"));
  buf.underlyingType = "VkFramebufferAttachmentsCreateInfo";
  return buf;
};
export const getEmptyVkFramebufferAttachmentsCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkFramebufferAttachmentsCreateInfoKHR"));
  buf.underlyingType = "VkFramebufferAttachmentsCreateInfoKHR";
  return buf;
};
export const getEmptyVkFramebufferAttachmentImageInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkFramebufferAttachmentImageInfo"));
  buf.underlyingType = "VkFramebufferAttachmentImageInfo";
  return buf;
};
export const getEmptyVkFramebufferAttachmentImageInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkFramebufferAttachmentImageInfoKHR"));
  buf.underlyingType = "VkFramebufferAttachmentImageInfoKHR";
  return buf;
};
export const getEmptyVkRenderPassAttachmentBeginInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderPassAttachmentBeginInfo"));
  buf.underlyingType = "VkRenderPassAttachmentBeginInfo";
  return buf;
};
export const getEmptyVkRenderPassAttachmentBeginInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderPassAttachmentBeginInfoKHR"));
  buf.underlyingType = "VkRenderPassAttachmentBeginInfoKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceTextureCompressionASTCHDRFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTextureCompressionASTCHDRFeatures"));
  buf.underlyingType = "VkPhysicalDeviceTextureCompressionASTCHDRFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceYcbcrImageArraysFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceYcbcrImageArraysFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceYcbcrImageArraysFeaturesEXT";
  return buf;
};
export const getEmptyVkPipelineCreationFeedback = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineCreationFeedback"));
  buf.underlyingType = "VkPipelineCreationFeedback";
  return buf;
};
export const getEmptyVkPipelineCreationFeedbackEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineCreationFeedbackEXT"));
  buf.underlyingType = "VkPipelineCreationFeedbackEXT";
  return buf;
};
export const getEmptyVkPipelineCreationFeedbackCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineCreationFeedbackCreateInfo"));
  buf.underlyingType = "VkPipelineCreationFeedbackCreateInfo";
  return buf;
};
export const getEmptyVkPipelineCreationFeedbackCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineCreationFeedbackCreateInfoEXT"));
  buf.underlyingType = "VkPipelineCreationFeedbackCreateInfoEXT";
  return buf;
};
export const getEmptyVkHeadlessSurfaceCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkHeadlessSurfaceCreateInfoEXT"));
  buf.underlyingType = "VkHeadlessSurfaceCreateInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderClockFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderClockFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceShaderClockFeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceIndexTypeUint8FeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceIndexTypeUint8FeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceIndexTypeUint8FeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceFragmentShaderInterlockFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceSeparateDepthStencilLayoutsFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures"));
  buf.underlyingType = "VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR";
  return buf;
};
export const getEmptyVkAttachmentReferenceStencilLayout = (): Membuf => {
  const buf = new Membuf(getStructSize("VkAttachmentReferenceStencilLayout"));
  buf.underlyingType = "VkAttachmentReferenceStencilLayout";
  return buf;
};
export const getEmptyVkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT";
  return buf;
};
export const getEmptyVkAttachmentReferenceStencilLayoutKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkAttachmentReferenceStencilLayoutKHR"));
  buf.underlyingType = "VkAttachmentReferenceStencilLayoutKHR";
  return buf;
};
export const getEmptyVkAttachmentDescriptionStencilLayout = (): Membuf => {
  const buf = new Membuf(getStructSize("VkAttachmentDescriptionStencilLayout"));
  buf.underlyingType = "VkAttachmentDescriptionStencilLayout";
  return buf;
};
export const getEmptyVkAttachmentDescriptionStencilLayoutKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkAttachmentDescriptionStencilLayoutKHR"));
  buf.underlyingType = "VkAttachmentDescriptionStencilLayoutKHR";
  return buf;
};
export const getEmptyVkPipelineInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineInfoEXT"));
  buf.underlyingType = "VkPipelineInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderDemoteToHelperInvocationFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures"));
  buf.underlyingType = "VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceTexelBufferAlignmentFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceTexelBufferAlignmentProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTexelBufferAlignmentProperties"));
  buf.underlyingType = "VkPhysicalDeviceTexelBufferAlignmentProperties";
  return buf;
};
export const getEmptyVkPhysicalDeviceTexelBufferAlignmentPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceSubgroupSizeControlFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSubgroupSizeControlFeatures"));
  buf.underlyingType = "VkPhysicalDeviceSubgroupSizeControlFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceSubgroupSizeControlFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSubgroupSizeControlFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceSubgroupSizeControlFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceSubgroupSizeControlProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSubgroupSizeControlProperties"));
  buf.underlyingType = "VkPhysicalDeviceSubgroupSizeControlProperties";
  return buf;
};
export const getEmptyVkPhysicalDeviceSubgroupSizeControlPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSubgroupSizeControlPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceSubgroupSizeControlPropertiesEXT";
  return buf;
};
export const getEmptyVkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT"));
  buf.underlyingType = "VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT";
  return buf;
};
export const getEmptyVkMemoryOpaqueCaptureAddressAllocateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMemoryOpaqueCaptureAddressAllocateInfo"));
  buf.underlyingType = "VkMemoryOpaqueCaptureAddressAllocateInfo";
  return buf;
};
export const getEmptyVkMemoryOpaqueCaptureAddressAllocateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMemoryOpaqueCaptureAddressAllocateInfoKHR"));
  buf.underlyingType = "VkMemoryOpaqueCaptureAddressAllocateInfoKHR";
  return buf;
};
export const getEmptyVkDeviceMemoryOpaqueCaptureAddressInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceMemoryOpaqueCaptureAddressInfo"));
  buf.underlyingType = "VkDeviceMemoryOpaqueCaptureAddressInfo";
  return buf;
};
export const getEmptyVkDeviceMemoryOpaqueCaptureAddressInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDeviceMemoryOpaqueCaptureAddressInfoKHR"));
  buf.underlyingType = "VkDeviceMemoryOpaqueCaptureAddressInfoKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceLineRasterizationFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceLineRasterizationFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceLineRasterizationFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceLineRasterizationPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceLineRasterizationPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceLineRasterizationPropertiesEXT";
  return buf;
};
export const getEmptyVkPipelineRasterizationLineStateCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineRasterizationLineStateCreateInfoEXT"));
  buf.underlyingType = "VkPipelineRasterizationLineStateCreateInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDevicePipelineCreationCacheControlFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePipelineCreationCacheControlFeatures"));
  buf.underlyingType = "VkPhysicalDevicePipelineCreationCacheControlFeatures";
  return buf;
};
export const getEmptyVkPhysicalDevicePipelineCreationCacheControlFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceVulkan11Features = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVulkan11Features"));
  buf.underlyingType = "VkPhysicalDeviceVulkan11Features";
  return buf;
};
export const getEmptyVkPhysicalDeviceVulkan11Properties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVulkan11Properties"));
  buf.underlyingType = "VkPhysicalDeviceVulkan11Properties";
  return buf;
};
export const getEmptyVkPhysicalDeviceVulkan12Features = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVulkan12Features"));
  buf.underlyingType = "VkPhysicalDeviceVulkan12Features";
  return buf;
};
export const getEmptyVkPhysicalDeviceVulkan12Properties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVulkan12Properties"));
  buf.underlyingType = "VkPhysicalDeviceVulkan12Properties";
  return buf;
};
export const getEmptyVkPhysicalDeviceVulkan13Features = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVulkan13Features"));
  buf.underlyingType = "VkPhysicalDeviceVulkan13Features";
  return buf;
};
export const getEmptyVkPhysicalDeviceVulkan13Properties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVulkan13Properties"));
  buf.underlyingType = "VkPhysicalDeviceVulkan13Properties";
  return buf;
};
export const getEmptyVkPhysicalDeviceToolProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceToolProperties"));
  buf.underlyingType = "VkPhysicalDeviceToolProperties";
  return buf;
};
export const getEmptyVkPhysicalDeviceToolPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceToolPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceToolPropertiesEXT";
  return buf;
};
export const getEmptyVkRayTracingPipelineInterfaceCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRayTracingPipelineInterfaceCreateInfoKHR"));
  buf.underlyingType = "VkRayTracingPipelineInterfaceCreateInfoKHR";
  return buf;
};
export const getEmptyVkPipelineLibraryCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineLibraryCreateInfoKHR"));
  buf.underlyingType = "VkPipelineLibraryCreateInfoKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures"));
  buf.underlyingType = "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceRobustness2FeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceRobustness2FeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceRobustness2FeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceRobustness2PropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceRobustness2PropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceRobustness2PropertiesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceImageRobustnessFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImageRobustnessFeatures"));
  buf.underlyingType = "VkPhysicalDeviceImageRobustnessFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceImageRobustnessFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImageRobustnessFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceImageRobustnessFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR";
  return buf;
};
export const getEmptyVkBufferCopy2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBufferCopy2"));
  buf.underlyingType = "VkBufferCopy2";
  return buf;
};
export const getEmptyVkBufferCopy2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBufferCopy2KHR"));
  buf.underlyingType = "VkBufferCopy2KHR";
  return buf;
};
export const getEmptyVkImageCopy2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageCopy2"));
  buf.underlyingType = "VkImageCopy2";
  return buf;
};
export const getEmptyVkImageCopy2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageCopy2KHR"));
  buf.underlyingType = "VkImageCopy2KHR";
  return buf;
};
export const getEmptyVkImageBlit2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageBlit2"));
  buf.underlyingType = "VkImageBlit2";
  return buf;
};
export const getEmptyVkImageBlit2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageBlit2KHR"));
  buf.underlyingType = "VkImageBlit2KHR";
  return buf;
};
export const getEmptyVkBufferImageCopy2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBufferImageCopy2"));
  buf.underlyingType = "VkBufferImageCopy2";
  return buf;
};
export const getEmptyVkBufferImageCopy2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBufferImageCopy2KHR"));
  buf.underlyingType = "VkBufferImageCopy2KHR";
  return buf;
};
export const getEmptyVkImageResolve2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageResolve2"));
  buf.underlyingType = "VkImageResolve2";
  return buf;
};
export const getEmptyVkImageResolve2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageResolve2KHR"));
  buf.underlyingType = "VkImageResolve2KHR";
  return buf;
};
export const getEmptyVkCopyBufferInfo2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkCopyBufferInfo2"));
  buf.underlyingType = "VkCopyBufferInfo2";
  return buf;
};
export const getEmptyVkCopyBufferInfo2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkCopyBufferInfo2KHR"));
  buf.underlyingType = "VkCopyBufferInfo2KHR";
  return buf;
};
export const getEmptyVkCopyImageInfo2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkCopyImageInfo2"));
  buf.underlyingType = "VkCopyImageInfo2";
  return buf;
};
export const getEmptyVkCopyImageInfo2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkCopyImageInfo2KHR"));
  buf.underlyingType = "VkCopyImageInfo2KHR";
  return buf;
};
export const getEmptyVkBlitImageInfo2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBlitImageInfo2"));
  buf.underlyingType = "VkBlitImageInfo2";
  return buf;
};
export const getEmptyVkBlitImageInfo2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBlitImageInfo2KHR"));
  buf.underlyingType = "VkBlitImageInfo2KHR";
  return buf;
};
export const getEmptyVkCopyBufferToImageInfo2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkCopyBufferToImageInfo2"));
  buf.underlyingType = "VkCopyBufferToImageInfo2";
  return buf;
};
export const getEmptyVkCopyBufferToImageInfo2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkCopyBufferToImageInfo2KHR"));
  buf.underlyingType = "VkCopyBufferToImageInfo2KHR";
  return buf;
};
export const getEmptyVkCopyImageToBufferInfo2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkCopyImageToBufferInfo2"));
  buf.underlyingType = "VkCopyImageToBufferInfo2";
  return buf;
};
export const getEmptyVkCopyImageToBufferInfo2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkCopyImageToBufferInfo2KHR"));
  buf.underlyingType = "VkCopyImageToBufferInfo2KHR";
  return buf;
};
export const getEmptyVkResolveImageInfo2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkResolveImageInfo2"));
  buf.underlyingType = "VkResolveImageInfo2";
  return buf;
};
export const getEmptyVkResolveImageInfo2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkResolveImageInfo2KHR"));
  buf.underlyingType = "VkResolveImageInfo2KHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT";
  return buf;
};
export const getEmptyVkFragmentShadingRateAttachmentInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkFragmentShadingRateAttachmentInfoKHR"));
  buf.underlyingType = "VkFragmentShadingRateAttachmentInfoKHR";
  return buf;
};
export const getEmptyVkPipelineFragmentShadingRateStateCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineFragmentShadingRateStateCreateInfoKHR"));
  buf.underlyingType = "VkPipelineFragmentShadingRateStateCreateInfoKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceFragmentShadingRateFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentShadingRateFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceFragmentShadingRateFeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceFragmentShadingRatePropertiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentShadingRatePropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceFragmentShadingRatePropertiesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceFragmentShadingRateKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentShadingRateKHR"));
  buf.underlyingType = "VkPhysicalDeviceFragmentShadingRateKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderTerminateInvocationFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderTerminateInvocationFeatures"));
  buf.underlyingType = "VkPhysicalDeviceShaderTerminateInvocationFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderTerminateInvocationFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceImage2DViewOf3DFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImage2DViewOf3DFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceImage2DViewOf3DFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceMutableDescriptorTypeFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT";
  return buf;
};
export const getEmptyVkMutableDescriptorTypeListEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMutableDescriptorTypeListEXT"));
  buf.underlyingType = "VkMutableDescriptorTypeListEXT";
  return buf;
};
export const getEmptyVkMutableDescriptorTypeCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMutableDescriptorTypeCreateInfoEXT"));
  buf.underlyingType = "VkMutableDescriptorTypeCreateInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceVertexInputDynamicStateFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT";
  return buf;
};
export const getEmptyVkMemoryBarrier2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMemoryBarrier2"));
  buf.underlyingType = "VkMemoryBarrier2";
  return buf;
};
export const getEmptyVkMemoryBarrier2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMemoryBarrier2KHR"));
  buf.underlyingType = "VkMemoryBarrier2KHR";
  return buf;
};
export const getEmptyVkImageMemoryBarrier2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageMemoryBarrier2"));
  buf.underlyingType = "VkImageMemoryBarrier2";
  return buf;
};
export const getEmptyVkImageMemoryBarrier2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageMemoryBarrier2KHR"));
  buf.underlyingType = "VkImageMemoryBarrier2KHR";
  return buf;
};
export const getEmptyVkBufferMemoryBarrier2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBufferMemoryBarrier2"));
  buf.underlyingType = "VkBufferMemoryBarrier2";
  return buf;
};
export const getEmptyVkBufferMemoryBarrier2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBufferMemoryBarrier2KHR"));
  buf.underlyingType = "VkBufferMemoryBarrier2KHR";
  return buf;
};
export const getEmptyVkDependencyInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDependencyInfo"));
  buf.underlyingType = "VkDependencyInfo";
  return buf;
};
export const getEmptyVkDependencyInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDependencyInfoKHR"));
  buf.underlyingType = "VkDependencyInfoKHR";
  return buf;
};
export const getEmptyVkSemaphoreSubmitInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSemaphoreSubmitInfo"));
  buf.underlyingType = "VkSemaphoreSubmitInfo";
  return buf;
};
export const getEmptyVkSemaphoreSubmitInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSemaphoreSubmitInfoKHR"));
  buf.underlyingType = "VkSemaphoreSubmitInfoKHR";
  return buf;
};
export const getEmptyVkCommandBufferSubmitInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkCommandBufferSubmitInfo"));
  buf.underlyingType = "VkCommandBufferSubmitInfo";
  return buf;
};
export const getEmptyVkCommandBufferSubmitInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkCommandBufferSubmitInfoKHR"));
  buf.underlyingType = "VkCommandBufferSubmitInfoKHR";
  return buf;
};
export const getEmptyVkSubmitInfo2 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSubmitInfo2"));
  buf.underlyingType = "VkSubmitInfo2";
  return buf;
};
export const getEmptyVkSubmitInfo2KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSubmitInfo2KHR"));
  buf.underlyingType = "VkSubmitInfo2KHR";
  return buf;
};
export const getEmptyVkQueueFamilyCheckpointProperties2NV = (): Membuf => {
  const buf = new Membuf(getStructSize("VkQueueFamilyCheckpointProperties2NV"));
  buf.underlyingType = "VkQueueFamilyCheckpointProperties2NV";
  return buf;
};
export const getEmptyVkCheckpointData2NV = (): Membuf => {
  const buf = new Membuf(getStructSize("VkCheckpointData2NV"));
  buf.underlyingType = "VkCheckpointData2NV";
  return buf;
};
export const getEmptyVkPhysicalDeviceSynchronization2Features = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSynchronization2Features"));
  buf.underlyingType = "VkPhysicalDeviceSynchronization2Features";
  return buf;
};
export const getEmptyVkPhysicalDeviceSynchronization2FeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSynchronization2FeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceSynchronization2FeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceLegacyDitheringFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceLegacyDitheringFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceLegacyDitheringFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT";
  return buf;
};
export const getEmptyVkSubpassResolvePerformanceQueryEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSubpassResolvePerformanceQueryEXT"));
  buf.underlyingType = "VkSubpassResolvePerformanceQueryEXT";
  return buf;
};
export const getEmptyVkMultisampledRenderToSingleSampledInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMultisampledRenderToSingleSampledInfoEXT"));
  buf.underlyingType = "VkMultisampledRenderToSingleSampledInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDevicePipelineProtectedAccessFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePipelineProtectedAccessFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDevicePipelineProtectedAccessFeaturesEXT";
  return buf;
};
export const getEmptyVkQueueFamilyVideoPropertiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkQueueFamilyVideoPropertiesKHR"));
  buf.underlyingType = "VkQueueFamilyVideoPropertiesKHR";
  return buf;
};
export const getEmptyVkQueueFamilyQueryResultStatusPropertiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkQueueFamilyQueryResultStatusPropertiesKHR"));
  buf.underlyingType = "VkQueueFamilyQueryResultStatusPropertiesKHR";
  return buf;
};
export const getEmptyVkVideoProfileListInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkVideoProfileListInfoKHR"));
  buf.underlyingType = "VkVideoProfileListInfoKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceVideoFormatInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVideoFormatInfoKHR"));
  buf.underlyingType = "VkPhysicalDeviceVideoFormatInfoKHR";
  return buf;
};
export const getEmptyVkVideoFormatPropertiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkVideoFormatPropertiesKHR"));
  buf.underlyingType = "VkVideoFormatPropertiesKHR";
  return buf;
};
export const getEmptyVkVideoProfileInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkVideoProfileInfoKHR"));
  buf.underlyingType = "VkVideoProfileInfoKHR";
  return buf;
};
export const getEmptyVkVideoCapabilitiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkVideoCapabilitiesKHR"));
  buf.underlyingType = "VkVideoCapabilitiesKHR";
  return buf;
};
export const getEmptyVkVideoSessionMemoryRequirementsKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkVideoSessionMemoryRequirementsKHR"));
  buf.underlyingType = "VkVideoSessionMemoryRequirementsKHR";
  return buf;
};
export const getEmptyVkBindVideoSessionMemoryInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkBindVideoSessionMemoryInfoKHR"));
  buf.underlyingType = "VkBindVideoSessionMemoryInfoKHR";
  return buf;
};
export const getEmptyVkVideoPictureResourceInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkVideoPictureResourceInfoKHR"));
  buf.underlyingType = "VkVideoPictureResourceInfoKHR";
  return buf;
};
export const getEmptyVkVideoReferenceSlotInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkVideoReferenceSlotInfoKHR"));
  buf.underlyingType = "VkVideoReferenceSlotInfoKHR";
  return buf;
};
export const getEmptyVkVideoSessionCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkVideoSessionCreateInfoKHR"));
  buf.underlyingType = "VkVideoSessionCreateInfoKHR";
  return buf;
};
export const getEmptyVkVideoSessionParametersCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkVideoSessionParametersCreateInfoKHR"));
  buf.underlyingType = "VkVideoSessionParametersCreateInfoKHR";
  return buf;
};
export const getEmptyVkVideoSessionParametersUpdateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkVideoSessionParametersUpdateInfoKHR"));
  buf.underlyingType = "VkVideoSessionParametersUpdateInfoKHR";
  return buf;
};
export const getEmptyVkVideoBeginCodingInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkVideoBeginCodingInfoKHR"));
  buf.underlyingType = "VkVideoBeginCodingInfoKHR";
  return buf;
};
export const getEmptyVkVideoEndCodingInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkVideoEndCodingInfoKHR"));
  buf.underlyingType = "VkVideoEndCodingInfoKHR";
  return buf;
};
export const getEmptyVkVideoCodingControlInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkVideoCodingControlInfoKHR"));
  buf.underlyingType = "VkVideoCodingControlInfoKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceProvokingVertexFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceProvokingVertexFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceProvokingVertexFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceProvokingVertexPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceProvokingVertexPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceProvokingVertexPropertiesEXT";
  return buf;
};
export const getEmptyVkPipelineRasterizationProvokingVertexStateCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineRasterizationProvokingVertexStateCreateInfoEXT"));
  buf.underlyingType = "VkPipelineRasterizationProvokingVertexStateCreateInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderIntegerDotProductFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderIntegerDotProductFeatures"));
  buf.underlyingType = "VkPhysicalDeviceShaderIntegerDotProductFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderIntegerDotProductFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderIntegerDotProductProperties = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderIntegerDotProductProperties"));
  buf.underlyingType = "VkPhysicalDeviceShaderIntegerDotProductProperties";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderIntegerDotProductPropertiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceDrmPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceDrmPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceDrmPropertiesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR";
  return buf;
};
export const getEmptyVkPhysicalDeviceRGBA10X6FormatsFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT";
  return buf;
};
export const getEmptyVkFormatProperties3 = (): Membuf => {
  const buf = new Membuf(getStructSize("VkFormatProperties3"));
  buf.underlyingType = "VkFormatProperties3";
  return buf;
};
export const getEmptyVkFormatProperties3KHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkFormatProperties3KHR"));
  buf.underlyingType = "VkFormatProperties3KHR";
  return buf;
};
export const getEmptyVkDrmFormatModifierPropertiesList2EXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDrmFormatModifierPropertiesList2EXT"));
  buf.underlyingType = "VkDrmFormatModifierPropertiesList2EXT";
  return buf;
};
export const getEmptyVkDrmFormatModifierProperties2EXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkDrmFormatModifierProperties2EXT"));
  buf.underlyingType = "VkDrmFormatModifierProperties2EXT";
  return buf;
};
export const getEmptyVkPipelineRenderingCreateInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineRenderingCreateInfo"));
  buf.underlyingType = "VkPipelineRenderingCreateInfo";
  return buf;
};
export const getEmptyVkPipelineRenderingCreateInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineRenderingCreateInfoKHR"));
  buf.underlyingType = "VkPipelineRenderingCreateInfoKHR";
  return buf;
};
export const getEmptyVkRenderingInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderingInfo"));
  buf.underlyingType = "VkRenderingInfo";
  return buf;
};
export const getEmptyVkRenderingAttachmentInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderingAttachmentInfo"));
  buf.underlyingType = "VkRenderingAttachmentInfo";
  return buf;
};
export const getEmptyVkRenderingAttachmentInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderingAttachmentInfoKHR"));
  buf.underlyingType = "VkRenderingAttachmentInfoKHR";
  return buf;
};
export const getEmptyVkRenderingFragmentShadingRateAttachmentInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderingFragmentShadingRateAttachmentInfoKHR"));
  buf.underlyingType = "VkRenderingFragmentShadingRateAttachmentInfoKHR";
  return buf;
};
export const getEmptyVkRenderingFragmentDensityMapAttachmentInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderingFragmentDensityMapAttachmentInfoEXT"));
  buf.underlyingType = "VkRenderingFragmentDensityMapAttachmentInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceDynamicRenderingFeatures = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceDynamicRenderingFeatures"));
  buf.underlyingType = "VkPhysicalDeviceDynamicRenderingFeatures";
  return buf;
};
export const getEmptyVkPhysicalDeviceDynamicRenderingFeaturesKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceDynamicRenderingFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceDynamicRenderingFeaturesKHR";
  return buf;
};
export const getEmptyVkCommandBufferInheritanceRenderingInfo = (): Membuf => {
  const buf = new Membuf(getStructSize("VkCommandBufferInheritanceRenderingInfo"));
  buf.underlyingType = "VkCommandBufferInheritanceRenderingInfo";
  return buf;
};
export const getEmptyVkCommandBufferInheritanceRenderingInfoKHR = (): Membuf => {
  const buf = new Membuf(getStructSize("VkCommandBufferInheritanceRenderingInfoKHR"));
  buf.underlyingType = "VkCommandBufferInheritanceRenderingInfoKHR";
  return buf;
};
export const getEmptyVkAttachmentSampleCountInfoAMD = (): Membuf => {
  const buf = new Membuf(getStructSize("VkAttachmentSampleCountInfoAMD"));
  buf.underlyingType = "VkAttachmentSampleCountInfoAMD";
  return buf;
};
export const getEmptyVkAttachmentSampleCountInfoNV = (): Membuf => {
  const buf = new Membuf(getStructSize("VkAttachmentSampleCountInfoNV"));
  buf.underlyingType = "VkAttachmentSampleCountInfoNV";
  return buf;
};
export const getEmptyVkMultiviewPerViewAttributesInfoNVX = (): Membuf => {
  const buf = new Membuf(getStructSize("VkMultiviewPerViewAttributesInfoNVX"));
  buf.underlyingType = "VkMultiviewPerViewAttributesInfoNVX";
  return buf;
};
export const getEmptyVkPhysicalDeviceImageViewMinLodFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImageViewMinLodFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceImageViewMinLodFeaturesEXT";
  return buf;
};
export const getEmptyVkImageViewMinLodCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageViewMinLodCreateInfoEXT"));
  buf.underlyingType = "VkImageViewMinLodCreateInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT";
  return buf;
};
export const getEmptyVkGraphicsPipelineLibraryCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkGraphicsPipelineLibraryCreateInfoEXT"));
  buf.underlyingType = "VkGraphicsPipelineLibraryCreateInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderModuleIdentifierFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceShaderModuleIdentifierPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT";
  return buf;
};
export const getEmptyVkPipelineShaderStageModuleIdentifierCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineShaderStageModuleIdentifierCreateInfoEXT"));
  buf.underlyingType = "VkPipelineShaderStageModuleIdentifierCreateInfoEXT";
  return buf;
};
export const getEmptyVkShaderModuleIdentifierEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkShaderModuleIdentifierEXT"));
  buf.underlyingType = "VkShaderModuleIdentifierEXT";
  return buf;
};
export const getEmptyVkImageCompressionControlEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageCompressionControlEXT"));
  buf.underlyingType = "VkImageCompressionControlEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceImageCompressionControlFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImageCompressionControlFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceImageCompressionControlFeaturesEXT";
  return buf;
};
export const getEmptyVkImageCompressionPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkImageCompressionPropertiesEXT"));
  buf.underlyingType = "VkImageCompressionPropertiesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT";
  return buf;
};
export const getEmptyVkRenderPassCreationControlEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderPassCreationControlEXT"));
  buf.underlyingType = "VkRenderPassCreationControlEXT";
  return buf;
};
export const getEmptyVkRenderPassCreationFeedbackInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderPassCreationFeedbackInfoEXT"));
  buf.underlyingType = "VkRenderPassCreationFeedbackInfoEXT";
  return buf;
};
export const getEmptyVkRenderPassCreationFeedbackCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderPassCreationFeedbackCreateInfoEXT"));
  buf.underlyingType = "VkRenderPassCreationFeedbackCreateInfoEXT";
  return buf;
};
export const getEmptyVkRenderPassSubpassFeedbackInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderPassSubpassFeedbackInfoEXT"));
  buf.underlyingType = "VkRenderPassSubpassFeedbackInfoEXT";
  return buf;
};
export const getEmptyVkRenderPassSubpassFeedbackCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkRenderPassSubpassFeedbackCreateInfoEXT"));
  buf.underlyingType = "VkRenderPassSubpassFeedbackCreateInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT";
  return buf;
};
export const getEmptyVkPipelinePropertiesIdentifierEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelinePropertiesIdentifierEXT"));
  buf.underlyingType = "VkPipelinePropertiesIdentifierEXT";
  return buf;
};
export const getEmptyVkPhysicalDevicePipelinePropertiesFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePipelinePropertiesFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDevicePipelinePropertiesFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT";
  return buf;
};
export const getEmptyVkPhysicalDevicePipelineRobustnessFeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePipelineRobustnessFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDevicePipelineRobustnessFeaturesEXT";
  return buf;
};
export const getEmptyVkPipelineRobustnessCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPipelineRobustnessCreateInfoEXT"));
  buf.underlyingType = "VkPipelineRobustnessCreateInfoEXT";
  return buf;
};
export const getEmptyVkPhysicalDevicePipelineRobustnessPropertiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePipelineRobustnessPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDevicePipelineRobustnessPropertiesEXT";
  return buf;
};
export const getEmptyVkSurfacePresentModeEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSurfacePresentModeEXT"));
  buf.underlyingType = "VkSurfacePresentModeEXT";
  return buf;
};
export const getEmptyVkSurfacePresentScalingCapabilitiesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSurfacePresentScalingCapabilitiesEXT"));
  buf.underlyingType = "VkSurfacePresentScalingCapabilitiesEXT";
  return buf;
};
export const getEmptyVkSurfacePresentModeCompatibilityEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSurfacePresentModeCompatibilityEXT"));
  buf.underlyingType = "VkSurfacePresentModeCompatibilityEXT";
  return buf;
};
export const getEmptyVkPhysicalDeviceSwapchainMaintenance1FeaturesEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT";
  return buf;
};
export const getEmptyVkSwapchainPresentFenceInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSwapchainPresentFenceInfoEXT"));
  buf.underlyingType = "VkSwapchainPresentFenceInfoEXT";
  return buf;
};
export const getEmptyVkSwapchainPresentModesCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSwapchainPresentModesCreateInfoEXT"));
  buf.underlyingType = "VkSwapchainPresentModesCreateInfoEXT";
  return buf;
};
export const getEmptyVkSwapchainPresentModeInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSwapchainPresentModeInfoEXT"));
  buf.underlyingType = "VkSwapchainPresentModeInfoEXT";
  return buf;
};
export const getEmptyVkSwapchainPresentScalingCreateInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkSwapchainPresentScalingCreateInfoEXT"));
  buf.underlyingType = "VkSwapchainPresentScalingCreateInfoEXT";
  return buf;
};
export const getEmptyVkReleaseSwapchainImagesInfoEXT = (): Membuf => {
  const buf = new Membuf(getStructSize("VkReleaseSwapchainImagesInfoEXT"));
  buf.underlyingType = "VkReleaseSwapchainImagesInfoEXT";
  return buf;
};
export const getEmptyVkBaseOutStructureArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBaseOutStructure"));
  buf.underlyingType = "VkBaseOutStructure";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBaseInStructureArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBaseInStructure"));
  buf.underlyingType = "VkBaseInStructure";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkOffset2DArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkOffset2D"));
  buf.underlyingType = "VkOffset2D";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkOffset3DArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkOffset3D"));
  buf.underlyingType = "VkOffset3D";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkExtent2DArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkExtent2D"));
  buf.underlyingType = "VkExtent2D";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkExtent3DArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkExtent3D"));
  buf.underlyingType = "VkExtent3D";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkViewportArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkViewport"));
  buf.underlyingType = "VkViewport";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRect2DArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRect2D"));
  buf.underlyingType = "VkRect2D";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkClearRectArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkClearRect"));
  buf.underlyingType = "VkClearRect";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkComponentMappingArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkComponentMapping"));
  buf.underlyingType = "VkComponentMapping";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevicePropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceProperties"));
  buf.underlyingType = "VkPhysicalDeviceProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkExtensionPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkExtensionProperties"));
  buf.underlyingType = "VkExtensionProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkLayerPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkLayerProperties"));
  buf.underlyingType = "VkLayerProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkApplicationInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkApplicationInfo"));
  buf.underlyingType = "VkApplicationInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkAllocationCallbacksArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkAllocationCallbacks"));
  buf.underlyingType = "VkAllocationCallbacks";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceQueueCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceQueueCreateInfo"));
  buf.underlyingType = "VkDeviceQueueCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceCreateInfo"));
  buf.underlyingType = "VkDeviceCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkInstanceCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkInstanceCreateInfo"));
  buf.underlyingType = "VkInstanceCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkQueueFamilyPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkQueueFamilyProperties"));
  buf.underlyingType = "VkQueueFamilyProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceMemoryPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMemoryProperties"));
  buf.underlyingType = "VkPhysicalDeviceMemoryProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMemoryAllocateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMemoryAllocateInfo"));
  buf.underlyingType = "VkMemoryAllocateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMemoryRequirementsArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMemoryRequirements"));
  buf.underlyingType = "VkMemoryRequirements";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSparseImageFormatPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSparseImageFormatProperties"));
  buf.underlyingType = "VkSparseImageFormatProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSparseImageMemoryRequirementsArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSparseImageMemoryRequirements"));
  buf.underlyingType = "VkSparseImageMemoryRequirements";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMemoryTypeArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMemoryType"));
  buf.underlyingType = "VkMemoryType";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMemoryHeapArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMemoryHeap"));
  buf.underlyingType = "VkMemoryHeap";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMappedMemoryRangeArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMappedMemoryRange"));
  buf.underlyingType = "VkMappedMemoryRange";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkFormatPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkFormatProperties"));
  buf.underlyingType = "VkFormatProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageFormatPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageFormatProperties"));
  buf.underlyingType = "VkImageFormatProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDescriptorBufferInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDescriptorBufferInfo"));
  buf.underlyingType = "VkDescriptorBufferInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDescriptorImageInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDescriptorImageInfo"));
  buf.underlyingType = "VkDescriptorImageInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkWriteDescriptorSetArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkWriteDescriptorSet"));
  buf.underlyingType = "VkWriteDescriptorSet";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkCopyDescriptorSetArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkCopyDescriptorSet"));
  buf.underlyingType = "VkCopyDescriptorSet";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBufferCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBufferCreateInfo"));
  buf.underlyingType = "VkBufferCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBufferViewCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBufferViewCreateInfo"));
  buf.underlyingType = "VkBufferViewCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageSubresourceArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageSubresource"));
  buf.underlyingType = "VkImageSubresource";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageSubresourceLayersArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageSubresourceLayers"));
  buf.underlyingType = "VkImageSubresourceLayers";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageSubresourceRangeArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageSubresourceRange"));
  buf.underlyingType = "VkImageSubresourceRange";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMemoryBarrierArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMemoryBarrier"));
  buf.underlyingType = "VkMemoryBarrier";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBufferMemoryBarrierArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBufferMemoryBarrier"));
  buf.underlyingType = "VkBufferMemoryBarrier";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageMemoryBarrierArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageMemoryBarrier"));
  buf.underlyingType = "VkImageMemoryBarrier";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageCreateInfo"));
  buf.underlyingType = "VkImageCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSubresourceLayoutArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSubresourceLayout"));
  buf.underlyingType = "VkSubresourceLayout";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageViewCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageViewCreateInfo"));
  buf.underlyingType = "VkImageViewCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBufferCopyArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBufferCopy"));
  buf.underlyingType = "VkBufferCopy";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSparseMemoryBindArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSparseMemoryBind"));
  buf.underlyingType = "VkSparseMemoryBind";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSparseImageMemoryBindArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSparseImageMemoryBind"));
  buf.underlyingType = "VkSparseImageMemoryBind";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSparseBufferMemoryBindInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSparseBufferMemoryBindInfo"));
  buf.underlyingType = "VkSparseBufferMemoryBindInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSparseImageOpaqueMemoryBindInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSparseImageOpaqueMemoryBindInfo"));
  buf.underlyingType = "VkSparseImageOpaqueMemoryBindInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSparseImageMemoryBindInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSparseImageMemoryBindInfo"));
  buf.underlyingType = "VkSparseImageMemoryBindInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBindSparseInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBindSparseInfo"));
  buf.underlyingType = "VkBindSparseInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageCopyArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageCopy"));
  buf.underlyingType = "VkImageCopy";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageBlitArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageBlit"));
  buf.underlyingType = "VkImageBlit";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBufferImageCopyArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBufferImageCopy"));
  buf.underlyingType = "VkBufferImageCopy";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageResolveArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageResolve"));
  buf.underlyingType = "VkImageResolve";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkShaderModuleCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkShaderModuleCreateInfo"));
  buf.underlyingType = "VkShaderModuleCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDescriptorSetLayoutBindingArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDescriptorSetLayoutBinding"));
  buf.underlyingType = "VkDescriptorSetLayoutBinding";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDescriptorSetLayoutCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDescriptorSetLayoutCreateInfo"));
  buf.underlyingType = "VkDescriptorSetLayoutCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDescriptorPoolSizeArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDescriptorPoolSize"));
  buf.underlyingType = "VkDescriptorPoolSize";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDescriptorPoolCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDescriptorPoolCreateInfo"));
  buf.underlyingType = "VkDescriptorPoolCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDescriptorSetAllocateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDescriptorSetAllocateInfo"));
  buf.underlyingType = "VkDescriptorSetAllocateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSpecializationMapEntryArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSpecializationMapEntry"));
  buf.underlyingType = "VkSpecializationMapEntry";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSpecializationInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSpecializationInfo"));
  buf.underlyingType = "VkSpecializationInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineShaderStageCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineShaderStageCreateInfo"));
  buf.underlyingType = "VkPipelineShaderStageCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkComputePipelineCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkComputePipelineCreateInfo"));
  buf.underlyingType = "VkComputePipelineCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkVertexInputBindingDescriptionArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkVertexInputBindingDescription"));
  buf.underlyingType = "VkVertexInputBindingDescription";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkVertexInputAttributeDescriptionArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkVertexInputAttributeDescription"));
  buf.underlyingType = "VkVertexInputAttributeDescription";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineVertexInputStateCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineVertexInputStateCreateInfo"));
  buf.underlyingType = "VkPipelineVertexInputStateCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineInputAssemblyStateCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineInputAssemblyStateCreateInfo"));
  buf.underlyingType = "VkPipelineInputAssemblyStateCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineTessellationStateCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineTessellationStateCreateInfo"));
  buf.underlyingType = "VkPipelineTessellationStateCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineViewportStateCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineViewportStateCreateInfo"));
  buf.underlyingType = "VkPipelineViewportStateCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineRasterizationStateCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineRasterizationStateCreateInfo"));
  buf.underlyingType = "VkPipelineRasterizationStateCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineMultisampleStateCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineMultisampleStateCreateInfo"));
  buf.underlyingType = "VkPipelineMultisampleStateCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineColorBlendAttachmentStateArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineColorBlendAttachmentState"));
  buf.underlyingType = "VkPipelineColorBlendAttachmentState";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineColorBlendStateCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineColorBlendStateCreateInfo"));
  buf.underlyingType = "VkPipelineColorBlendStateCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineDynamicStateCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineDynamicStateCreateInfo"));
  buf.underlyingType = "VkPipelineDynamicStateCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkStencilOpStateArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkStencilOpState"));
  buf.underlyingType = "VkStencilOpState";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineDepthStencilStateCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineDepthStencilStateCreateInfo"));
  buf.underlyingType = "VkPipelineDepthStencilStateCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkGraphicsPipelineCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkGraphicsPipelineCreateInfo"));
  buf.underlyingType = "VkGraphicsPipelineCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineCacheCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineCacheCreateInfo"));
  buf.underlyingType = "VkPipelineCacheCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineCacheHeaderVersionOneArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineCacheHeaderVersionOne"));
  buf.underlyingType = "VkPipelineCacheHeaderVersionOne";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPushConstantRangeArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPushConstantRange"));
  buf.underlyingType = "VkPushConstantRange";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineLayoutCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineLayoutCreateInfo"));
  buf.underlyingType = "VkPipelineLayoutCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSamplerCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSamplerCreateInfo"));
  buf.underlyingType = "VkSamplerCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkCommandPoolCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkCommandPoolCreateInfo"));
  buf.underlyingType = "VkCommandPoolCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkCommandBufferAllocateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkCommandBufferAllocateInfo"));
  buf.underlyingType = "VkCommandBufferAllocateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkCommandBufferInheritanceInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkCommandBufferInheritanceInfo"));
  buf.underlyingType = "VkCommandBufferInheritanceInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkCommandBufferBeginInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkCommandBufferBeginInfo"));
  buf.underlyingType = "VkCommandBufferBeginInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderPassBeginInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderPassBeginInfo"));
  buf.underlyingType = "VkRenderPassBeginInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkClearDepthStencilValueArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkClearDepthStencilValue"));
  buf.underlyingType = "VkClearDepthStencilValue";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkClearAttachmentArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkClearAttachment"));
  buf.underlyingType = "VkClearAttachment";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkAttachmentDescriptionArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkAttachmentDescription"));
  buf.underlyingType = "VkAttachmentDescription";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkAttachmentReferenceArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkAttachmentReference"));
  buf.underlyingType = "VkAttachmentReference";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSubpassDescriptionArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSubpassDescription"));
  buf.underlyingType = "VkSubpassDescription";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSubpassDependencyArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSubpassDependency"));
  buf.underlyingType = "VkSubpassDependency";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderPassCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderPassCreateInfo"));
  buf.underlyingType = "VkRenderPassCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkEventCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkEventCreateInfo"));
  buf.underlyingType = "VkEventCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkFenceCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkFenceCreateInfo"));
  buf.underlyingType = "VkFenceCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFeatures"));
  buf.underlyingType = "VkPhysicalDeviceFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSparsePropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSparseProperties"));
  buf.underlyingType = "VkPhysicalDeviceSparseProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceLimitsArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceLimits"));
  buf.underlyingType = "VkPhysicalDeviceLimits";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSemaphoreCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSemaphoreCreateInfo"));
  buf.underlyingType = "VkSemaphoreCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkQueryPoolCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkQueryPoolCreateInfo"));
  buf.underlyingType = "VkQueryPoolCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkFramebufferCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkFramebufferCreateInfo"));
  buf.underlyingType = "VkFramebufferCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDrawIndirectCommandArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDrawIndirectCommand"));
  buf.underlyingType = "VkDrawIndirectCommand";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDrawIndexedIndirectCommandArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDrawIndexedIndirectCommand"));
  buf.underlyingType = "VkDrawIndexedIndirectCommand";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDispatchIndirectCommandArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDispatchIndirectCommand"));
  buf.underlyingType = "VkDispatchIndirectCommand";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMultiDrawInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMultiDrawInfoEXT"));
  buf.underlyingType = "VkMultiDrawInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMultiDrawIndexedInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMultiDrawIndexedInfoEXT"));
  buf.underlyingType = "VkMultiDrawIndexedInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSubmitInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSubmitInfo"));
  buf.underlyingType = "VkSubmitInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDisplayPropertiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDisplayPropertiesKHR"));
  buf.underlyingType = "VkDisplayPropertiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDisplayPlanePropertiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDisplayPlanePropertiesKHR"));
  buf.underlyingType = "VkDisplayPlanePropertiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDisplayModeParametersKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDisplayModeParametersKHR"));
  buf.underlyingType = "VkDisplayModeParametersKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDisplayModePropertiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDisplayModePropertiesKHR"));
  buf.underlyingType = "VkDisplayModePropertiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDisplayModeCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDisplayModeCreateInfoKHR"));
  buf.underlyingType = "VkDisplayModeCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDisplayPlaneCapabilitiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDisplayPlaneCapabilitiesKHR"));
  buf.underlyingType = "VkDisplayPlaneCapabilitiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDisplaySurfaceCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDisplaySurfaceCreateInfoKHR"));
  buf.underlyingType = "VkDisplaySurfaceCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDisplayPresentInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDisplayPresentInfoKHR"));
  buf.underlyingType = "VkDisplayPresentInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSurfaceCapabilitiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSurfaceCapabilitiesKHR"));
  buf.underlyingType = "VkSurfaceCapabilitiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSurfaceFormatKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSurfaceFormatKHR"));
  buf.underlyingType = "VkSurfaceFormatKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSwapchainCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSwapchainCreateInfoKHR"));
  buf.underlyingType = "VkSwapchainCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPresentInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPresentInfoKHR"));
  buf.underlyingType = "VkPresentInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkValidationFlagsEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkValidationFlagsEXT"));
  buf.underlyingType = "VkValidationFlagsEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkValidationFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkValidationFeaturesEXT"));
  buf.underlyingType = "VkValidationFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDevicePrivateDataCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDevicePrivateDataCreateInfo"));
  buf.underlyingType = "VkDevicePrivateDataCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDevicePrivateDataCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDevicePrivateDataCreateInfoEXT"));
  buf.underlyingType = "VkDevicePrivateDataCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPrivateDataSlotCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPrivateDataSlotCreateInfo"));
  buf.underlyingType = "VkPrivateDataSlotCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPrivateDataSlotCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPrivateDataSlotCreateInfoEXT"));
  buf.underlyingType = "VkPrivateDataSlotCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevicePrivateDataFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePrivateDataFeatures"));
  buf.underlyingType = "VkPhysicalDevicePrivateDataFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevicePrivateDataFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePrivateDataFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDevicePrivateDataFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceMultiDrawPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMultiDrawPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceMultiDrawPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceFeatures2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFeatures2"));
  buf.underlyingType = "VkPhysicalDeviceFeatures2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceFeatures2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFeatures2KHR"));
  buf.underlyingType = "VkPhysicalDeviceFeatures2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceProperties2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceProperties2"));
  buf.underlyingType = "VkPhysicalDeviceProperties2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceProperties2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceProperties2KHR"));
  buf.underlyingType = "VkPhysicalDeviceProperties2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkFormatProperties2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkFormatProperties2"));
  buf.underlyingType = "VkFormatProperties2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkFormatProperties2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkFormatProperties2KHR"));
  buf.underlyingType = "VkFormatProperties2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageFormatProperties2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageFormatProperties2"));
  buf.underlyingType = "VkImageFormatProperties2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageFormatProperties2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageFormatProperties2KHR"));
  buf.underlyingType = "VkImageFormatProperties2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceImageFormatInfo2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImageFormatInfo2"));
  buf.underlyingType = "VkPhysicalDeviceImageFormatInfo2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceImageFormatInfo2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImageFormatInfo2KHR"));
  buf.underlyingType = "VkPhysicalDeviceImageFormatInfo2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkQueueFamilyProperties2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkQueueFamilyProperties2"));
  buf.underlyingType = "VkQueueFamilyProperties2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkQueueFamilyProperties2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkQueueFamilyProperties2KHR"));
  buf.underlyingType = "VkQueueFamilyProperties2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceMemoryProperties2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMemoryProperties2"));
  buf.underlyingType = "VkPhysicalDeviceMemoryProperties2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceMemoryProperties2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMemoryProperties2KHR"));
  buf.underlyingType = "VkPhysicalDeviceMemoryProperties2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSparseImageFormatProperties2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSparseImageFormatProperties2"));
  buf.underlyingType = "VkSparseImageFormatProperties2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSparseImageFormatProperties2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSparseImageFormatProperties2KHR"));
  buf.underlyingType = "VkSparseImageFormatProperties2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSparseImageFormatInfo2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSparseImageFormatInfo2"));
  buf.underlyingType = "VkPhysicalDeviceSparseImageFormatInfo2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSparseImageFormatInfo2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSparseImageFormatInfo2KHR"));
  buf.underlyingType = "VkPhysicalDeviceSparseImageFormatInfo2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevicePushDescriptorPropertiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePushDescriptorPropertiesKHR"));
  buf.underlyingType = "VkPhysicalDevicePushDescriptorPropertiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkConformanceVersionArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkConformanceVersion"));
  buf.underlyingType = "VkConformanceVersion";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkConformanceVersionKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkConformanceVersionKHR"));
  buf.underlyingType = "VkConformanceVersionKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceDriverPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceDriverProperties"));
  buf.underlyingType = "VkPhysicalDeviceDriverProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceDriverPropertiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceDriverPropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceDriverPropertiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPresentRegionsKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPresentRegionsKHR"));
  buf.underlyingType = "VkPresentRegionsKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPresentRegionKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPresentRegionKHR"));
  buf.underlyingType = "VkPresentRegionKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRectLayerKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRectLayerKHR"));
  buf.underlyingType = "VkRectLayerKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceVariablePointersFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVariablePointersFeatures"));
  buf.underlyingType = "VkPhysicalDeviceVariablePointersFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceVariablePointersFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVariablePointersFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceVariablePointersFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceVariablePointerFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVariablePointerFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceVariablePointerFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceVariablePointerFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVariablePointerFeatures"));
  buf.underlyingType = "VkPhysicalDeviceVariablePointerFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkExternalMemoryPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkExternalMemoryProperties"));
  buf.underlyingType = "VkExternalMemoryProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceExternalImageFormatInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceExternalImageFormatInfo"));
  buf.underlyingType = "VkPhysicalDeviceExternalImageFormatInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkExternalImageFormatPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkExternalImageFormatProperties"));
  buf.underlyingType = "VkExternalImageFormatProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceExternalBufferInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceExternalBufferInfo"));
  buf.underlyingType = "VkPhysicalDeviceExternalBufferInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkExternalBufferPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkExternalBufferProperties"));
  buf.underlyingType = "VkExternalBufferProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceIDPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceIDProperties"));
  buf.underlyingType = "VkPhysicalDeviceIDProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkExternalMemoryImageCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkExternalMemoryImageCreateInfo"));
  buf.underlyingType = "VkExternalMemoryImageCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkExternalMemoryBufferCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkExternalMemoryBufferCreateInfo"));
  buf.underlyingType = "VkExternalMemoryBufferCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkExportMemoryAllocateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkExportMemoryAllocateInfo"));
  buf.underlyingType = "VkExportMemoryAllocateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceExternalSemaphoreInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceExternalSemaphoreInfo"));
  buf.underlyingType = "VkPhysicalDeviceExternalSemaphoreInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkExternalSemaphorePropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkExternalSemaphoreProperties"));
  buf.underlyingType = "VkExternalSemaphoreProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkExportSemaphoreCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkExportSemaphoreCreateInfo"));
  buf.underlyingType = "VkExportSemaphoreCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceExternalFenceInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceExternalFenceInfo"));
  buf.underlyingType = "VkPhysicalDeviceExternalFenceInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkExternalFencePropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkExternalFenceProperties"));
  buf.underlyingType = "VkExternalFenceProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkExportFenceCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkExportFenceCreateInfo"));
  buf.underlyingType = "VkExportFenceCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceMultiviewFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMultiviewFeatures"));
  buf.underlyingType = "VkPhysicalDeviceMultiviewFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceMultiviewFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMultiviewFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceMultiviewFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceMultiviewPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMultiviewProperties"));
  buf.underlyingType = "VkPhysicalDeviceMultiviewProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceMultiviewPropertiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMultiviewPropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceMultiviewPropertiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderPassMultiviewCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderPassMultiviewCreateInfo"));
  buf.underlyingType = "VkRenderPassMultiviewCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderPassMultiviewCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderPassMultiviewCreateInfoKHR"));
  buf.underlyingType = "VkRenderPassMultiviewCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceGroupPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceGroupProperties"));
  buf.underlyingType = "VkPhysicalDeviceGroupProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceGroupPropertiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceGroupPropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceGroupPropertiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMemoryAllocateFlagsInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMemoryAllocateFlagsInfo"));
  buf.underlyingType = "VkMemoryAllocateFlagsInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMemoryAllocateFlagsInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMemoryAllocateFlagsInfoKHR"));
  buf.underlyingType = "VkMemoryAllocateFlagsInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBindBufferMemoryInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBindBufferMemoryInfo"));
  buf.underlyingType = "VkBindBufferMemoryInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBindBufferMemoryInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBindBufferMemoryInfoKHR"));
  buf.underlyingType = "VkBindBufferMemoryInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBindBufferMemoryDeviceGroupInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBindBufferMemoryDeviceGroupInfo"));
  buf.underlyingType = "VkBindBufferMemoryDeviceGroupInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBindBufferMemoryDeviceGroupInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBindBufferMemoryDeviceGroupInfoKHR"));
  buf.underlyingType = "VkBindBufferMemoryDeviceGroupInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBindImageMemoryInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBindImageMemoryInfo"));
  buf.underlyingType = "VkBindImageMemoryInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBindImageMemoryInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBindImageMemoryInfoKHR"));
  buf.underlyingType = "VkBindImageMemoryInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBindImageMemoryDeviceGroupInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBindImageMemoryDeviceGroupInfo"));
  buf.underlyingType = "VkBindImageMemoryDeviceGroupInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBindImageMemoryDeviceGroupInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBindImageMemoryDeviceGroupInfoKHR"));
  buf.underlyingType = "VkBindImageMemoryDeviceGroupInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceGroupRenderPassBeginInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceGroupRenderPassBeginInfo"));
  buf.underlyingType = "VkDeviceGroupRenderPassBeginInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceGroupRenderPassBeginInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceGroupRenderPassBeginInfoKHR"));
  buf.underlyingType = "VkDeviceGroupRenderPassBeginInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceGroupCommandBufferBeginInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceGroupCommandBufferBeginInfo"));
  buf.underlyingType = "VkDeviceGroupCommandBufferBeginInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceGroupCommandBufferBeginInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceGroupCommandBufferBeginInfoKHR"));
  buf.underlyingType = "VkDeviceGroupCommandBufferBeginInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceGroupSubmitInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceGroupSubmitInfo"));
  buf.underlyingType = "VkDeviceGroupSubmitInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceGroupSubmitInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceGroupSubmitInfoKHR"));
  buf.underlyingType = "VkDeviceGroupSubmitInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceGroupBindSparseInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceGroupBindSparseInfo"));
  buf.underlyingType = "VkDeviceGroupBindSparseInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceGroupBindSparseInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceGroupBindSparseInfoKHR"));
  buf.underlyingType = "VkDeviceGroupBindSparseInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceGroupPresentCapabilitiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceGroupPresentCapabilitiesKHR"));
  buf.underlyingType = "VkDeviceGroupPresentCapabilitiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageSwapchainCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageSwapchainCreateInfoKHR"));
  buf.underlyingType = "VkImageSwapchainCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBindImageMemorySwapchainInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBindImageMemorySwapchainInfoKHR"));
  buf.underlyingType = "VkBindImageMemorySwapchainInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkAcquireNextImageInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkAcquireNextImageInfoKHR"));
  buf.underlyingType = "VkAcquireNextImageInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceGroupPresentInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceGroupPresentInfoKHR"));
  buf.underlyingType = "VkDeviceGroupPresentInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceGroupDeviceCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceGroupDeviceCreateInfo"));
  buf.underlyingType = "VkDeviceGroupDeviceCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceGroupDeviceCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceGroupDeviceCreateInfoKHR"));
  buf.underlyingType = "VkDeviceGroupDeviceCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceGroupSwapchainCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceGroupSwapchainCreateInfoKHR"));
  buf.underlyingType = "VkDeviceGroupSwapchainCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDescriptorUpdateTemplateEntryArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDescriptorUpdateTemplateEntry"));
  buf.underlyingType = "VkDescriptorUpdateTemplateEntry";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDescriptorUpdateTemplateEntryKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDescriptorUpdateTemplateEntryKHR"));
  buf.underlyingType = "VkDescriptorUpdateTemplateEntryKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDescriptorUpdateTemplateCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDescriptorUpdateTemplateCreateInfo"));
  buf.underlyingType = "VkDescriptorUpdateTemplateCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDescriptorUpdateTemplateCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDescriptorUpdateTemplateCreateInfoKHR"));
  buf.underlyingType = "VkDescriptorUpdateTemplateCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkXYColorEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkXYColorEXT"));
  buf.underlyingType = "VkXYColorEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevicePresentIdFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePresentIdFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDevicePresentIdFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPresentIdKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPresentIdKHR"));
  buf.underlyingType = "VkPresentIdKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevicePresentWaitFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePresentWaitFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDevicePresentWaitFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkHdrMetadataEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkHdrMetadataEXT"));
  buf.underlyingType = "VkHdrMetadataEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkInputAttachmentAspectReferenceArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkInputAttachmentAspectReference"));
  buf.underlyingType = "VkInputAttachmentAspectReference";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderPassInputAttachmentAspectCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderPassInputAttachmentAspectCreateInfo"));
  buf.underlyingType = "VkRenderPassInputAttachmentAspectCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSurfaceInfo2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSurfaceInfo2KHR"));
  buf.underlyingType = "VkPhysicalDeviceSurfaceInfo2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSurfaceCapabilities2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSurfaceCapabilities2KHR"));
  buf.underlyingType = "VkSurfaceCapabilities2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSurfaceFormat2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSurfaceFormat2KHR"));
  buf.underlyingType = "VkSurfaceFormat2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDisplayProperties2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDisplayProperties2KHR"));
  buf.underlyingType = "VkDisplayProperties2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDisplayPlaneProperties2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDisplayPlaneProperties2KHR"));
  buf.underlyingType = "VkDisplayPlaneProperties2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDisplayModeProperties2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDisplayModeProperties2KHR"));
  buf.underlyingType = "VkDisplayModeProperties2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDisplayPlaneInfo2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDisplayPlaneInfo2KHR"));
  buf.underlyingType = "VkDisplayPlaneInfo2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDisplayPlaneCapabilities2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDisplayPlaneCapabilities2KHR"));
  buf.underlyingType = "VkDisplayPlaneCapabilities2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSharedPresentSurfaceCapabilitiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSharedPresentSurfaceCapabilitiesKHR"));
  buf.underlyingType = "VkSharedPresentSurfaceCapabilitiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevice16BitStorageFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevice16BitStorageFeatures"));
  buf.underlyingType = "VkPhysicalDevice16BitStorageFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevice16BitStorageFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevice16BitStorageFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDevice16BitStorageFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSubgroupPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSubgroupProperties"));
  buf.underlyingType = "VkPhysicalDeviceSubgroupProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures"));
  buf.underlyingType = "VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBufferMemoryRequirementsInfo2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBufferMemoryRequirementsInfo2"));
  buf.underlyingType = "VkBufferMemoryRequirementsInfo2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBufferMemoryRequirementsInfo2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBufferMemoryRequirementsInfo2KHR"));
  buf.underlyingType = "VkBufferMemoryRequirementsInfo2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceBufferMemoryRequirementsArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceBufferMemoryRequirements"));
  buf.underlyingType = "VkDeviceBufferMemoryRequirements";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageMemoryRequirementsInfo2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageMemoryRequirementsInfo2"));
  buf.underlyingType = "VkImageMemoryRequirementsInfo2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageMemoryRequirementsInfo2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageMemoryRequirementsInfo2KHR"));
  buf.underlyingType = "VkImageMemoryRequirementsInfo2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageSparseMemoryRequirementsInfo2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageSparseMemoryRequirementsInfo2"));
  buf.underlyingType = "VkImageSparseMemoryRequirementsInfo2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageSparseMemoryRequirementsInfo2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageSparseMemoryRequirementsInfo2KHR"));
  buf.underlyingType = "VkImageSparseMemoryRequirementsInfo2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceImageMemoryRequirementsArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceImageMemoryRequirements"));
  buf.underlyingType = "VkDeviceImageMemoryRequirements";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMemoryRequirements2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMemoryRequirements2"));
  buf.underlyingType = "VkMemoryRequirements2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSparseImageMemoryRequirements2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSparseImageMemoryRequirements2"));
  buf.underlyingType = "VkSparseImageMemoryRequirements2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSparseImageMemoryRequirements2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSparseImageMemoryRequirements2KHR"));
  buf.underlyingType = "VkSparseImageMemoryRequirements2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevicePointClippingPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePointClippingProperties"));
  buf.underlyingType = "VkPhysicalDevicePointClippingProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMemoryDedicatedRequirementsArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMemoryDedicatedRequirements"));
  buf.underlyingType = "VkMemoryDedicatedRequirements";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMemoryDedicatedRequirementsKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMemoryDedicatedRequirementsKHR"));
  buf.underlyingType = "VkMemoryDedicatedRequirementsKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMemoryDedicatedAllocateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMemoryDedicatedAllocateInfo"));
  buf.underlyingType = "VkMemoryDedicatedAllocateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMemoryDedicatedAllocateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMemoryDedicatedAllocateInfoKHR"));
  buf.underlyingType = "VkMemoryDedicatedAllocateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageViewUsageCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageViewUsageCreateInfo"));
  buf.underlyingType = "VkImageViewUsageCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineTessellationDomainOriginStateCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineTessellationDomainOriginStateCreateInfo"));
  buf.underlyingType = "VkPipelineTessellationDomainOriginStateCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSamplerYcbcrConversionInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSamplerYcbcrConversionInfo"));
  buf.underlyingType = "VkSamplerYcbcrConversionInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSamplerYcbcrConversionInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSamplerYcbcrConversionInfoKHR"));
  buf.underlyingType = "VkSamplerYcbcrConversionInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSamplerYcbcrConversionCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSamplerYcbcrConversionCreateInfo"));
  buf.underlyingType = "VkSamplerYcbcrConversionCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSamplerYcbcrConversionCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSamplerYcbcrConversionCreateInfoKHR"));
  buf.underlyingType = "VkSamplerYcbcrConversionCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBindImagePlaneMemoryInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBindImagePlaneMemoryInfo"));
  buf.underlyingType = "VkBindImagePlaneMemoryInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBindImagePlaneMemoryInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBindImagePlaneMemoryInfoKHR"));
  buf.underlyingType = "VkBindImagePlaneMemoryInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImagePlaneMemoryRequirementsInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImagePlaneMemoryRequirementsInfo"));
  buf.underlyingType = "VkImagePlaneMemoryRequirementsInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImagePlaneMemoryRequirementsInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImagePlaneMemoryRequirementsInfoKHR"));
  buf.underlyingType = "VkImagePlaneMemoryRequirementsInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSamplerYcbcrConversionFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSamplerYcbcrConversionFeatures"));
  buf.underlyingType = "VkPhysicalDeviceSamplerYcbcrConversionFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSamplerYcbcrConversionFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSamplerYcbcrConversionImageFormatPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSamplerYcbcrConversionImageFormatProperties"));
  buf.underlyingType = "VkSamplerYcbcrConversionImageFormatProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSamplerYcbcrConversionImageFormatPropertiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSamplerYcbcrConversionImageFormatPropertiesKHR"));
  buf.underlyingType = "VkSamplerYcbcrConversionImageFormatPropertiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkProtectedSubmitInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkProtectedSubmitInfo"));
  buf.underlyingType = "VkProtectedSubmitInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceProtectedMemoryFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceProtectedMemoryFeatures"));
  buf.underlyingType = "VkPhysicalDeviceProtectedMemoryFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceProtectedMemoryPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceProtectedMemoryProperties"));
  buf.underlyingType = "VkPhysicalDeviceProtectedMemoryProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceQueueInfo2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceQueueInfo2"));
  buf.underlyingType = "VkDeviceQueueInfo2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSamplerFilterMinmaxPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSamplerFilterMinmaxProperties"));
  buf.underlyingType = "VkPhysicalDeviceSamplerFilterMinmaxProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSamplerFilterMinmaxPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSampleLocationEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSampleLocationEXT"));
  buf.underlyingType = "VkSampleLocationEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSampleLocationsInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSampleLocationsInfoEXT"));
  buf.underlyingType = "VkSampleLocationsInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkAttachmentSampleLocationsEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkAttachmentSampleLocationsEXT"));
  buf.underlyingType = "VkAttachmentSampleLocationsEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSubpassSampleLocationsEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSubpassSampleLocationsEXT"));
  buf.underlyingType = "VkSubpassSampleLocationsEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderPassSampleLocationsBeginInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderPassSampleLocationsBeginInfoEXT"));
  buf.underlyingType = "VkRenderPassSampleLocationsBeginInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineSampleLocationsStateCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineSampleLocationsStateCreateInfoEXT"));
  buf.underlyingType = "VkPipelineSampleLocationsStateCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSampleLocationsPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSampleLocationsPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceSampleLocationsPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMultisamplePropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMultisamplePropertiesEXT"));
  buf.underlyingType = "VkMultisamplePropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSamplerReductionModeCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSamplerReductionModeCreateInfo"));
  buf.underlyingType = "VkSamplerReductionModeCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSamplerReductionModeCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSamplerReductionModeCreateInfoEXT"));
  buf.underlyingType = "VkSamplerReductionModeCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceMultiDrawFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMultiDrawFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceMultiDrawFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceInlineUniformBlockFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceInlineUniformBlockFeatures"));
  buf.underlyingType = "VkPhysicalDeviceInlineUniformBlockFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceInlineUniformBlockFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceInlineUniformBlockFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceInlineUniformBlockFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceInlineUniformBlockPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceInlineUniformBlockProperties"));
  buf.underlyingType = "VkPhysicalDeviceInlineUniformBlockProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceInlineUniformBlockPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceInlineUniformBlockPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceInlineUniformBlockPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkWriteDescriptorSetInlineUniformBlockArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkWriteDescriptorSetInlineUniformBlock"));
  buf.underlyingType = "VkWriteDescriptorSetInlineUniformBlock";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkWriteDescriptorSetInlineUniformBlockEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkWriteDescriptorSetInlineUniformBlockEXT"));
  buf.underlyingType = "VkWriteDescriptorSetInlineUniformBlockEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDescriptorPoolInlineUniformBlockCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDescriptorPoolInlineUniformBlockCreateInfo"));
  buf.underlyingType = "VkDescriptorPoolInlineUniformBlockCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDescriptorPoolInlineUniformBlockCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDescriptorPoolInlineUniformBlockCreateInfoEXT"));
  buf.underlyingType = "VkDescriptorPoolInlineUniformBlockCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageFormatListCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageFormatListCreateInfo"));
  buf.underlyingType = "VkImageFormatListCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageFormatListCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageFormatListCreateInfoKHR"));
  buf.underlyingType = "VkImageFormatListCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkValidationCacheCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkValidationCacheCreateInfoEXT"));
  buf.underlyingType = "VkValidationCacheCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkShaderModuleValidationCacheCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkShaderModuleValidationCacheCreateInfoEXT"));
  buf.underlyingType = "VkShaderModuleValidationCacheCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceMaintenance3PropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMaintenance3Properties"));
  buf.underlyingType = "VkPhysicalDeviceMaintenance3Properties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceMaintenance4FeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMaintenance4Features"));
  buf.underlyingType = "VkPhysicalDeviceMaintenance4Features";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceMaintenance4PropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMaintenance4Properties"));
  buf.underlyingType = "VkPhysicalDeviceMaintenance4Properties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDescriptorSetLayoutSupportArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDescriptorSetLayoutSupport"));
  buf.underlyingType = "VkDescriptorSetLayoutSupport";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderDrawParametersFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderDrawParametersFeatures"));
  buf.underlyingType = "VkPhysicalDeviceShaderDrawParametersFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderDrawParameterFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderDrawParameterFeatures"));
  buf.underlyingType = "VkPhysicalDeviceShaderDrawParameterFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderFloat16Int8FeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderFloat16Int8Features"));
  buf.underlyingType = "VkPhysicalDeviceShaderFloat16Int8Features";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderFloat16Int8FeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderFloat16Int8FeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceShaderFloat16Int8FeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceFloat16Int8FeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFloat16Int8FeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceFloat16Int8FeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceFloatControlsPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFloatControlsProperties"));
  buf.underlyingType = "VkPhysicalDeviceFloatControlsProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceFloatControlsPropertiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFloatControlsPropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceFloatControlsPropertiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceHostQueryResetFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceHostQueryResetFeatures"));
  buf.underlyingType = "VkPhysicalDeviceHostQueryResetFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceHostQueryResetFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceHostQueryResetFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceHostQueryResetFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceQueueGlobalPriorityCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceQueueGlobalPriorityCreateInfoKHR"));
  buf.underlyingType = "VkDeviceQueueGlobalPriorityCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceQueueGlobalPriorityCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceQueueGlobalPriorityCreateInfoEXT"));
  buf.underlyingType = "VkDeviceQueueGlobalPriorityCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceGlobalPriorityQueryFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceGlobalPriorityQueryFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkQueueFamilyGlobalPriorityPropertiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkQueueFamilyGlobalPriorityPropertiesKHR"));
  buf.underlyingType = "VkQueueFamilyGlobalPriorityPropertiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkQueueFamilyGlobalPriorityPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkQueueFamilyGlobalPriorityPropertiesEXT"));
  buf.underlyingType = "VkQueueFamilyGlobalPriorityPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImportMemoryHostPointerInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImportMemoryHostPointerInfoEXT"));
  buf.underlyingType = "VkImportMemoryHostPointerInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMemoryHostPointerPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMemoryHostPointerPropertiesEXT"));
  buf.underlyingType = "VkMemoryHostPointerPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceExternalMemoryHostPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceExternalMemoryHostPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceExternalMemoryHostPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceDescriptorIndexingFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceDescriptorIndexingFeatures"));
  buf.underlyingType = "VkPhysicalDeviceDescriptorIndexingFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceDescriptorIndexingPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceDescriptorIndexingProperties"));
  buf.underlyingType = "VkPhysicalDeviceDescriptorIndexingProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDescriptorSetLayoutBindingFlagsCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDescriptorSetLayoutBindingFlagsCreateInfo"));
  buf.underlyingType = "VkDescriptorSetLayoutBindingFlagsCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDescriptorSetVariableDescriptorCountAllocateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDescriptorSetVariableDescriptorCountAllocateInfo"));
  buf.underlyingType = "VkDescriptorSetVariableDescriptorCountAllocateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDescriptorSetVariableDescriptorCountLayoutSupportArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDescriptorSetVariableDescriptorCountLayoutSupport"));
  buf.underlyingType = "VkDescriptorSetVariableDescriptorCountLayoutSupport";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkAttachmentDescription2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkAttachmentDescription2"));
  buf.underlyingType = "VkAttachmentDescription2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkAttachmentDescription2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkAttachmentDescription2KHR"));
  buf.underlyingType = "VkAttachmentDescription2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkAttachmentReference2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkAttachmentReference2"));
  buf.underlyingType = "VkAttachmentReference2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkAttachmentReference2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkAttachmentReference2KHR"));
  buf.underlyingType = "VkAttachmentReference2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSubpassDescription2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSubpassDescription2"));
  buf.underlyingType = "VkSubpassDescription2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSubpassDescription2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSubpassDescription2KHR"));
  buf.underlyingType = "VkSubpassDescription2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSubpassDependency2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSubpassDependency2"));
  buf.underlyingType = "VkSubpassDependency2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSubpassDependency2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSubpassDependency2KHR"));
  buf.underlyingType = "VkSubpassDependency2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderPassCreateInfo2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderPassCreateInfo2"));
  buf.underlyingType = "VkRenderPassCreateInfo2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderPassCreateInfo2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderPassCreateInfo2KHR"));
  buf.underlyingType = "VkRenderPassCreateInfo2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSubpassBeginInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSubpassBeginInfo"));
  buf.underlyingType = "VkSubpassBeginInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSubpassBeginInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSubpassBeginInfoKHR"));
  buf.underlyingType = "VkSubpassBeginInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSubpassEndInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSubpassEndInfo"));
  buf.underlyingType = "VkSubpassEndInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSubpassEndInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSubpassEndInfoKHR"));
  buf.underlyingType = "VkSubpassEndInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceTimelineSemaphoreFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTimelineSemaphoreFeatures"));
  buf.underlyingType = "VkPhysicalDeviceTimelineSemaphoreFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceTimelineSemaphoreFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTimelineSemaphoreFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceTimelineSemaphoreFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceTimelineSemaphorePropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTimelineSemaphoreProperties"));
  buf.underlyingType = "VkPhysicalDeviceTimelineSemaphoreProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceTimelineSemaphorePropertiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTimelineSemaphorePropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceTimelineSemaphorePropertiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSemaphoreTypeCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSemaphoreTypeCreateInfo"));
  buf.underlyingType = "VkSemaphoreTypeCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSemaphoreTypeCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSemaphoreTypeCreateInfoKHR"));
  buf.underlyingType = "VkSemaphoreTypeCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkTimelineSemaphoreSubmitInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkTimelineSemaphoreSubmitInfo"));
  buf.underlyingType = "VkTimelineSemaphoreSubmitInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkTimelineSemaphoreSubmitInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkTimelineSemaphoreSubmitInfoKHR"));
  buf.underlyingType = "VkTimelineSemaphoreSubmitInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSemaphoreWaitInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSemaphoreWaitInfo"));
  buf.underlyingType = "VkSemaphoreWaitInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSemaphoreWaitInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSemaphoreWaitInfoKHR"));
  buf.underlyingType = "VkSemaphoreWaitInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSemaphoreSignalInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSemaphoreSignalInfo"));
  buf.underlyingType = "VkSemaphoreSignalInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSemaphoreSignalInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSemaphoreSignalInfoKHR"));
  buf.underlyingType = "VkSemaphoreSignalInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkVertexInputBindingDivisorDescriptionEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkVertexInputBindingDivisorDescriptionEXT"));
  buf.underlyingType = "VkVertexInputBindingDivisorDescriptionEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineVertexInputDivisorStateCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineVertexInputDivisorStateCreateInfoEXT"));
  buf.underlyingType = "VkPipelineVertexInputDivisorStateCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceVertexAttributeDivisorPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevicePCIBusInfoPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePCIBusInfoPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDevicePCIBusInfoPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevice8BitStorageFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevice8BitStorageFeatures"));
  buf.underlyingType = "VkPhysicalDevice8BitStorageFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevice8BitStorageFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevice8BitStorageFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDevice8BitStorageFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceVulkanMemoryModelFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVulkanMemoryModelFeatures"));
  buf.underlyingType = "VkPhysicalDeviceVulkanMemoryModelFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceVulkanMemoryModelFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVulkanMemoryModelFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceVulkanMemoryModelFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderAtomicInt64FeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderAtomicInt64Features"));
  buf.underlyingType = "VkPhysicalDeviceShaderAtomicInt64Features";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderAtomicInt64FeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderAtomicInt64FeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceShaderAtomicInt64FeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderAtomicFloatFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderAtomicFloatFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceShaderAtomicFloatFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderAtomicFloat2FeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceVertexAttributeDivisorFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceDepthStencilResolvePropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceDepthStencilResolveProperties"));
  buf.underlyingType = "VkPhysicalDeviceDepthStencilResolveProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceDepthStencilResolvePropertiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceDepthStencilResolvePropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceDepthStencilResolvePropertiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSubpassDescriptionDepthStencilResolveArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSubpassDescriptionDepthStencilResolve"));
  buf.underlyingType = "VkSubpassDescriptionDepthStencilResolve";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSubpassDescriptionDepthStencilResolveKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSubpassDescriptionDepthStencilResolveKHR"));
  buf.underlyingType = "VkSubpassDescriptionDepthStencilResolveKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceTransformFeedbackFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTransformFeedbackFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceTransformFeedbackFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceTransformFeedbackPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTransformFeedbackPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceTransformFeedbackPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineRasterizationStateStreamCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineRasterizationStateStreamCreateInfoEXT"));
  buf.underlyingType = "VkPipelineRasterizationStateStreamCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceMeshShaderFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMeshShaderFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceMeshShaderFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceMeshShaderPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMeshShaderPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceMeshShaderPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDrawMeshTasksIndirectCommandEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDrawMeshTasksIndirectCommandEXT"));
  buf.underlyingType = "VkDrawMeshTasksIndirectCommandEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRayTracingShaderGroupCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRayTracingShaderGroupCreateInfoKHR"));
  buf.underlyingType = "VkRayTracingShaderGroupCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRayTracingPipelineCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRayTracingPipelineCreateInfoKHR"));
  buf.underlyingType = "VkRayTracingPipelineCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceRayTracingPipelineFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceRayTracingPipelineFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceRayTracingPipelineFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceRayQueryFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceRayQueryFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceRayQueryFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceRayTracingPipelinePropertiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceRayTracingPipelinePropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceRayTracingPipelinePropertiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkStridedDeviceAddressRegionKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkStridedDeviceAddressRegionKHR"));
  buf.underlyingType = "VkStridedDeviceAddressRegionKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkTraceRaysIndirectCommandKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkTraceRaysIndirectCommandKHR"));
  buf.underlyingType = "VkTraceRaysIndirectCommandKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkTraceRaysIndirectCommand2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkTraceRaysIndirectCommand2KHR"));
  buf.underlyingType = "VkTraceRaysIndirectCommand2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceRayTracingMaintenance1FeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDrmFormatModifierPropertiesListEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDrmFormatModifierPropertiesListEXT"));
  buf.underlyingType = "VkDrmFormatModifierPropertiesListEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDrmFormatModifierPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDrmFormatModifierPropertiesEXT"));
  buf.underlyingType = "VkDrmFormatModifierPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceImageDrmFormatModifierInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImageDrmFormatModifierInfoEXT"));
  buf.underlyingType = "VkPhysicalDeviceImageDrmFormatModifierInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageDrmFormatModifierListCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageDrmFormatModifierListCreateInfoEXT"));
  buf.underlyingType = "VkImageDrmFormatModifierListCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageDrmFormatModifierExplicitCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageDrmFormatModifierExplicitCreateInfoEXT"));
  buf.underlyingType = "VkImageDrmFormatModifierExplicitCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageDrmFormatModifierPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageDrmFormatModifierPropertiesEXT"));
  buf.underlyingType = "VkImageDrmFormatModifierPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageStencilUsageCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageStencilUsageCreateInfo"));
  buf.underlyingType = "VkImageStencilUsageCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageStencilUsageCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageStencilUsageCreateInfoEXT"));
  buf.underlyingType = "VkImageStencilUsageCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceFragmentDensityMapFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentDensityMapFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceFragmentDensityMapFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceFragmentDensityMap2FeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentDensityMap2FeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceFragmentDensityMap2FeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceFragmentDensityMapPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentDensityMapPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceFragmentDensityMapPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceFragmentDensityMap2PropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentDensityMap2PropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceFragmentDensityMap2PropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderPassFragmentDensityMapCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderPassFragmentDensityMapCreateInfoEXT"));
  buf.underlyingType = "VkRenderPassFragmentDensityMapCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceScalarBlockLayoutFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceScalarBlockLayoutFeatures"));
  buf.underlyingType = "VkPhysicalDeviceScalarBlockLayoutFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceScalarBlockLayoutFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceScalarBlockLayoutFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceScalarBlockLayoutFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSurfaceProtectedCapabilitiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSurfaceProtectedCapabilitiesKHR"));
  buf.underlyingType = "VkSurfaceProtectedCapabilitiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceUniformBufferStandardLayoutFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceUniformBufferStandardLayoutFeatures"));
  buf.underlyingType = "VkPhysicalDeviceUniformBufferStandardLayoutFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceMemoryBudgetPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMemoryBudgetPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceMemoryBudgetPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceMemoryPriorityFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMemoryPriorityFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceMemoryPriorityFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMemoryPriorityAllocateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMemoryPriorityAllocateInfoEXT"));
  buf.underlyingType = "VkMemoryPriorityAllocateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceBufferDeviceAddressFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceBufferDeviceAddressFeatures"));
  buf.underlyingType = "VkPhysicalDeviceBufferDeviceAddressFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceBufferDeviceAddressFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceBufferDeviceAddressFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceBufferDeviceAddressFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBufferDeviceAddressInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBufferDeviceAddressInfo"));
  buf.underlyingType = "VkBufferDeviceAddressInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBufferDeviceAddressInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBufferDeviceAddressInfoKHR"));
  buf.underlyingType = "VkBufferDeviceAddressInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBufferOpaqueCaptureAddressCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBufferOpaqueCaptureAddressCreateInfo"));
  buf.underlyingType = "VkBufferOpaqueCaptureAddressCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBufferOpaqueCaptureAddressCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBufferOpaqueCaptureAddressCreateInfoKHR"));
  buf.underlyingType = "VkBufferOpaqueCaptureAddressCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceImageViewImageFormatInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImageViewImageFormatInfoEXT"));
  buf.underlyingType = "VkPhysicalDeviceImageViewImageFormatInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkFilterCubicImageViewImageFormatPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkFilterCubicImageViewImageFormatPropertiesEXT"));
  buf.underlyingType = "VkFilterCubicImageViewImageFormatPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceImagelessFramebufferFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImagelessFramebufferFeatures"));
  buf.underlyingType = "VkPhysicalDeviceImagelessFramebufferFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceImagelessFramebufferFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImagelessFramebufferFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceImagelessFramebufferFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkFramebufferAttachmentsCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkFramebufferAttachmentsCreateInfo"));
  buf.underlyingType = "VkFramebufferAttachmentsCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkFramebufferAttachmentsCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkFramebufferAttachmentsCreateInfoKHR"));
  buf.underlyingType = "VkFramebufferAttachmentsCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkFramebufferAttachmentImageInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkFramebufferAttachmentImageInfo"));
  buf.underlyingType = "VkFramebufferAttachmentImageInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkFramebufferAttachmentImageInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkFramebufferAttachmentImageInfoKHR"));
  buf.underlyingType = "VkFramebufferAttachmentImageInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderPassAttachmentBeginInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderPassAttachmentBeginInfo"));
  buf.underlyingType = "VkRenderPassAttachmentBeginInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderPassAttachmentBeginInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderPassAttachmentBeginInfoKHR"));
  buf.underlyingType = "VkRenderPassAttachmentBeginInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceTextureCompressionASTCHDRFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTextureCompressionASTCHDRFeatures"));
  buf.underlyingType = "VkPhysicalDeviceTextureCompressionASTCHDRFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceYcbcrImageArraysFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceYcbcrImageArraysFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceYcbcrImageArraysFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineCreationFeedbackArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineCreationFeedback"));
  buf.underlyingType = "VkPipelineCreationFeedback";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineCreationFeedbackEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineCreationFeedbackEXT"));
  buf.underlyingType = "VkPipelineCreationFeedbackEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineCreationFeedbackCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineCreationFeedbackCreateInfo"));
  buf.underlyingType = "VkPipelineCreationFeedbackCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineCreationFeedbackCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineCreationFeedbackCreateInfoEXT"));
  buf.underlyingType = "VkPipelineCreationFeedbackCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkHeadlessSurfaceCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkHeadlessSurfaceCreateInfoEXT"));
  buf.underlyingType = "VkHeadlessSurfaceCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderClockFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderClockFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceShaderClockFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceIndexTypeUint8FeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceIndexTypeUint8FeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceIndexTypeUint8FeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceFragmentShaderInterlockFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures"));
  buf.underlyingType = "VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkAttachmentReferenceStencilLayoutArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkAttachmentReferenceStencilLayout"));
  buf.underlyingType = "VkAttachmentReferenceStencilLayout";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkAttachmentReferenceStencilLayoutKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkAttachmentReferenceStencilLayoutKHR"));
  buf.underlyingType = "VkAttachmentReferenceStencilLayoutKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkAttachmentDescriptionStencilLayoutArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkAttachmentDescriptionStencilLayout"));
  buf.underlyingType = "VkAttachmentDescriptionStencilLayout";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkAttachmentDescriptionStencilLayoutKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkAttachmentDescriptionStencilLayoutKHR"));
  buf.underlyingType = "VkAttachmentDescriptionStencilLayoutKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineInfoEXT"));
  buf.underlyingType = "VkPipelineInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures"));
  buf.underlyingType = "VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceTexelBufferAlignmentFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceTexelBufferAlignmentPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTexelBufferAlignmentProperties"));
  buf.underlyingType = "VkPhysicalDeviceTexelBufferAlignmentProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceTexelBufferAlignmentPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSubgroupSizeControlFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSubgroupSizeControlFeatures"));
  buf.underlyingType = "VkPhysicalDeviceSubgroupSizeControlFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSubgroupSizeControlFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSubgroupSizeControlFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceSubgroupSizeControlFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSubgroupSizeControlPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSubgroupSizeControlProperties"));
  buf.underlyingType = "VkPhysicalDeviceSubgroupSizeControlProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSubgroupSizeControlPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSubgroupSizeControlPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceSubgroupSizeControlPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT"));
  buf.underlyingType = "VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMemoryOpaqueCaptureAddressAllocateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMemoryOpaqueCaptureAddressAllocateInfo"));
  buf.underlyingType = "VkMemoryOpaqueCaptureAddressAllocateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMemoryOpaqueCaptureAddressAllocateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMemoryOpaqueCaptureAddressAllocateInfoKHR"));
  buf.underlyingType = "VkMemoryOpaqueCaptureAddressAllocateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceMemoryOpaqueCaptureAddressInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceMemoryOpaqueCaptureAddressInfo"));
  buf.underlyingType = "VkDeviceMemoryOpaqueCaptureAddressInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDeviceMemoryOpaqueCaptureAddressInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDeviceMemoryOpaqueCaptureAddressInfoKHR"));
  buf.underlyingType = "VkDeviceMemoryOpaqueCaptureAddressInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceLineRasterizationFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceLineRasterizationFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceLineRasterizationFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceLineRasterizationPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceLineRasterizationPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceLineRasterizationPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineRasterizationLineStateCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineRasterizationLineStateCreateInfoEXT"));
  buf.underlyingType = "VkPipelineRasterizationLineStateCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevicePipelineCreationCacheControlFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePipelineCreationCacheControlFeatures"));
  buf.underlyingType = "VkPhysicalDevicePipelineCreationCacheControlFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevicePipelineCreationCacheControlFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceVulkan11FeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVulkan11Features"));
  buf.underlyingType = "VkPhysicalDeviceVulkan11Features";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceVulkan11PropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVulkan11Properties"));
  buf.underlyingType = "VkPhysicalDeviceVulkan11Properties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceVulkan12FeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVulkan12Features"));
  buf.underlyingType = "VkPhysicalDeviceVulkan12Features";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceVulkan12PropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVulkan12Properties"));
  buf.underlyingType = "VkPhysicalDeviceVulkan12Properties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceVulkan13FeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVulkan13Features"));
  buf.underlyingType = "VkPhysicalDeviceVulkan13Features";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceVulkan13PropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVulkan13Properties"));
  buf.underlyingType = "VkPhysicalDeviceVulkan13Properties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceToolPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceToolProperties"));
  buf.underlyingType = "VkPhysicalDeviceToolProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceToolPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceToolPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceToolPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRayTracingPipelineInterfaceCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRayTracingPipelineInterfaceCreateInfoKHR"));
  buf.underlyingType = "VkRayTracingPipelineInterfaceCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineLibraryCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineLibraryCreateInfoKHR"));
  buf.underlyingType = "VkPipelineLibraryCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures"));
  buf.underlyingType = "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceRobustness2FeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceRobustness2FeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceRobustness2FeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceRobustness2PropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceRobustness2PropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceRobustness2PropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceImageRobustnessFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImageRobustnessFeatures"));
  buf.underlyingType = "VkPhysicalDeviceImageRobustnessFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceImageRobustnessFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImageRobustnessFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceImageRobustnessFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBufferCopy2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBufferCopy2"));
  buf.underlyingType = "VkBufferCopy2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBufferCopy2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBufferCopy2KHR"));
  buf.underlyingType = "VkBufferCopy2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageCopy2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageCopy2"));
  buf.underlyingType = "VkImageCopy2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageCopy2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageCopy2KHR"));
  buf.underlyingType = "VkImageCopy2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageBlit2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageBlit2"));
  buf.underlyingType = "VkImageBlit2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageBlit2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageBlit2KHR"));
  buf.underlyingType = "VkImageBlit2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBufferImageCopy2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBufferImageCopy2"));
  buf.underlyingType = "VkBufferImageCopy2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBufferImageCopy2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBufferImageCopy2KHR"));
  buf.underlyingType = "VkBufferImageCopy2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageResolve2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageResolve2"));
  buf.underlyingType = "VkImageResolve2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageResolve2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageResolve2KHR"));
  buf.underlyingType = "VkImageResolve2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkCopyBufferInfo2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkCopyBufferInfo2"));
  buf.underlyingType = "VkCopyBufferInfo2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkCopyBufferInfo2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkCopyBufferInfo2KHR"));
  buf.underlyingType = "VkCopyBufferInfo2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkCopyImageInfo2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkCopyImageInfo2"));
  buf.underlyingType = "VkCopyImageInfo2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkCopyImageInfo2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkCopyImageInfo2KHR"));
  buf.underlyingType = "VkCopyImageInfo2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBlitImageInfo2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBlitImageInfo2"));
  buf.underlyingType = "VkBlitImageInfo2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBlitImageInfo2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBlitImageInfo2KHR"));
  buf.underlyingType = "VkBlitImageInfo2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkCopyBufferToImageInfo2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkCopyBufferToImageInfo2"));
  buf.underlyingType = "VkCopyBufferToImageInfo2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkCopyBufferToImageInfo2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkCopyBufferToImageInfo2KHR"));
  buf.underlyingType = "VkCopyBufferToImageInfo2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkCopyImageToBufferInfo2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkCopyImageToBufferInfo2"));
  buf.underlyingType = "VkCopyImageToBufferInfo2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkCopyImageToBufferInfo2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkCopyImageToBufferInfo2KHR"));
  buf.underlyingType = "VkCopyImageToBufferInfo2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkResolveImageInfo2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkResolveImageInfo2"));
  buf.underlyingType = "VkResolveImageInfo2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkResolveImageInfo2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkResolveImageInfo2KHR"));
  buf.underlyingType = "VkResolveImageInfo2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderImageAtomicInt64FeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkFragmentShadingRateAttachmentInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkFragmentShadingRateAttachmentInfoKHR"));
  buf.underlyingType = "VkFragmentShadingRateAttachmentInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineFragmentShadingRateStateCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineFragmentShadingRateStateCreateInfoKHR"));
  buf.underlyingType = "VkPipelineFragmentShadingRateStateCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceFragmentShadingRateFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentShadingRateFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceFragmentShadingRateFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceFragmentShadingRatePropertiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentShadingRatePropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceFragmentShadingRatePropertiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceFragmentShadingRateKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentShadingRateKHR"));
  buf.underlyingType = "VkPhysicalDeviceFragmentShadingRateKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderTerminateInvocationFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderTerminateInvocationFeatures"));
  buf.underlyingType = "VkPhysicalDeviceShaderTerminateInvocationFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderTerminateInvocationFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceImage2DViewOf3DFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImage2DViewOf3DFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceImage2DViewOf3DFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceMutableDescriptorTypeFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMutableDescriptorTypeListEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMutableDescriptorTypeListEXT"));
  buf.underlyingType = "VkMutableDescriptorTypeListEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMutableDescriptorTypeCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMutableDescriptorTypeCreateInfoEXT"));
  buf.underlyingType = "VkMutableDescriptorTypeCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceVertexInputDynamicStateFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMemoryBarrier2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMemoryBarrier2"));
  buf.underlyingType = "VkMemoryBarrier2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMemoryBarrier2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMemoryBarrier2KHR"));
  buf.underlyingType = "VkMemoryBarrier2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageMemoryBarrier2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageMemoryBarrier2"));
  buf.underlyingType = "VkImageMemoryBarrier2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageMemoryBarrier2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageMemoryBarrier2KHR"));
  buf.underlyingType = "VkImageMemoryBarrier2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBufferMemoryBarrier2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBufferMemoryBarrier2"));
  buf.underlyingType = "VkBufferMemoryBarrier2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBufferMemoryBarrier2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBufferMemoryBarrier2KHR"));
  buf.underlyingType = "VkBufferMemoryBarrier2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDependencyInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDependencyInfo"));
  buf.underlyingType = "VkDependencyInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDependencyInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDependencyInfoKHR"));
  buf.underlyingType = "VkDependencyInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSemaphoreSubmitInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSemaphoreSubmitInfo"));
  buf.underlyingType = "VkSemaphoreSubmitInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSemaphoreSubmitInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSemaphoreSubmitInfoKHR"));
  buf.underlyingType = "VkSemaphoreSubmitInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkCommandBufferSubmitInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkCommandBufferSubmitInfo"));
  buf.underlyingType = "VkCommandBufferSubmitInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkCommandBufferSubmitInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkCommandBufferSubmitInfoKHR"));
  buf.underlyingType = "VkCommandBufferSubmitInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSubmitInfo2Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSubmitInfo2"));
  buf.underlyingType = "VkSubmitInfo2";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSubmitInfo2KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSubmitInfo2KHR"));
  buf.underlyingType = "VkSubmitInfo2KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkQueueFamilyCheckpointProperties2NVArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkQueueFamilyCheckpointProperties2NV"));
  buf.underlyingType = "VkQueueFamilyCheckpointProperties2NV";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkCheckpointData2NVArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkCheckpointData2NV"));
  buf.underlyingType = "VkCheckpointData2NV";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSynchronization2FeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSynchronization2Features"));
  buf.underlyingType = "VkPhysicalDeviceSynchronization2Features";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSynchronization2FeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSynchronization2FeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceSynchronization2FeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceLegacyDitheringFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceLegacyDitheringFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceLegacyDitheringFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSubpassResolvePerformanceQueryEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSubpassResolvePerformanceQueryEXT"));
  buf.underlyingType = "VkSubpassResolvePerformanceQueryEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMultisampledRenderToSingleSampledInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMultisampledRenderToSingleSampledInfoEXT"));
  buf.underlyingType = "VkMultisampledRenderToSingleSampledInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevicePipelineProtectedAccessFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePipelineProtectedAccessFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDevicePipelineProtectedAccessFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkQueueFamilyVideoPropertiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkQueueFamilyVideoPropertiesKHR"));
  buf.underlyingType = "VkQueueFamilyVideoPropertiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkQueueFamilyQueryResultStatusPropertiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkQueueFamilyQueryResultStatusPropertiesKHR"));
  buf.underlyingType = "VkQueueFamilyQueryResultStatusPropertiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkVideoProfileListInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkVideoProfileListInfoKHR"));
  buf.underlyingType = "VkVideoProfileListInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceVideoFormatInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceVideoFormatInfoKHR"));
  buf.underlyingType = "VkPhysicalDeviceVideoFormatInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkVideoFormatPropertiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkVideoFormatPropertiesKHR"));
  buf.underlyingType = "VkVideoFormatPropertiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkVideoProfileInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkVideoProfileInfoKHR"));
  buf.underlyingType = "VkVideoProfileInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkVideoCapabilitiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkVideoCapabilitiesKHR"));
  buf.underlyingType = "VkVideoCapabilitiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkVideoSessionMemoryRequirementsKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkVideoSessionMemoryRequirementsKHR"));
  buf.underlyingType = "VkVideoSessionMemoryRequirementsKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkBindVideoSessionMemoryInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkBindVideoSessionMemoryInfoKHR"));
  buf.underlyingType = "VkBindVideoSessionMemoryInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkVideoPictureResourceInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkVideoPictureResourceInfoKHR"));
  buf.underlyingType = "VkVideoPictureResourceInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkVideoReferenceSlotInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkVideoReferenceSlotInfoKHR"));
  buf.underlyingType = "VkVideoReferenceSlotInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkVideoSessionCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkVideoSessionCreateInfoKHR"));
  buf.underlyingType = "VkVideoSessionCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkVideoSessionParametersCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkVideoSessionParametersCreateInfoKHR"));
  buf.underlyingType = "VkVideoSessionParametersCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkVideoSessionParametersUpdateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkVideoSessionParametersUpdateInfoKHR"));
  buf.underlyingType = "VkVideoSessionParametersUpdateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkVideoBeginCodingInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkVideoBeginCodingInfoKHR"));
  buf.underlyingType = "VkVideoBeginCodingInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkVideoEndCodingInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkVideoEndCodingInfoKHR"));
  buf.underlyingType = "VkVideoEndCodingInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkVideoCodingControlInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkVideoCodingControlInfoKHR"));
  buf.underlyingType = "VkVideoCodingControlInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceProvokingVertexFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceProvokingVertexFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceProvokingVertexFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceProvokingVertexPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceProvokingVertexPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceProvokingVertexPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineRasterizationProvokingVertexStateCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineRasterizationProvokingVertexStateCreateInfoEXT"));
  buf.underlyingType = "VkPipelineRasterizationProvokingVertexStateCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderIntegerDotProductFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderIntegerDotProductFeatures"));
  buf.underlyingType = "VkPhysicalDeviceShaderIntegerDotProductFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderIntegerDotProductFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderIntegerDotProductPropertiesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderIntegerDotProductProperties"));
  buf.underlyingType = "VkPhysicalDeviceShaderIntegerDotProductProperties";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderIntegerDotProductPropertiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceDrmPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceDrmPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceDrmPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceFragmentShaderBarycentricFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceFragmentShaderBarycentricPropertiesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR"));
  buf.underlyingType = "VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceRGBA10X6FormatsFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkFormatProperties3Array = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkFormatProperties3"));
  buf.underlyingType = "VkFormatProperties3";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkFormatProperties3KHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkFormatProperties3KHR"));
  buf.underlyingType = "VkFormatProperties3KHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDrmFormatModifierPropertiesList2EXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDrmFormatModifierPropertiesList2EXT"));
  buf.underlyingType = "VkDrmFormatModifierPropertiesList2EXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkDrmFormatModifierProperties2EXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkDrmFormatModifierProperties2EXT"));
  buf.underlyingType = "VkDrmFormatModifierProperties2EXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineRenderingCreateInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineRenderingCreateInfo"));
  buf.underlyingType = "VkPipelineRenderingCreateInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineRenderingCreateInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineRenderingCreateInfoKHR"));
  buf.underlyingType = "VkPipelineRenderingCreateInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderingInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderingInfo"));
  buf.underlyingType = "VkRenderingInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderingAttachmentInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderingAttachmentInfo"));
  buf.underlyingType = "VkRenderingAttachmentInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderingAttachmentInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderingAttachmentInfoKHR"));
  buf.underlyingType = "VkRenderingAttachmentInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderingFragmentShadingRateAttachmentInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderingFragmentShadingRateAttachmentInfoKHR"));
  buf.underlyingType = "VkRenderingFragmentShadingRateAttachmentInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderingFragmentDensityMapAttachmentInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderingFragmentDensityMapAttachmentInfoEXT"));
  buf.underlyingType = "VkRenderingFragmentDensityMapAttachmentInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceDynamicRenderingFeaturesArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceDynamicRenderingFeatures"));
  buf.underlyingType = "VkPhysicalDeviceDynamicRenderingFeatures";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceDynamicRenderingFeaturesKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceDynamicRenderingFeaturesKHR"));
  buf.underlyingType = "VkPhysicalDeviceDynamicRenderingFeaturesKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkCommandBufferInheritanceRenderingInfoArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkCommandBufferInheritanceRenderingInfo"));
  buf.underlyingType = "VkCommandBufferInheritanceRenderingInfo";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkCommandBufferInheritanceRenderingInfoKHRArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkCommandBufferInheritanceRenderingInfoKHR"));
  buf.underlyingType = "VkCommandBufferInheritanceRenderingInfoKHR";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkAttachmentSampleCountInfoAMDArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkAttachmentSampleCountInfoAMD"));
  buf.underlyingType = "VkAttachmentSampleCountInfoAMD";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkAttachmentSampleCountInfoNVArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkAttachmentSampleCountInfoNV"));
  buf.underlyingType = "VkAttachmentSampleCountInfoNV";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkMultiviewPerViewAttributesInfoNVXArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkMultiviewPerViewAttributesInfoNVX"));
  buf.underlyingType = "VkMultiviewPerViewAttributesInfoNVX";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceImageViewMinLodFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImageViewMinLodFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceImageViewMinLodFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageViewMinLodCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageViewMinLodCreateInfoEXT"));
  buf.underlyingType = "VkImageViewMinLodCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkGraphicsPipelineLibraryCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkGraphicsPipelineLibraryCreateInfoEXT"));
  buf.underlyingType = "VkGraphicsPipelineLibraryCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderModuleIdentifierFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceShaderModuleIdentifierPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineShaderStageModuleIdentifierCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineShaderStageModuleIdentifierCreateInfoEXT"));
  buf.underlyingType = "VkPipelineShaderStageModuleIdentifierCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkShaderModuleIdentifierEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkShaderModuleIdentifierEXT"));
  buf.underlyingType = "VkShaderModuleIdentifierEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageCompressionControlEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageCompressionControlEXT"));
  buf.underlyingType = "VkImageCompressionControlEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceImageCompressionControlFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImageCompressionControlFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceImageCompressionControlFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkImageCompressionPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkImageCompressionPropertiesEXT"));
  buf.underlyingType = "VkImageCompressionPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderPassCreationControlEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderPassCreationControlEXT"));
  buf.underlyingType = "VkRenderPassCreationControlEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderPassCreationFeedbackInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderPassCreationFeedbackInfoEXT"));
  buf.underlyingType = "VkRenderPassCreationFeedbackInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderPassCreationFeedbackCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderPassCreationFeedbackCreateInfoEXT"));
  buf.underlyingType = "VkRenderPassCreationFeedbackCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderPassSubpassFeedbackInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderPassSubpassFeedbackInfoEXT"));
  buf.underlyingType = "VkRenderPassSubpassFeedbackInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkRenderPassSubpassFeedbackCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkRenderPassSubpassFeedbackCreateInfoEXT"));
  buf.underlyingType = "VkRenderPassSubpassFeedbackCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSubpassMergeFeedbackFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelinePropertiesIdentifierEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelinePropertiesIdentifierEXT"));
  buf.underlyingType = "VkPipelinePropertiesIdentifierEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevicePipelinePropertiesFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePipelinePropertiesFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDevicePipelinePropertiesFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceNonSeamlessCubeMapFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevicePipelineRobustnessFeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePipelineRobustnessFeaturesEXT"));
  buf.underlyingType = "VkPhysicalDevicePipelineRobustnessFeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPipelineRobustnessCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPipelineRobustnessCreateInfoEXT"));
  buf.underlyingType = "VkPipelineRobustnessCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDevicePipelineRobustnessPropertiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDevicePipelineRobustnessPropertiesEXT"));
  buf.underlyingType = "VkPhysicalDevicePipelineRobustnessPropertiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSurfacePresentModeEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSurfacePresentModeEXT"));
  buf.underlyingType = "VkSurfacePresentModeEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSurfacePresentScalingCapabilitiesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSurfacePresentScalingCapabilitiesEXT"));
  buf.underlyingType = "VkSurfacePresentScalingCapabilitiesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSurfacePresentModeCompatibilityEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSurfacePresentModeCompatibilityEXT"));
  buf.underlyingType = "VkSurfacePresentModeCompatibilityEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkPhysicalDeviceSwapchainMaintenance1FeaturesEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT"));
  buf.underlyingType = "VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSwapchainPresentFenceInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSwapchainPresentFenceInfoEXT"));
  buf.underlyingType = "VkSwapchainPresentFenceInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSwapchainPresentModesCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSwapchainPresentModesCreateInfoEXT"));
  buf.underlyingType = "VkSwapchainPresentModesCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSwapchainPresentModeInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSwapchainPresentModeInfoEXT"));
  buf.underlyingType = "VkSwapchainPresentModeInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkSwapchainPresentScalingCreateInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkSwapchainPresentScalingCreateInfoEXT"));
  buf.underlyingType = "VkSwapchainPresentScalingCreateInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
export const getEmptyVkReleaseSwapchainImagesInfoEXTArray = (count: number): Membuf[] => {const res = initArray(count, () => {
  const buf = new Membuf(getStructSize("VkReleaseSwapchainImagesInfoEXT"));
  buf.underlyingType = "VkReleaseSwapchainImagesInfoEXT";
  return buf;
}); BaseMembuf.reallocateIntoContinuousMemory(res); return res; }
    export interface vkCreateInstanceInputWithDevice {
  pCreateInfo: VkInstanceCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pInstance: uint64_t| null | Membuf;
}
export interface vkCreateInstanceInputWithInstance {
  pCreateInfo: VkInstanceCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pInstance: uint64_t| null | Membuf;
}

const vkCreateInstanceParamsTypes = {"pCreateInfo":{"simple":"VkInstanceCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pInstance":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateInstance = (input: vkCreateInstanceInputWithDevice | vkCreateInstanceInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_INITIALIZATION_FAILED | VkResult.VK_ERROR_LAYER_NOT_PRESENT | VkResult.VK_ERROR_EXTENSION_NOT_PRESENT | VkResult.VK_ERROR_INCOMPATIBLE_DRIVER => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateInstanceParamsTypes[e[0] as keyof typeof vkCreateInstanceParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateInstance(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyInstanceInputWithDevice {
  instance: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyInstanceInputWithInstance {
  instance: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyInstanceParamsTypes = {"instance":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyInstance = (input: vkDestroyInstanceInputWithDevice | vkDestroyInstanceInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyInstanceParamsTypes[e[0] as keyof typeof vkDestroyInstanceParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyInstance(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkEnumeratePhysicalDevicesInputWithDevice {
  instance: uint64_t | Membuf;
  pPhysicalDeviceCount: uint32_t| null | Membuf;
  pPhysicalDevices?: uint64_t[] | null | Membuf[] | Membuf;
}
export interface vkEnumeratePhysicalDevicesInputWithInstance {
  instance: uint64_t | Membuf;
  pPhysicalDeviceCount: uint32_t| null | Membuf;
  pPhysicalDevices?: uint64_t[] | null | Membuf[] | Membuf;
}

const vkEnumeratePhysicalDevicesParamsTypes = {"instance":{"simple":"uint64_t","isPointer":false},"pPhysicalDeviceCount":{"simple":"uint32_t","isPointer":true},"pPhysicalDevices":{"simple":"uint64_t","isPointer":true}} as const;
export const vkEnumeratePhysicalDevices = (input: vkEnumeratePhysicalDevicesInputWithDevice | vkEnumeratePhysicalDevicesInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_INITIALIZATION_FAILED => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkEnumeratePhysicalDevicesParamsTypes[e[0] as keyof typeof vkEnumeratePhysicalDevicesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkEnumeratePhysicalDevices(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetDeviceProcAddrInputWithDevice {
  device: uint64_t | Membuf;
  pName: char[] | null | Membuf[] | Membuf;
}
export interface vkGetDeviceProcAddrInputWithInstance {
  device: uint64_t | Membuf;
  pName: char[] | null | Membuf[] | Membuf;
}

const vkGetDeviceProcAddrParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pName":{"simple":"char","isPointer":true}} as const;
export const vkGetDeviceProcAddr = (input: vkGetDeviceProcAddrInputWithDevice | vkGetDeviceProcAddrInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetDeviceProcAddrParamsTypes[e[0] as keyof typeof vkGetDeviceProcAddrParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetDeviceProcAddr(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetInstanceProcAddrInputWithDevice {
  instance: uint64_t | nullptr_t | Membuf;
  pName: char[] | null | Membuf[] | Membuf;
}
export interface vkGetInstanceProcAddrInputWithInstance {
  instance: uint64_t | nullptr_t | Membuf;
  pName: char[] | null | Membuf[] | Membuf;
}

const vkGetInstanceProcAddrParamsTypes = {"instance":{"simple":"uint64_t","isPointer":false},"pName":{"simple":"char","isPointer":true}} as const;
export const vkGetInstanceProcAddr = (input: vkGetInstanceProcAddrInputWithDevice | vkGetInstanceProcAddrInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetInstanceProcAddrParamsTypes[e[0] as keyof typeof vkGetInstanceProcAddrParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetInstanceProcAddr(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDevicePropertiesInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pProperties: VkPhysicalDeviceProperties| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDevicePropertiesInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pProperties: VkPhysicalDeviceProperties| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDevicePropertiesParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pProperties":{"simple":"VkPhysicalDeviceProperties","isPointer":true}} as const;
export const vkGetPhysicalDeviceProperties = (input: vkGetPhysicalDevicePropertiesInputWithDevice | vkGetPhysicalDevicePropertiesInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDevicePropertiesParamsTypes[e[0] as keyof typeof vkGetPhysicalDevicePropertiesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceProperties(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceQueueFamilyPropertiesInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pQueueFamilyPropertyCount: uint32_t| null | Membuf;
  pQueueFamilyProperties?: VkQueueFamilyProperties[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceQueueFamilyPropertiesInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pQueueFamilyPropertyCount: uint32_t| null | Membuf;
  pQueueFamilyProperties?: VkQueueFamilyProperties[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceQueueFamilyPropertiesParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pQueueFamilyPropertyCount":{"simple":"uint32_t","isPointer":true},"pQueueFamilyProperties":{"simple":"VkQueueFamilyProperties","isPointer":true}} as const;
export const vkGetPhysicalDeviceQueueFamilyProperties = (input: vkGetPhysicalDeviceQueueFamilyPropertiesInputWithDevice | vkGetPhysicalDeviceQueueFamilyPropertiesInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceQueueFamilyPropertiesParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceQueueFamilyPropertiesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceQueueFamilyProperties(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceMemoryPropertiesInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pMemoryProperties: VkPhysicalDeviceMemoryProperties| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceMemoryPropertiesInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pMemoryProperties: VkPhysicalDeviceMemoryProperties| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceMemoryPropertiesParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pMemoryProperties":{"simple":"VkPhysicalDeviceMemoryProperties","isPointer":true}} as const;
export const vkGetPhysicalDeviceMemoryProperties = (input: vkGetPhysicalDeviceMemoryPropertiesInputWithDevice | vkGetPhysicalDeviceMemoryPropertiesInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceMemoryPropertiesParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceMemoryPropertiesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceMemoryProperties(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceFeaturesInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pFeatures: VkPhysicalDeviceFeatures| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceFeaturesInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pFeatures: VkPhysicalDeviceFeatures| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceFeaturesParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pFeatures":{"simple":"VkPhysicalDeviceFeatures","isPointer":true}} as const;
export const vkGetPhysicalDeviceFeatures = (input: vkGetPhysicalDeviceFeaturesInputWithDevice | vkGetPhysicalDeviceFeaturesInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceFeaturesParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceFeaturesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceFeatures(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceFormatPropertiesInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  format: int32_t | number | Membuf;
  pFormatProperties: VkFormatProperties| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceFormatPropertiesInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  format: int32_t | number | Membuf;
  pFormatProperties: VkFormatProperties| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceFormatPropertiesParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"format":{"simple":"int32_t","isPointer":false},"pFormatProperties":{"simple":"VkFormatProperties","isPointer":true}} as const;
export const vkGetPhysicalDeviceFormatProperties = (input: vkGetPhysicalDeviceFormatPropertiesInputWithDevice | vkGetPhysicalDeviceFormatPropertiesInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceFormatPropertiesParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceFormatPropertiesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceFormatProperties(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceImageFormatPropertiesInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  format: int32_t | number | Membuf;
  type: int32_t | number | Membuf;
  tiling: int32_t | number | Membuf;
  usage: uint32_t | number | Membuf;
  flags: uint32_t | nullptr_t | number | Membuf;
  pImageFormatProperties: VkImageFormatProperties| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceImageFormatPropertiesInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  format: int32_t | number | Membuf;
  type: int32_t | number | Membuf;
  tiling: int32_t | number | Membuf;
  usage: uint32_t | number | Membuf;
  flags: uint32_t | nullptr_t | number | Membuf;
  pImageFormatProperties: VkImageFormatProperties| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceImageFormatPropertiesParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"format":{"simple":"int32_t","isPointer":false},"type":{"simple":"int32_t","isPointer":false},"tiling":{"simple":"int32_t","isPointer":false},"usage":{"simple":"uint32_t","isPointer":false},"flags":{"simple":"uint32_t","isPointer":false},"pImageFormatProperties":{"simple":"VkImageFormatProperties","isPointer":true}} as const;
export const vkGetPhysicalDeviceImageFormatProperties = (input: vkGetPhysicalDeviceImageFormatPropertiesInputWithDevice | vkGetPhysicalDeviceImageFormatPropertiesInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_FORMAT_NOT_SUPPORTED => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceImageFormatPropertiesParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceImageFormatPropertiesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceImageFormatProperties(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateDeviceInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pCreateInfo: VkDeviceCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pDevice: uint64_t| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCreateDeviceInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pCreateInfo: VkDeviceCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pDevice: uint64_t| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCreateDeviceParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkDeviceCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pDevice":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateDevice = (input: vkCreateDeviceInputWithDevice | vkCreateDeviceInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_INITIALIZATION_FAILED | VkResult.VK_ERROR_EXTENSION_NOT_PRESENT | VkResult.VK_ERROR_FEATURE_NOT_PRESENT | VkResult.VK_ERROR_TOO_MANY_OBJECTS | VkResult.VK_ERROR_DEVICE_LOST => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateDeviceParamsTypes[e[0] as keyof typeof vkCreateDeviceParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateDevice(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyDeviceInputWithDevice {
  device: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyDeviceInputWithInstance {
  device: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyDeviceParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyDevice = (input: vkDestroyDeviceInputWithDevice | vkDestroyDeviceInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyDeviceParamsTypes[e[0] as keyof typeof vkDestroyDeviceParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyDevice(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkEnumerateInstanceVersionInputWithDevice {
  pApiVersion: uint32_t| null | Membuf;
}
export interface vkEnumerateInstanceVersionInputWithInstance {
  pApiVersion: uint32_t| null | Membuf;
}

const vkEnumerateInstanceVersionParamsTypes = {"pApiVersion":{"simple":"uint32_t","isPointer":true}} as const;
export const vkEnumerateInstanceVersion = (input: vkEnumerateInstanceVersionInputWithDevice | vkEnumerateInstanceVersionInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkEnumerateInstanceVersionParamsTypes[e[0] as keyof typeof vkEnumerateInstanceVersionParamsTypes])];
    }));
    const result = vsnative.vts_native_vkEnumerateInstanceVersion(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkEnumerateInstanceLayerPropertiesInputWithDevice {
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkLayerProperties[] | null | Membuf[] | Membuf;
}
export interface vkEnumerateInstanceLayerPropertiesInputWithInstance {
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkLayerProperties[] | null | Membuf[] | Membuf;
}

const vkEnumerateInstanceLayerPropertiesParamsTypes = {"pPropertyCount":{"simple":"uint32_t","isPointer":true},"pProperties":{"simple":"VkLayerProperties","isPointer":true}} as const;
export const vkEnumerateInstanceLayerProperties = (input: vkEnumerateInstanceLayerPropertiesInputWithDevice | vkEnumerateInstanceLayerPropertiesInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkEnumerateInstanceLayerPropertiesParamsTypes[e[0] as keyof typeof vkEnumerateInstanceLayerPropertiesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkEnumerateInstanceLayerProperties(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkEnumerateInstanceExtensionPropertiesInputWithDevice {
  pLayerName?: char[] | null | Membuf[] | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkExtensionProperties[] | null | Membuf[] | Membuf;
}
export interface vkEnumerateInstanceExtensionPropertiesInputWithInstance {
  pLayerName?: char[] | null | Membuf[] | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkExtensionProperties[] | null | Membuf[] | Membuf;
}

const vkEnumerateInstanceExtensionPropertiesParamsTypes = {"pLayerName":{"simple":"char","isPointer":true},"pPropertyCount":{"simple":"uint32_t","isPointer":true},"pProperties":{"simple":"VkExtensionProperties","isPointer":true}} as const;
export const vkEnumerateInstanceExtensionProperties = (input: vkEnumerateInstanceExtensionPropertiesInputWithDevice | vkEnumerateInstanceExtensionPropertiesInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_LAYER_NOT_PRESENT => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkEnumerateInstanceExtensionPropertiesParamsTypes[e[0] as keyof typeof vkEnumerateInstanceExtensionPropertiesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkEnumerateInstanceExtensionProperties(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkEnumerateDeviceLayerPropertiesInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkLayerProperties[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkEnumerateDeviceLayerPropertiesInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkLayerProperties[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkEnumerateDeviceLayerPropertiesParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pPropertyCount":{"simple":"uint32_t","isPointer":true},"pProperties":{"simple":"VkLayerProperties","isPointer":true}} as const;
export const vkEnumerateDeviceLayerProperties = (input: vkEnumerateDeviceLayerPropertiesInputWithDevice | vkEnumerateDeviceLayerPropertiesInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkEnumerateDeviceLayerPropertiesParamsTypes[e[0] as keyof typeof vkEnumerateDeviceLayerPropertiesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkEnumerateDeviceLayerProperties(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkEnumerateDeviceExtensionPropertiesInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pLayerName?: char[] | null | Membuf[] | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkExtensionProperties[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkEnumerateDeviceExtensionPropertiesInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pLayerName?: char[] | null | Membuf[] | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkExtensionProperties[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkEnumerateDeviceExtensionPropertiesParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pLayerName":{"simple":"char","isPointer":true},"pPropertyCount":{"simple":"uint32_t","isPointer":true},"pProperties":{"simple":"VkExtensionProperties","isPointer":true}} as const;
export const vkEnumerateDeviceExtensionProperties = (input: vkEnumerateDeviceExtensionPropertiesInputWithDevice | vkEnumerateDeviceExtensionPropertiesInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_LAYER_NOT_PRESENT => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkEnumerateDeviceExtensionPropertiesParamsTypes[e[0] as keyof typeof vkEnumerateDeviceExtensionPropertiesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkEnumerateDeviceExtensionProperties(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetDeviceQueueInputWithDevice {
  device: uint64_t | Membuf;
  queueFamilyIndex: uint32_t | number | Membuf;
  queueIndex: uint32_t | number | Membuf;
  pQueue: uint64_t| null | Membuf;
}
export interface vkGetDeviceQueueInputWithInstance {
  device: uint64_t | Membuf;
  queueFamilyIndex: uint32_t | number | Membuf;
  queueIndex: uint32_t | number | Membuf;
  pQueue: uint64_t| null | Membuf;
}

const vkGetDeviceQueueParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"queueFamilyIndex":{"simple":"uint32_t","isPointer":false},"queueIndex":{"simple":"uint32_t","isPointer":false},"pQueue":{"simple":"uint64_t","isPointer":true}} as const;
export const vkGetDeviceQueue = (input: vkGetDeviceQueueInputWithDevice | vkGetDeviceQueueInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetDeviceQueueParamsTypes[e[0] as keyof typeof vkGetDeviceQueueParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetDeviceQueue(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkQueueSubmitInputWithDevice {
  queue: uint64_t | Membuf;
  submitCount: uint32_t | nullptr_t | number | Membuf;
  pSubmits: VkSubmitInfo[] | null | Membuf[] | Membuf;
  fence: uint64_t | nullptr_t | Membuf;
  device: uint64_t | Membuf;
}
export interface vkQueueSubmitInputWithInstance {
  queue: uint64_t | Membuf;
  submitCount: uint32_t | nullptr_t | number | Membuf;
  pSubmits: VkSubmitInfo[] | null | Membuf[] | Membuf;
  fence: uint64_t | nullptr_t | Membuf;
  instance: uint64_t | Membuf;
}

const vkQueueSubmitParamsTypes = {"queue":{"simple":"uint64_t","isPointer":false},"submitCount":{"simple":"uint32_t","isPointer":false},"pSubmits":{"simple":"VkSubmitInfo","isPointer":true},"fence":{"simple":"uint64_t","isPointer":false}} as const;
export const vkQueueSubmit = (input: vkQueueSubmitInputWithDevice | vkQueueSubmitInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_DEVICE_LOST => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkQueueSubmitParamsTypes[e[0] as keyof typeof vkQueueSubmitParamsTypes])];
    }));
    const result = vsnative.vts_native_vkQueueSubmit(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkQueueWaitIdleInputWithDevice {
  queue: uint64_t | Membuf;
  device: uint64_t | Membuf;
}
export interface vkQueueWaitIdleInputWithInstance {
  queue: uint64_t | Membuf;
  instance: uint64_t | Membuf;
}

const vkQueueWaitIdleParamsTypes = {"queue":{"simple":"uint64_t","isPointer":false}} as const;
export const vkQueueWaitIdle = (input: vkQueueWaitIdleInputWithDevice | vkQueueWaitIdleInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_DEVICE_LOST => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkQueueWaitIdleParamsTypes[e[0] as keyof typeof vkQueueWaitIdleParamsTypes])];
    }));
    const result = vsnative.vts_native_vkQueueWaitIdle(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDeviceWaitIdleInputWithDevice {
  device: uint64_t | Membuf;
}
export interface vkDeviceWaitIdleInputWithInstance {
  device: uint64_t | Membuf;
}

const vkDeviceWaitIdleParamsTypes = {"device":{"simple":"uint64_t","isPointer":false}} as const;
export const vkDeviceWaitIdle = (input: vkDeviceWaitIdleInputWithDevice | vkDeviceWaitIdleInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_DEVICE_LOST => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDeviceWaitIdleParamsTypes[e[0] as keyof typeof vkDeviceWaitIdleParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDeviceWaitIdle(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkAllocateMemoryInputWithDevice {
  device: uint64_t | Membuf;
  pAllocateInfo: VkMemoryAllocateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pMemory: uint64_t| null | Membuf;
}
export interface vkAllocateMemoryInputWithInstance {
  device: uint64_t | Membuf;
  pAllocateInfo: VkMemoryAllocateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pMemory: uint64_t| null | Membuf;
}

const vkAllocateMemoryParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pAllocateInfo":{"simple":"VkMemoryAllocateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pMemory":{"simple":"uint64_t","isPointer":true}} as const;
export const vkAllocateMemory = (input: vkAllocateMemoryInputWithDevice | vkAllocateMemoryInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_INVALID_EXTERNAL_HANDLE => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkAllocateMemoryParamsTypes[e[0] as keyof typeof vkAllocateMemoryParamsTypes])];
    }));
    const result = vsnative.vts_native_vkAllocateMemory(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkFreeMemoryInputWithDevice {
  device: uint64_t | Membuf;
  memory: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkFreeMemoryInputWithInstance {
  device: uint64_t | Membuf;
  memory: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkFreeMemoryParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"memory":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkFreeMemory = (input: vkFreeMemoryInputWithDevice | vkFreeMemoryInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkFreeMemoryParamsTypes[e[0] as keyof typeof vkFreeMemoryParamsTypes])];
    }));
    const result = vsnative.vts_native_vkFreeMemory(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkMapMemoryInputWithDevice {
  device: uint64_t | Membuf;
  memory: uint64_t | Membuf;
  offset: uint64_t | number | Membuf;
  size: uint64_t | number | Membuf;
  flags: int32_t | nullptr_t | number | Membuf;
  ppData: uint64_t| null | Membuf;
}
export interface vkMapMemoryInputWithInstance {
  device: uint64_t | Membuf;
  memory: uint64_t | Membuf;
  offset: uint64_t | number | Membuf;
  size: uint64_t | number | Membuf;
  flags: int32_t | nullptr_t | number | Membuf;
  ppData: uint64_t| null | Membuf;
}

const vkMapMemoryParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"memory":{"simple":"uint64_t","isPointer":false},"offset":{"simple":"uint64_t","isPointer":false},"size":{"simple":"uint64_t","isPointer":false},"flags":{"simple":"int32_t","isPointer":false},"ppData":{"simple":"uint64_t","isPointer":true}} as const;
export const vkMapMemory = (input: vkMapMemoryInputWithDevice | vkMapMemoryInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_MEMORY_MAP_FAILED => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkMapMemoryParamsTypes[e[0] as keyof typeof vkMapMemoryParamsTypes])];
    }));
    const result = vsnative.vts_native_vkMapMemory(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkUnmapMemoryInputWithDevice {
  device: uint64_t | Membuf;
  memory: uint64_t | Membuf;
}
export interface vkUnmapMemoryInputWithInstance {
  device: uint64_t | Membuf;
  memory: uint64_t | Membuf;
}

const vkUnmapMemoryParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"memory":{"simple":"uint64_t","isPointer":false}} as const;
export const vkUnmapMemory = (input: vkUnmapMemoryInputWithDevice | vkUnmapMemoryInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkUnmapMemoryParamsTypes[e[0] as keyof typeof vkUnmapMemoryParamsTypes])];
    }));
    const result = vsnative.vts_native_vkUnmapMemory(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkFlushMappedMemoryRangesInputWithDevice {
  device: uint64_t | Membuf;
  memoryRangeCount: uint32_t | number | Membuf;
  pMemoryRanges: VkMappedMemoryRange[] | null | Membuf[] | Membuf;
}
export interface vkFlushMappedMemoryRangesInputWithInstance {
  device: uint64_t | Membuf;
  memoryRangeCount: uint32_t | number | Membuf;
  pMemoryRanges: VkMappedMemoryRange[] | null | Membuf[] | Membuf;
}

const vkFlushMappedMemoryRangesParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"memoryRangeCount":{"simple":"uint32_t","isPointer":false},"pMemoryRanges":{"simple":"VkMappedMemoryRange","isPointer":true}} as const;
export const vkFlushMappedMemoryRanges = (input: vkFlushMappedMemoryRangesInputWithDevice | vkFlushMappedMemoryRangesInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkFlushMappedMemoryRangesParamsTypes[e[0] as keyof typeof vkFlushMappedMemoryRangesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkFlushMappedMemoryRanges(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkInvalidateMappedMemoryRangesInputWithDevice {
  device: uint64_t | Membuf;
  memoryRangeCount: uint32_t | number | Membuf;
  pMemoryRanges: VkMappedMemoryRange[] | null | Membuf[] | Membuf;
}
export interface vkInvalidateMappedMemoryRangesInputWithInstance {
  device: uint64_t | Membuf;
  memoryRangeCount: uint32_t | number | Membuf;
  pMemoryRanges: VkMappedMemoryRange[] | null | Membuf[] | Membuf;
}

const vkInvalidateMappedMemoryRangesParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"memoryRangeCount":{"simple":"uint32_t","isPointer":false},"pMemoryRanges":{"simple":"VkMappedMemoryRange","isPointer":true}} as const;
export const vkInvalidateMappedMemoryRanges = (input: vkInvalidateMappedMemoryRangesInputWithDevice | vkInvalidateMappedMemoryRangesInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkInvalidateMappedMemoryRangesParamsTypes[e[0] as keyof typeof vkInvalidateMappedMemoryRangesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkInvalidateMappedMemoryRanges(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetDeviceMemoryCommitmentInputWithDevice {
  device: uint64_t | Membuf;
  memory: uint64_t | Membuf;
  pCommittedMemoryInBytes: uint64_t| null | Membuf;
}
export interface vkGetDeviceMemoryCommitmentInputWithInstance {
  device: uint64_t | Membuf;
  memory: uint64_t | Membuf;
  pCommittedMemoryInBytes: uint64_t| null | Membuf;
}

const vkGetDeviceMemoryCommitmentParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"memory":{"simple":"uint64_t","isPointer":false},"pCommittedMemoryInBytes":{"simple":"uint64_t","isPointer":true}} as const;
export const vkGetDeviceMemoryCommitment = (input: vkGetDeviceMemoryCommitmentInputWithDevice | vkGetDeviceMemoryCommitmentInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetDeviceMemoryCommitmentParamsTypes[e[0] as keyof typeof vkGetDeviceMemoryCommitmentParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetDeviceMemoryCommitment(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetBufferMemoryRequirementsInputWithDevice {
  device: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  pMemoryRequirements: VkMemoryRequirements| null | Membuf;
}
export interface vkGetBufferMemoryRequirementsInputWithInstance {
  device: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  pMemoryRequirements: VkMemoryRequirements| null | Membuf;
}

const vkGetBufferMemoryRequirementsParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"buffer":{"simple":"uint64_t","isPointer":false},"pMemoryRequirements":{"simple":"VkMemoryRequirements","isPointer":true}} as const;
export const vkGetBufferMemoryRequirements = (input: vkGetBufferMemoryRequirementsInputWithDevice | vkGetBufferMemoryRequirementsInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetBufferMemoryRequirementsParamsTypes[e[0] as keyof typeof vkGetBufferMemoryRequirementsParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetBufferMemoryRequirements(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkBindBufferMemoryInputWithDevice {
  device: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  memory: uint64_t | Membuf;
  memoryOffset: uint64_t | number | Membuf;
}
export interface vkBindBufferMemoryInputWithInstance {
  device: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  memory: uint64_t | Membuf;
  memoryOffset: uint64_t | number | Membuf;
}

const vkBindBufferMemoryParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"buffer":{"simple":"uint64_t","isPointer":false},"memory":{"simple":"uint64_t","isPointer":false},"memoryOffset":{"simple":"uint64_t","isPointer":false}} as const;
export const vkBindBufferMemory = (input: vkBindBufferMemoryInputWithDevice | vkBindBufferMemoryInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkBindBufferMemoryParamsTypes[e[0] as keyof typeof vkBindBufferMemoryParamsTypes])];
    }));
    const result = vsnative.vts_native_vkBindBufferMemory(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetImageMemoryRequirementsInputWithDevice {
  device: uint64_t | Membuf;
  image: uint64_t | Membuf;
  pMemoryRequirements: VkMemoryRequirements| null | Membuf;
}
export interface vkGetImageMemoryRequirementsInputWithInstance {
  device: uint64_t | Membuf;
  image: uint64_t | Membuf;
  pMemoryRequirements: VkMemoryRequirements| null | Membuf;
}

const vkGetImageMemoryRequirementsParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"image":{"simple":"uint64_t","isPointer":false},"pMemoryRequirements":{"simple":"VkMemoryRequirements","isPointer":true}} as const;
export const vkGetImageMemoryRequirements = (input: vkGetImageMemoryRequirementsInputWithDevice | vkGetImageMemoryRequirementsInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetImageMemoryRequirementsParamsTypes[e[0] as keyof typeof vkGetImageMemoryRequirementsParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetImageMemoryRequirements(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkBindImageMemoryInputWithDevice {
  device: uint64_t | Membuf;
  image: uint64_t | Membuf;
  memory: uint64_t | Membuf;
  memoryOffset: uint64_t | number | Membuf;
}
export interface vkBindImageMemoryInputWithInstance {
  device: uint64_t | Membuf;
  image: uint64_t | Membuf;
  memory: uint64_t | Membuf;
  memoryOffset: uint64_t | number | Membuf;
}

const vkBindImageMemoryParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"image":{"simple":"uint64_t","isPointer":false},"memory":{"simple":"uint64_t","isPointer":false},"memoryOffset":{"simple":"uint64_t","isPointer":false}} as const;
export const vkBindImageMemory = (input: vkBindImageMemoryInputWithDevice | vkBindImageMemoryInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkBindImageMemoryParamsTypes[e[0] as keyof typeof vkBindImageMemoryParamsTypes])];
    }));
    const result = vsnative.vts_native_vkBindImageMemory(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetImageSparseMemoryRequirementsInputWithDevice {
  device: uint64_t | Membuf;
  image: uint64_t | Membuf;
  pSparseMemoryRequirementCount: uint32_t| null | Membuf;
  pSparseMemoryRequirements?: VkSparseImageMemoryRequirements[] | null | Membuf[] | Membuf;
}
export interface vkGetImageSparseMemoryRequirementsInputWithInstance {
  device: uint64_t | Membuf;
  image: uint64_t | Membuf;
  pSparseMemoryRequirementCount: uint32_t| null | Membuf;
  pSparseMemoryRequirements?: VkSparseImageMemoryRequirements[] | null | Membuf[] | Membuf;
}

const vkGetImageSparseMemoryRequirementsParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"image":{"simple":"uint64_t","isPointer":false},"pSparseMemoryRequirementCount":{"simple":"uint32_t","isPointer":true},"pSparseMemoryRequirements":{"simple":"VkSparseImageMemoryRequirements","isPointer":true}} as const;
export const vkGetImageSparseMemoryRequirements = (input: vkGetImageSparseMemoryRequirementsInputWithDevice | vkGetImageSparseMemoryRequirementsInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetImageSparseMemoryRequirementsParamsTypes[e[0] as keyof typeof vkGetImageSparseMemoryRequirementsParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetImageSparseMemoryRequirements(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceSparseImageFormatPropertiesInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  format: int32_t | number | Membuf;
  type: int32_t | number | Membuf;
  samples: uint32_t | number | Membuf;
  usage: uint32_t | number | Membuf;
  tiling: int32_t | number | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkSparseImageFormatProperties[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceSparseImageFormatPropertiesInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  format: int32_t | number | Membuf;
  type: int32_t | number | Membuf;
  samples: uint32_t | number | Membuf;
  usage: uint32_t | number | Membuf;
  tiling: int32_t | number | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkSparseImageFormatProperties[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceSparseImageFormatPropertiesParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"format":{"simple":"int32_t","isPointer":false},"type":{"simple":"int32_t","isPointer":false},"samples":{"simple":"uint32_t","isPointer":false},"usage":{"simple":"uint32_t","isPointer":false},"tiling":{"simple":"int32_t","isPointer":false},"pPropertyCount":{"simple":"uint32_t","isPointer":true},"pProperties":{"simple":"VkSparseImageFormatProperties","isPointer":true}} as const;
export const vkGetPhysicalDeviceSparseImageFormatProperties = (input: vkGetPhysicalDeviceSparseImageFormatPropertiesInputWithDevice | vkGetPhysicalDeviceSparseImageFormatPropertiesInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceSparseImageFormatPropertiesParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceSparseImageFormatPropertiesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceSparseImageFormatProperties(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkQueueBindSparseInputWithDevice {
  queue: uint64_t | Membuf;
  bindInfoCount: uint32_t | nullptr_t | number | Membuf;
  pBindInfo: VkBindSparseInfo[] | null | Membuf[] | Membuf;
  fence: uint64_t | nullptr_t | Membuf;
  device: uint64_t | Membuf;
}
export interface vkQueueBindSparseInputWithInstance {
  queue: uint64_t | Membuf;
  bindInfoCount: uint32_t | nullptr_t | number | Membuf;
  pBindInfo: VkBindSparseInfo[] | null | Membuf[] | Membuf;
  fence: uint64_t | nullptr_t | Membuf;
  instance: uint64_t | Membuf;
}

const vkQueueBindSparseParamsTypes = {"queue":{"simple":"uint64_t","isPointer":false},"bindInfoCount":{"simple":"uint32_t","isPointer":false},"pBindInfo":{"simple":"VkBindSparseInfo","isPointer":true},"fence":{"simple":"uint64_t","isPointer":false}} as const;
export const vkQueueBindSparse = (input: vkQueueBindSparseInputWithDevice | vkQueueBindSparseInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_DEVICE_LOST => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkQueueBindSparseParamsTypes[e[0] as keyof typeof vkQueueBindSparseParamsTypes])];
    }));
    const result = vsnative.vts_native_vkQueueBindSparse(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateFenceInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkFenceCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pFence: uint64_t| null | Membuf;
}
export interface vkCreateFenceInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkFenceCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pFence: uint64_t| null | Membuf;
}

const vkCreateFenceParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkFenceCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pFence":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateFence = (input: vkCreateFenceInputWithDevice | vkCreateFenceInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateFenceParamsTypes[e[0] as keyof typeof vkCreateFenceParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateFence(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyFenceInputWithDevice {
  device: uint64_t | Membuf;
  fence: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyFenceInputWithInstance {
  device: uint64_t | Membuf;
  fence: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyFenceParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"fence":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyFence = (input: vkDestroyFenceInputWithDevice | vkDestroyFenceInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyFenceParamsTypes[e[0] as keyof typeof vkDestroyFenceParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyFence(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkResetFencesInputWithDevice {
  device: uint64_t | Membuf;
  fenceCount: uint32_t | number | Membuf;
  pFences: uint64_t[] | null | Membuf[] | Membuf;
}
export interface vkResetFencesInputWithInstance {
  device: uint64_t | Membuf;
  fenceCount: uint32_t | number | Membuf;
  pFences: uint64_t[] | null | Membuf[] | Membuf;
}

const vkResetFencesParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"fenceCount":{"simple":"uint32_t","isPointer":false},"pFences":{"simple":"uint64_t","isPointer":true}} as const;
export const vkResetFences = (input: vkResetFencesInputWithDevice | vkResetFencesInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkResetFencesParamsTypes[e[0] as keyof typeof vkResetFencesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkResetFences(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetFenceStatusInputWithDevice {
  device: uint64_t | Membuf;
  fence: uint64_t | Membuf;
}
export interface vkGetFenceStatusInputWithInstance {
  device: uint64_t | Membuf;
  fence: uint64_t | Membuf;
}

const vkGetFenceStatusParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"fence":{"simple":"uint64_t","isPointer":false}} as const;
export const vkGetFenceStatus = (input: vkGetFenceStatusInputWithDevice | vkGetFenceStatusInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_NOT_READY | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_DEVICE_LOST => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetFenceStatusParamsTypes[e[0] as keyof typeof vkGetFenceStatusParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetFenceStatus(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkWaitForFencesInputWithDevice {
  device: uint64_t | Membuf;
  fenceCount: uint32_t | number | Membuf;
  pFences: uint64_t[] | null | Membuf[] | Membuf;
  waitAll: uint32_t | number | Membuf;
  timeout: uint64_t | number | Membuf;
}
export interface vkWaitForFencesInputWithInstance {
  device: uint64_t | Membuf;
  fenceCount: uint32_t | number | Membuf;
  pFences: uint64_t[] | null | Membuf[] | Membuf;
  waitAll: uint32_t | number | Membuf;
  timeout: uint64_t | number | Membuf;
}

const vkWaitForFencesParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"fenceCount":{"simple":"uint32_t","isPointer":false},"pFences":{"simple":"uint64_t","isPointer":true},"waitAll":{"simple":"uint32_t","isPointer":false},"timeout":{"simple":"uint64_t","isPointer":false}} as const;
export const vkWaitForFences = (input: vkWaitForFencesInputWithDevice | vkWaitForFencesInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_TIMEOUT | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_DEVICE_LOST => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkWaitForFencesParamsTypes[e[0] as keyof typeof vkWaitForFencesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkWaitForFences(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateSemaphoreInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkSemaphoreCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pSemaphore: uint64_t| null | Membuf;
}
export interface vkCreateSemaphoreInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkSemaphoreCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pSemaphore: uint64_t| null | Membuf;
}

const vkCreateSemaphoreParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkSemaphoreCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pSemaphore":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateSemaphore = (input: vkCreateSemaphoreInputWithDevice | vkCreateSemaphoreInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateSemaphoreParamsTypes[e[0] as keyof typeof vkCreateSemaphoreParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateSemaphore(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroySemaphoreInputWithDevice {
  device: uint64_t | Membuf;
  semaphore: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroySemaphoreInputWithInstance {
  device: uint64_t | Membuf;
  semaphore: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroySemaphoreParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"semaphore":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroySemaphore = (input: vkDestroySemaphoreInputWithDevice | vkDestroySemaphoreInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroySemaphoreParamsTypes[e[0] as keyof typeof vkDestroySemaphoreParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroySemaphore(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateEventInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkEventCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pEvent: uint64_t| null | Membuf;
}
export interface vkCreateEventInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkEventCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pEvent: uint64_t| null | Membuf;
}

const vkCreateEventParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkEventCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pEvent":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateEvent = (input: vkCreateEventInputWithDevice | vkCreateEventInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateEventParamsTypes[e[0] as keyof typeof vkCreateEventParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateEvent(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyEventInputWithDevice {
  device: uint64_t | Membuf;
  event: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyEventInputWithInstance {
  device: uint64_t | Membuf;
  event: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyEventParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"event":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyEvent = (input: vkDestroyEventInputWithDevice | vkDestroyEventInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyEventParamsTypes[e[0] as keyof typeof vkDestroyEventParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyEvent(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetEventStatusInputWithDevice {
  device: uint64_t | Membuf;
  event: uint64_t | Membuf;
}
export interface vkGetEventStatusInputWithInstance {
  device: uint64_t | Membuf;
  event: uint64_t | Membuf;
}

const vkGetEventStatusParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"event":{"simple":"uint64_t","isPointer":false}} as const;
export const vkGetEventStatus = (input: vkGetEventStatusInputWithDevice | vkGetEventStatusInputWithInstance): VkResult.VK_EVENT_SET | VkResult.VK_EVENT_RESET | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_DEVICE_LOST => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetEventStatusParamsTypes[e[0] as keyof typeof vkGetEventStatusParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetEventStatus(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkSetEventInputWithDevice {
  device: uint64_t | Membuf;
  event: uint64_t | Membuf;
}
export interface vkSetEventInputWithInstance {
  device: uint64_t | Membuf;
  event: uint64_t | Membuf;
}

const vkSetEventParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"event":{"simple":"uint64_t","isPointer":false}} as const;
export const vkSetEvent = (input: vkSetEventInputWithDevice | vkSetEventInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkSetEventParamsTypes[e[0] as keyof typeof vkSetEventParamsTypes])];
    }));
    const result = vsnative.vts_native_vkSetEvent(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkResetEventInputWithDevice {
  device: uint64_t | Membuf;
  event: uint64_t | Membuf;
}
export interface vkResetEventInputWithInstance {
  device: uint64_t | Membuf;
  event: uint64_t | Membuf;
}

const vkResetEventParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"event":{"simple":"uint64_t","isPointer":false}} as const;
export const vkResetEvent = (input: vkResetEventInputWithDevice | vkResetEventInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkResetEventParamsTypes[e[0] as keyof typeof vkResetEventParamsTypes])];
    }));
    const result = vsnative.vts_native_vkResetEvent(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateQueryPoolInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkQueryPoolCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pQueryPool: uint64_t| null | Membuf;
}
export interface vkCreateQueryPoolInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkQueryPoolCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pQueryPool: uint64_t| null | Membuf;
}

const vkCreateQueryPoolParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkQueryPoolCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pQueryPool":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateQueryPool = (input: vkCreateQueryPoolInputWithDevice | vkCreateQueryPoolInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateQueryPoolParamsTypes[e[0] as keyof typeof vkCreateQueryPoolParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateQueryPool(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyQueryPoolInputWithDevice {
  device: uint64_t | Membuf;
  queryPool: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyQueryPoolInputWithInstance {
  device: uint64_t | Membuf;
  queryPool: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyQueryPoolParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"queryPool":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyQueryPool = (input: vkDestroyQueryPoolInputWithDevice | vkDestroyQueryPoolInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyQueryPoolParamsTypes[e[0] as keyof typeof vkDestroyQueryPoolParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyQueryPool(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetQueryPoolResultsInputWithDevice {
  device: uint64_t | Membuf;
  queryPool: uint64_t | Membuf;
  firstQuery: uint32_t | number | Membuf;
  queryCount: uint32_t | number | Membuf;
  dataSize: size_t | number | Membuf;
  pData: uint64_t[] | null | Membuf[] | Membuf;
  stride: uint64_t | number | Membuf;
  flags: uint32_t | nullptr_t | number | Membuf;
}
export interface vkGetQueryPoolResultsInputWithInstance {
  device: uint64_t | Membuf;
  queryPool: uint64_t | Membuf;
  firstQuery: uint32_t | number | Membuf;
  queryCount: uint32_t | number | Membuf;
  dataSize: size_t | number | Membuf;
  pData: uint64_t[] | null | Membuf[] | Membuf;
  stride: uint64_t | number | Membuf;
  flags: uint32_t | nullptr_t | number | Membuf;
}

const vkGetQueryPoolResultsParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"queryPool":{"simple":"uint64_t","isPointer":false},"firstQuery":{"simple":"uint32_t","isPointer":false},"queryCount":{"simple":"uint32_t","isPointer":false},"dataSize":{"simple":"size_t","isPointer":false},"pData":{"simple":"uint64_t","isPointer":true},"stride":{"simple":"uint64_t","isPointer":false},"flags":{"simple":"uint32_t","isPointer":false}} as const;
export const vkGetQueryPoolResults = (input: vkGetQueryPoolResultsInputWithDevice | vkGetQueryPoolResultsInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_NOT_READY | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_DEVICE_LOST => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetQueryPoolResultsParamsTypes[e[0] as keyof typeof vkGetQueryPoolResultsParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetQueryPoolResults(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkResetQueryPoolInputWithDevice {
  device: uint64_t | Membuf;
  queryPool: uint64_t | Membuf;
  firstQuery: uint32_t | number | Membuf;
  queryCount: uint32_t | number | Membuf;
}
export interface vkResetQueryPoolInputWithInstance {
  device: uint64_t | Membuf;
  queryPool: uint64_t | Membuf;
  firstQuery: uint32_t | number | Membuf;
  queryCount: uint32_t | number | Membuf;
}

const vkResetQueryPoolParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"queryPool":{"simple":"uint64_t","isPointer":false},"firstQuery":{"simple":"uint32_t","isPointer":false},"queryCount":{"simple":"uint32_t","isPointer":false}} as const;
export const vkResetQueryPool = (input: vkResetQueryPoolInputWithDevice | vkResetQueryPoolInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkResetQueryPoolParamsTypes[e[0] as keyof typeof vkResetQueryPoolParamsTypes])];
    }));
    const result = vsnative.vts_native_vkResetQueryPool(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateBufferInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkBufferCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pBuffer: uint64_t| null | Membuf;
}
export interface vkCreateBufferInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkBufferCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pBuffer: uint64_t| null | Membuf;
}

const vkCreateBufferParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkBufferCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pBuffer":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateBuffer = (input: vkCreateBufferInputWithDevice | vkCreateBufferInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateBufferParamsTypes[e[0] as keyof typeof vkCreateBufferParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateBuffer(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyBufferInputWithDevice {
  device: uint64_t | Membuf;
  buffer: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyBufferInputWithInstance {
  device: uint64_t | Membuf;
  buffer: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyBufferParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"buffer":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyBuffer = (input: vkDestroyBufferInputWithDevice | vkDestroyBufferInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyBufferParamsTypes[e[0] as keyof typeof vkDestroyBufferParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyBuffer(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateBufferViewInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkBufferViewCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pView: uint64_t| null | Membuf;
}
export interface vkCreateBufferViewInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkBufferViewCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pView: uint64_t| null | Membuf;
}

const vkCreateBufferViewParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkBufferViewCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pView":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateBufferView = (input: vkCreateBufferViewInputWithDevice | vkCreateBufferViewInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateBufferViewParamsTypes[e[0] as keyof typeof vkCreateBufferViewParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateBufferView(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyBufferViewInputWithDevice {
  device: uint64_t | Membuf;
  bufferView: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyBufferViewInputWithInstance {
  device: uint64_t | Membuf;
  bufferView: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyBufferViewParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"bufferView":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyBufferView = (input: vkDestroyBufferViewInputWithDevice | vkDestroyBufferViewInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyBufferViewParamsTypes[e[0] as keyof typeof vkDestroyBufferViewParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyBufferView(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateImageInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkImageCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pImage: uint64_t| null | Membuf;
}
export interface vkCreateImageInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkImageCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pImage: uint64_t| null | Membuf;
}

const vkCreateImageParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkImageCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pImage":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateImage = (input: vkCreateImageInputWithDevice | vkCreateImageInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_COMPRESSION_EXHAUSTED_EXT => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateImageParamsTypes[e[0] as keyof typeof vkCreateImageParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateImage(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyImageInputWithDevice {
  device: uint64_t | Membuf;
  image: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyImageInputWithInstance {
  device: uint64_t | Membuf;
  image: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyImageParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"image":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyImage = (input: vkDestroyImageInputWithDevice | vkDestroyImageInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyImageParamsTypes[e[0] as keyof typeof vkDestroyImageParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyImage(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetImageSubresourceLayoutInputWithDevice {
  device: uint64_t | Membuf;
  image: uint64_t | Membuf;
  pSubresource: VkImageSubresource| null | Membuf;
  pLayout: VkSubresourceLayout| null | Membuf;
}
export interface vkGetImageSubresourceLayoutInputWithInstance {
  device: uint64_t | Membuf;
  image: uint64_t | Membuf;
  pSubresource: VkImageSubresource| null | Membuf;
  pLayout: VkSubresourceLayout| null | Membuf;
}

const vkGetImageSubresourceLayoutParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"image":{"simple":"uint64_t","isPointer":false},"pSubresource":{"simple":"VkImageSubresource","isPointer":true},"pLayout":{"simple":"VkSubresourceLayout","isPointer":true}} as const;
export const vkGetImageSubresourceLayout = (input: vkGetImageSubresourceLayoutInputWithDevice | vkGetImageSubresourceLayoutInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetImageSubresourceLayoutParamsTypes[e[0] as keyof typeof vkGetImageSubresourceLayoutParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetImageSubresourceLayout(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateImageViewInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkImageViewCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pView: uint64_t| null | Membuf;
}
export interface vkCreateImageViewInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkImageViewCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pView: uint64_t| null | Membuf;
}

const vkCreateImageViewParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkImageViewCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pView":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateImageView = (input: vkCreateImageViewInputWithDevice | vkCreateImageViewInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateImageViewParamsTypes[e[0] as keyof typeof vkCreateImageViewParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateImageView(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyImageViewInputWithDevice {
  device: uint64_t | Membuf;
  imageView: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyImageViewInputWithInstance {
  device: uint64_t | Membuf;
  imageView: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyImageViewParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"imageView":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyImageView = (input: vkDestroyImageViewInputWithDevice | vkDestroyImageViewInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyImageViewParamsTypes[e[0] as keyof typeof vkDestroyImageViewParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyImageView(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateShaderModuleInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkShaderModuleCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pShaderModule: uint64_t| null | Membuf;
}
export interface vkCreateShaderModuleInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkShaderModuleCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pShaderModule: uint64_t| null | Membuf;
}

const vkCreateShaderModuleParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkShaderModuleCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pShaderModule":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateShaderModule = (input: vkCreateShaderModuleInputWithDevice | vkCreateShaderModuleInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_INVALID_SHADER_NV => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateShaderModuleParamsTypes[e[0] as keyof typeof vkCreateShaderModuleParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateShaderModule(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyShaderModuleInputWithDevice {
  device: uint64_t | Membuf;
  shaderModule: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyShaderModuleInputWithInstance {
  device: uint64_t | Membuf;
  shaderModule: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyShaderModuleParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"shaderModule":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyShaderModule = (input: vkDestroyShaderModuleInputWithDevice | vkDestroyShaderModuleInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyShaderModuleParamsTypes[e[0] as keyof typeof vkDestroyShaderModuleParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyShaderModule(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreatePipelineCacheInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkPipelineCacheCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pPipelineCache: uint64_t| null | Membuf;
}
export interface vkCreatePipelineCacheInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkPipelineCacheCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pPipelineCache: uint64_t| null | Membuf;
}

const vkCreatePipelineCacheParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkPipelineCacheCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pPipelineCache":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreatePipelineCache = (input: vkCreatePipelineCacheInputWithDevice | vkCreatePipelineCacheInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreatePipelineCacheParamsTypes[e[0] as keyof typeof vkCreatePipelineCacheParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreatePipelineCache(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyPipelineCacheInputWithDevice {
  device: uint64_t | Membuf;
  pipelineCache: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyPipelineCacheInputWithInstance {
  device: uint64_t | Membuf;
  pipelineCache: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyPipelineCacheParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pipelineCache":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyPipelineCache = (input: vkDestroyPipelineCacheInputWithDevice | vkDestroyPipelineCacheInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyPipelineCacheParamsTypes[e[0] as keyof typeof vkDestroyPipelineCacheParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyPipelineCache(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPipelineCacheDataInputWithDevice {
  device: uint64_t | Membuf;
  pipelineCache: uint64_t | Membuf;
  pDataSize: size_t| null | Membuf;
  pData?: uint64_t[] | null | Membuf[] | Membuf;
}
export interface vkGetPipelineCacheDataInputWithInstance {
  device: uint64_t | Membuf;
  pipelineCache: uint64_t | Membuf;
  pDataSize: size_t| null | Membuf;
  pData?: uint64_t[] | null | Membuf[] | Membuf;
}

const vkGetPipelineCacheDataParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pipelineCache":{"simple":"uint64_t","isPointer":false},"pDataSize":{"simple":"size_t","isPointer":true},"pData":{"simple":"uint64_t","isPointer":true}} as const;
export const vkGetPipelineCacheData = (input: vkGetPipelineCacheDataInputWithDevice | vkGetPipelineCacheDataInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPipelineCacheDataParamsTypes[e[0] as keyof typeof vkGetPipelineCacheDataParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPipelineCacheData(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkMergePipelineCachesInputWithDevice {
  device: uint64_t | Membuf;
  dstCache: uint64_t | Membuf;
  srcCacheCount: uint32_t | number | Membuf;
  pSrcCaches: uint64_t[] | null | Membuf[] | Membuf;
}
export interface vkMergePipelineCachesInputWithInstance {
  device: uint64_t | Membuf;
  dstCache: uint64_t | Membuf;
  srcCacheCount: uint32_t | number | Membuf;
  pSrcCaches: uint64_t[] | null | Membuf[] | Membuf;
}

const vkMergePipelineCachesParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"dstCache":{"simple":"uint64_t","isPointer":false},"srcCacheCount":{"simple":"uint32_t","isPointer":false},"pSrcCaches":{"simple":"uint64_t","isPointer":true}} as const;
export const vkMergePipelineCaches = (input: vkMergePipelineCachesInputWithDevice | vkMergePipelineCachesInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkMergePipelineCachesParamsTypes[e[0] as keyof typeof vkMergePipelineCachesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkMergePipelineCaches(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateGraphicsPipelinesInputWithDevice {
  device: uint64_t | Membuf;
  pipelineCache: uint64_t | nullptr_t | Membuf;
  createInfoCount: uint32_t | number | Membuf;
  pCreateInfos: VkGraphicsPipelineCreateInfo[] | null | Membuf[] | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pPipelines: uint64_t[] | null | Membuf[] | Membuf;
}
export interface vkCreateGraphicsPipelinesInputWithInstance {
  device: uint64_t | Membuf;
  pipelineCache: uint64_t | nullptr_t | Membuf;
  createInfoCount: uint32_t | number | Membuf;
  pCreateInfos: VkGraphicsPipelineCreateInfo[] | null | Membuf[] | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pPipelines: uint64_t[] | null | Membuf[] | Membuf;
}

const vkCreateGraphicsPipelinesParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pipelineCache":{"simple":"uint64_t","isPointer":false},"createInfoCount":{"simple":"uint32_t","isPointer":false},"pCreateInfos":{"simple":"VkGraphicsPipelineCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pPipelines":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateGraphicsPipelines = (input: vkCreateGraphicsPipelinesInputWithDevice | vkCreateGraphicsPipelinesInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_INVALID_SHADER_NV => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateGraphicsPipelinesParamsTypes[e[0] as keyof typeof vkCreateGraphicsPipelinesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateGraphicsPipelines(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateComputePipelinesInputWithDevice {
  device: uint64_t | Membuf;
  pipelineCache: uint64_t | nullptr_t | Membuf;
  createInfoCount: uint32_t | number | Membuf;
  pCreateInfos: VkComputePipelineCreateInfo[] | null | Membuf[] | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pPipelines: uint64_t[] | null | Membuf[] | Membuf;
}
export interface vkCreateComputePipelinesInputWithInstance {
  device: uint64_t | Membuf;
  pipelineCache: uint64_t | nullptr_t | Membuf;
  createInfoCount: uint32_t | number | Membuf;
  pCreateInfos: VkComputePipelineCreateInfo[] | null | Membuf[] | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pPipelines: uint64_t[] | null | Membuf[] | Membuf;
}

const vkCreateComputePipelinesParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pipelineCache":{"simple":"uint64_t","isPointer":false},"createInfoCount":{"simple":"uint32_t","isPointer":false},"pCreateInfos":{"simple":"VkComputePipelineCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pPipelines":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateComputePipelines = (input: vkCreateComputePipelinesInputWithDevice | vkCreateComputePipelinesInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_INVALID_SHADER_NV => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateComputePipelinesParamsTypes[e[0] as keyof typeof vkCreateComputePipelinesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateComputePipelines(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyPipelineInputWithDevice {
  device: uint64_t | Membuf;
  pipeline: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyPipelineInputWithInstance {
  device: uint64_t | Membuf;
  pipeline: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyPipelineParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pipeline":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyPipeline = (input: vkDestroyPipelineInputWithDevice | vkDestroyPipelineInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyPipelineParamsTypes[e[0] as keyof typeof vkDestroyPipelineParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyPipeline(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreatePipelineLayoutInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkPipelineLayoutCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pPipelineLayout: uint64_t| null | Membuf;
}
export interface vkCreatePipelineLayoutInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkPipelineLayoutCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pPipelineLayout: uint64_t| null | Membuf;
}

const vkCreatePipelineLayoutParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkPipelineLayoutCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pPipelineLayout":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreatePipelineLayout = (input: vkCreatePipelineLayoutInputWithDevice | vkCreatePipelineLayoutInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreatePipelineLayoutParamsTypes[e[0] as keyof typeof vkCreatePipelineLayoutParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreatePipelineLayout(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyPipelineLayoutInputWithDevice {
  device: uint64_t | Membuf;
  pipelineLayout: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyPipelineLayoutInputWithInstance {
  device: uint64_t | Membuf;
  pipelineLayout: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyPipelineLayoutParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pipelineLayout":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyPipelineLayout = (input: vkDestroyPipelineLayoutInputWithDevice | vkDestroyPipelineLayoutInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyPipelineLayoutParamsTypes[e[0] as keyof typeof vkDestroyPipelineLayoutParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyPipelineLayout(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateSamplerInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkSamplerCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pSampler: uint64_t| null | Membuf;
}
export interface vkCreateSamplerInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkSamplerCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pSampler: uint64_t| null | Membuf;
}

const vkCreateSamplerParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkSamplerCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pSampler":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateSampler = (input: vkCreateSamplerInputWithDevice | vkCreateSamplerInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateSamplerParamsTypes[e[0] as keyof typeof vkCreateSamplerParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateSampler(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroySamplerInputWithDevice {
  device: uint64_t | Membuf;
  sampler: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroySamplerInputWithInstance {
  device: uint64_t | Membuf;
  sampler: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroySamplerParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"sampler":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroySampler = (input: vkDestroySamplerInputWithDevice | vkDestroySamplerInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroySamplerParamsTypes[e[0] as keyof typeof vkDestroySamplerParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroySampler(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateDescriptorSetLayoutInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkDescriptorSetLayoutCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pSetLayout: uint64_t| null | Membuf;
}
export interface vkCreateDescriptorSetLayoutInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkDescriptorSetLayoutCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pSetLayout: uint64_t| null | Membuf;
}

const vkCreateDescriptorSetLayoutParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkDescriptorSetLayoutCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pSetLayout":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateDescriptorSetLayout = (input: vkCreateDescriptorSetLayoutInputWithDevice | vkCreateDescriptorSetLayoutInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateDescriptorSetLayoutParamsTypes[e[0] as keyof typeof vkCreateDescriptorSetLayoutParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateDescriptorSetLayout(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyDescriptorSetLayoutInputWithDevice {
  device: uint64_t | Membuf;
  descriptorSetLayout: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyDescriptorSetLayoutInputWithInstance {
  device: uint64_t | Membuf;
  descriptorSetLayout: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyDescriptorSetLayoutParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"descriptorSetLayout":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyDescriptorSetLayout = (input: vkDestroyDescriptorSetLayoutInputWithDevice | vkDestroyDescriptorSetLayoutInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyDescriptorSetLayoutParamsTypes[e[0] as keyof typeof vkDestroyDescriptorSetLayoutParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyDescriptorSetLayout(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateDescriptorPoolInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkDescriptorPoolCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pDescriptorPool: uint64_t| null | Membuf;
}
export interface vkCreateDescriptorPoolInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkDescriptorPoolCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pDescriptorPool: uint64_t| null | Membuf;
}

const vkCreateDescriptorPoolParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkDescriptorPoolCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pDescriptorPool":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateDescriptorPool = (input: vkCreateDescriptorPoolInputWithDevice | vkCreateDescriptorPoolInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateDescriptorPoolParamsTypes[e[0] as keyof typeof vkCreateDescriptorPoolParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateDescriptorPool(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyDescriptorPoolInputWithDevice {
  device: uint64_t | Membuf;
  descriptorPool: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyDescriptorPoolInputWithInstance {
  device: uint64_t | Membuf;
  descriptorPool: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyDescriptorPoolParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"descriptorPool":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyDescriptorPool = (input: vkDestroyDescriptorPoolInputWithDevice | vkDestroyDescriptorPoolInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyDescriptorPoolParamsTypes[e[0] as keyof typeof vkDestroyDescriptorPoolParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyDescriptorPool(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkResetDescriptorPoolInputWithDevice {
  device: uint64_t | Membuf;
  descriptorPool: uint64_t | Membuf;
  flags: int32_t | nullptr_t | number | Membuf;
}
export interface vkResetDescriptorPoolInputWithInstance {
  device: uint64_t | Membuf;
  descriptorPool: uint64_t | Membuf;
  flags: int32_t | nullptr_t | number | Membuf;
}

const vkResetDescriptorPoolParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"descriptorPool":{"simple":"uint64_t","isPointer":false},"flags":{"simple":"int32_t","isPointer":false}} as const;
export const vkResetDescriptorPool = (input: vkResetDescriptorPoolInputWithDevice | vkResetDescriptorPoolInputWithInstance): VkResult.VK_SUCCESS => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkResetDescriptorPoolParamsTypes[e[0] as keyof typeof vkResetDescriptorPoolParamsTypes])];
    }));
    const result = vsnative.vts_native_vkResetDescriptorPool(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkAllocateDescriptorSetsInputWithDevice {
  device: uint64_t | Membuf;
  pAllocateInfo: VkDescriptorSetAllocateInfo| null | Membuf;
  pDescriptorSets: uint64_t[] | null | Membuf[] | Membuf;
}
export interface vkAllocateDescriptorSetsInputWithInstance {
  device: uint64_t | Membuf;
  pAllocateInfo: VkDescriptorSetAllocateInfo| null | Membuf;
  pDescriptorSets: uint64_t[] | null | Membuf[] | Membuf;
}

const vkAllocateDescriptorSetsParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pAllocateInfo":{"simple":"VkDescriptorSetAllocateInfo","isPointer":true},"pDescriptorSets":{"simple":"uint64_t","isPointer":true}} as const;
export const vkAllocateDescriptorSets = (input: vkAllocateDescriptorSetsInputWithDevice | vkAllocateDescriptorSetsInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_FRAGMENTED_POOL | VkResult.VK_ERROR_OUT_OF_POOL_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkAllocateDescriptorSetsParamsTypes[e[0] as keyof typeof vkAllocateDescriptorSetsParamsTypes])];
    }));
    const result = vsnative.vts_native_vkAllocateDescriptorSets(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkFreeDescriptorSetsInputWithDevice {
  device: uint64_t | Membuf;
  descriptorPool: uint64_t | Membuf;
  descriptorSetCount: uint32_t | number | Membuf;
  pDescriptorSets: uint64_t[] | null | Membuf[] | Membuf;
}
export interface vkFreeDescriptorSetsInputWithInstance {
  device: uint64_t | Membuf;
  descriptorPool: uint64_t | Membuf;
  descriptorSetCount: uint32_t | number | Membuf;
  pDescriptorSets: uint64_t[] | null | Membuf[] | Membuf;
}

const vkFreeDescriptorSetsParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"descriptorPool":{"simple":"uint64_t","isPointer":false},"descriptorSetCount":{"simple":"uint32_t","isPointer":false},"pDescriptorSets":{"simple":"uint64_t","isPointer":true}} as const;
export const vkFreeDescriptorSets = (input: vkFreeDescriptorSetsInputWithDevice | vkFreeDescriptorSetsInputWithInstance): VkResult.VK_SUCCESS => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkFreeDescriptorSetsParamsTypes[e[0] as keyof typeof vkFreeDescriptorSetsParamsTypes])];
    }));
    const result = vsnative.vts_native_vkFreeDescriptorSets(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkUpdateDescriptorSetsInputWithDevice {
  device: uint64_t | Membuf;
  descriptorWriteCount: uint32_t | nullptr_t | number | Membuf;
  pDescriptorWrites: VkWriteDescriptorSet[] | null | Membuf[] | Membuf;
  descriptorCopyCount: uint32_t | nullptr_t | number | Membuf;
  pDescriptorCopies: VkCopyDescriptorSet[] | null | Membuf[] | Membuf;
}
export interface vkUpdateDescriptorSetsInputWithInstance {
  device: uint64_t | Membuf;
  descriptorWriteCount: uint32_t | nullptr_t | number | Membuf;
  pDescriptorWrites: VkWriteDescriptorSet[] | null | Membuf[] | Membuf;
  descriptorCopyCount: uint32_t | nullptr_t | number | Membuf;
  pDescriptorCopies: VkCopyDescriptorSet[] | null | Membuf[] | Membuf;
}

const vkUpdateDescriptorSetsParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"descriptorWriteCount":{"simple":"uint32_t","isPointer":false},"pDescriptorWrites":{"simple":"VkWriteDescriptorSet","isPointer":true},"descriptorCopyCount":{"simple":"uint32_t","isPointer":false},"pDescriptorCopies":{"simple":"VkCopyDescriptorSet","isPointer":true}} as const;
export const vkUpdateDescriptorSets = (input: vkUpdateDescriptorSetsInputWithDevice | vkUpdateDescriptorSetsInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkUpdateDescriptorSetsParamsTypes[e[0] as keyof typeof vkUpdateDescriptorSetsParamsTypes])];
    }));
    const result = vsnative.vts_native_vkUpdateDescriptorSets(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateFramebufferInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkFramebufferCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pFramebuffer: uint64_t| null | Membuf;
}
export interface vkCreateFramebufferInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkFramebufferCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pFramebuffer: uint64_t| null | Membuf;
}

const vkCreateFramebufferParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkFramebufferCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pFramebuffer":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateFramebuffer = (input: vkCreateFramebufferInputWithDevice | vkCreateFramebufferInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateFramebufferParamsTypes[e[0] as keyof typeof vkCreateFramebufferParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateFramebuffer(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyFramebufferInputWithDevice {
  device: uint64_t | Membuf;
  framebuffer: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyFramebufferInputWithInstance {
  device: uint64_t | Membuf;
  framebuffer: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyFramebufferParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"framebuffer":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyFramebuffer = (input: vkDestroyFramebufferInputWithDevice | vkDestroyFramebufferInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyFramebufferParamsTypes[e[0] as keyof typeof vkDestroyFramebufferParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyFramebuffer(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateRenderPassInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkRenderPassCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pRenderPass: uint64_t| null | Membuf;
}
export interface vkCreateRenderPassInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkRenderPassCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pRenderPass: uint64_t| null | Membuf;
}

const vkCreateRenderPassParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkRenderPassCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pRenderPass":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateRenderPass = (input: vkCreateRenderPassInputWithDevice | vkCreateRenderPassInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateRenderPassParamsTypes[e[0] as keyof typeof vkCreateRenderPassParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateRenderPass(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyRenderPassInputWithDevice {
  device: uint64_t | Membuf;
  renderPass: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyRenderPassInputWithInstance {
  device: uint64_t | Membuf;
  renderPass: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyRenderPassParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"renderPass":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyRenderPass = (input: vkDestroyRenderPassInputWithDevice | vkDestroyRenderPassInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyRenderPassParamsTypes[e[0] as keyof typeof vkDestroyRenderPassParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyRenderPass(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetRenderAreaGranularityInputWithDevice {
  device: uint64_t | Membuf;
  renderPass: uint64_t | Membuf;
  pGranularity: VkExtent2D| null | Membuf;
}
export interface vkGetRenderAreaGranularityInputWithInstance {
  device: uint64_t | Membuf;
  renderPass: uint64_t | Membuf;
  pGranularity: VkExtent2D| null | Membuf;
}

const vkGetRenderAreaGranularityParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"renderPass":{"simple":"uint64_t","isPointer":false},"pGranularity":{"simple":"VkExtent2D","isPointer":true}} as const;
export const vkGetRenderAreaGranularity = (input: vkGetRenderAreaGranularityInputWithDevice | vkGetRenderAreaGranularityInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetRenderAreaGranularityParamsTypes[e[0] as keyof typeof vkGetRenderAreaGranularityParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetRenderAreaGranularity(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateCommandPoolInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkCommandPoolCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pCommandPool: uint64_t| null | Membuf;
}
export interface vkCreateCommandPoolInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkCommandPoolCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pCommandPool: uint64_t| null | Membuf;
}

const vkCreateCommandPoolParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkCommandPoolCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pCommandPool":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateCommandPool = (input: vkCreateCommandPoolInputWithDevice | vkCreateCommandPoolInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateCommandPoolParamsTypes[e[0] as keyof typeof vkCreateCommandPoolParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateCommandPool(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyCommandPoolInputWithDevice {
  device: uint64_t | Membuf;
  commandPool: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyCommandPoolInputWithInstance {
  device: uint64_t | Membuf;
  commandPool: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyCommandPoolParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"commandPool":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyCommandPool = (input: vkDestroyCommandPoolInputWithDevice | vkDestroyCommandPoolInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyCommandPoolParamsTypes[e[0] as keyof typeof vkDestroyCommandPoolParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyCommandPool(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkResetCommandPoolInputWithDevice {
  device: uint64_t | Membuf;
  commandPool: uint64_t | Membuf;
  flags: uint32_t | nullptr_t | number | Membuf;
}
export interface vkResetCommandPoolInputWithInstance {
  device: uint64_t | Membuf;
  commandPool: uint64_t | Membuf;
  flags: uint32_t | nullptr_t | number | Membuf;
}

const vkResetCommandPoolParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"commandPool":{"simple":"uint64_t","isPointer":false},"flags":{"simple":"uint32_t","isPointer":false}} as const;
export const vkResetCommandPool = (input: vkResetCommandPoolInputWithDevice | vkResetCommandPoolInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkResetCommandPoolParamsTypes[e[0] as keyof typeof vkResetCommandPoolParamsTypes])];
    }));
    const result = vsnative.vts_native_vkResetCommandPool(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkAllocateCommandBuffersInputWithDevice {
  device: uint64_t | Membuf;
  pAllocateInfo: VkCommandBufferAllocateInfo| null | Membuf;
  pCommandBuffers: uint64_t[] | null | Membuf[] | Membuf;
}
export interface vkAllocateCommandBuffersInputWithInstance {
  device: uint64_t | Membuf;
  pAllocateInfo: VkCommandBufferAllocateInfo| null | Membuf;
  pCommandBuffers: uint64_t[] | null | Membuf[] | Membuf;
}

const vkAllocateCommandBuffersParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pAllocateInfo":{"simple":"VkCommandBufferAllocateInfo","isPointer":true},"pCommandBuffers":{"simple":"uint64_t","isPointer":true}} as const;
export const vkAllocateCommandBuffers = (input: vkAllocateCommandBuffersInputWithDevice | vkAllocateCommandBuffersInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkAllocateCommandBuffersParamsTypes[e[0] as keyof typeof vkAllocateCommandBuffersParamsTypes])];
    }));
    const result = vsnative.vts_native_vkAllocateCommandBuffers(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkFreeCommandBuffersInputWithDevice {
  device: uint64_t | Membuf;
  commandPool: uint64_t | Membuf;
  commandBufferCount: uint32_t | number | Membuf;
  pCommandBuffers: uint64_t[] | null | Membuf[] | Membuf;
}
export interface vkFreeCommandBuffersInputWithInstance {
  device: uint64_t | Membuf;
  commandPool: uint64_t | Membuf;
  commandBufferCount: uint32_t | number | Membuf;
  pCommandBuffers: uint64_t[] | null | Membuf[] | Membuf;
}

const vkFreeCommandBuffersParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"commandPool":{"simple":"uint64_t","isPointer":false},"commandBufferCount":{"simple":"uint32_t","isPointer":false},"pCommandBuffers":{"simple":"uint64_t","isPointer":true}} as const;
export const vkFreeCommandBuffers = (input: vkFreeCommandBuffersInputWithDevice | vkFreeCommandBuffersInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkFreeCommandBuffersParamsTypes[e[0] as keyof typeof vkFreeCommandBuffersParamsTypes])];
    }));
    const result = vsnative.vts_native_vkFreeCommandBuffers(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkBeginCommandBufferInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pBeginInfo: VkCommandBufferBeginInfo| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkBeginCommandBufferInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pBeginInfo: VkCommandBufferBeginInfo| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkBeginCommandBufferParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pBeginInfo":{"simple":"VkCommandBufferBeginInfo","isPointer":true}} as const;
export const vkBeginCommandBuffer = (input: vkBeginCommandBufferInputWithDevice | vkBeginCommandBufferInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkBeginCommandBufferParamsTypes[e[0] as keyof typeof vkBeginCommandBufferParamsTypes])];
    }));
    const result = vsnative.vts_native_vkBeginCommandBuffer(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkEndCommandBufferInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  device: uint64_t | Membuf;
}
export interface vkEndCommandBufferInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  instance: uint64_t | Membuf;
}

const vkEndCommandBufferParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false}} as const;
export const vkEndCommandBuffer = (input: vkEndCommandBufferInputWithDevice | vkEndCommandBufferInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkEndCommandBufferParamsTypes[e[0] as keyof typeof vkEndCommandBufferParamsTypes])];
    }));
    const result = vsnative.vts_native_vkEndCommandBuffer(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkResetCommandBufferInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  flags: uint32_t | nullptr_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkResetCommandBufferInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  flags: uint32_t | nullptr_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkResetCommandBufferParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"flags":{"simple":"uint32_t","isPointer":false}} as const;
export const vkResetCommandBuffer = (input: vkResetCommandBufferInputWithDevice | vkResetCommandBufferInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkResetCommandBufferParamsTypes[e[0] as keyof typeof vkResetCommandBufferParamsTypes])];
    }));
    const result = vsnative.vts_native_vkResetCommandBuffer(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdBindPipelineInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pipelineBindPoint: int32_t | number | Membuf;
  pipeline: uint64_t | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdBindPipelineInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pipelineBindPoint: int32_t | number | Membuf;
  pipeline: uint64_t | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdBindPipelineParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pipelineBindPoint":{"simple":"int32_t","isPointer":false},"pipeline":{"simple":"uint64_t","isPointer":false}} as const;
export const vkCmdBindPipeline = (input: vkCmdBindPipelineInputWithDevice | vkCmdBindPipelineInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdBindPipelineParamsTypes[e[0] as keyof typeof vkCmdBindPipelineParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdBindPipeline(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetViewportInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  firstViewport: uint32_t | number | Membuf;
  viewportCount: uint32_t | number | Membuf;
  pViewports: VkViewport[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetViewportInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  firstViewport: uint32_t | number | Membuf;
  viewportCount: uint32_t | number | Membuf;
  pViewports: VkViewport[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetViewportParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"firstViewport":{"simple":"uint32_t","isPointer":false},"viewportCount":{"simple":"uint32_t","isPointer":false},"pViewports":{"simple":"VkViewport","isPointer":true}} as const;
export const vkCmdSetViewport = (input: vkCmdSetViewportInputWithDevice | vkCmdSetViewportInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetViewportParamsTypes[e[0] as keyof typeof vkCmdSetViewportParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetViewport(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetScissorInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  firstScissor: uint32_t | number | Membuf;
  scissorCount: uint32_t | number | Membuf;
  pScissors: VkRect2D[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetScissorInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  firstScissor: uint32_t | number | Membuf;
  scissorCount: uint32_t | number | Membuf;
  pScissors: VkRect2D[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetScissorParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"firstScissor":{"simple":"uint32_t","isPointer":false},"scissorCount":{"simple":"uint32_t","isPointer":false},"pScissors":{"simple":"VkRect2D","isPointer":true}} as const;
export const vkCmdSetScissor = (input: vkCmdSetScissorInputWithDevice | vkCmdSetScissorInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetScissorParamsTypes[e[0] as keyof typeof vkCmdSetScissorParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetScissor(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetLineWidthInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  lineWidth: float | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetLineWidthInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  lineWidth: float | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetLineWidthParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"lineWidth":{"simple":"float","isPointer":false}} as const;
export const vkCmdSetLineWidth = (input: vkCmdSetLineWidthInputWithDevice | vkCmdSetLineWidthInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetLineWidthParamsTypes[e[0] as keyof typeof vkCmdSetLineWidthParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetLineWidth(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetDepthBiasInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  depthBiasConstantFactor: float | number | Membuf;
  depthBiasClamp: float | number | Membuf;
  depthBiasSlopeFactor: float | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetDepthBiasInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  depthBiasConstantFactor: float | number | Membuf;
  depthBiasClamp: float | number | Membuf;
  depthBiasSlopeFactor: float | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetDepthBiasParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"depthBiasConstantFactor":{"simple":"float","isPointer":false},"depthBiasClamp":{"simple":"float","isPointer":false},"depthBiasSlopeFactor":{"simple":"float","isPointer":false}} as const;
export const vkCmdSetDepthBias = (input: vkCmdSetDepthBiasInputWithDevice | vkCmdSetDepthBiasInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetDepthBiasParamsTypes[e[0] as keyof typeof vkCmdSetDepthBiasParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetDepthBias(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetBlendConstantsInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  blendConstants: float[] | null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetBlendConstantsInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  blendConstants: float[] | null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetBlendConstantsParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"blendConstants":{"simple":"float","isPointer":false}} as const;
export const vkCmdSetBlendConstants = (input: vkCmdSetBlendConstantsInputWithDevice | vkCmdSetBlendConstantsInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetBlendConstantsParamsTypes[e[0] as keyof typeof vkCmdSetBlendConstantsParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetBlendConstants(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetDepthBoundsInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  minDepthBounds: float | number | Membuf;
  maxDepthBounds: float | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetDepthBoundsInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  minDepthBounds: float | number | Membuf;
  maxDepthBounds: float | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetDepthBoundsParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"minDepthBounds":{"simple":"float","isPointer":false},"maxDepthBounds":{"simple":"float","isPointer":false}} as const;
export const vkCmdSetDepthBounds = (input: vkCmdSetDepthBoundsInputWithDevice | vkCmdSetDepthBoundsInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetDepthBoundsParamsTypes[e[0] as keyof typeof vkCmdSetDepthBoundsParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetDepthBounds(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetStencilCompareMaskInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  faceMask: uint32_t | number | Membuf;
  compareMask: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetStencilCompareMaskInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  faceMask: uint32_t | number | Membuf;
  compareMask: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetStencilCompareMaskParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"faceMask":{"simple":"uint32_t","isPointer":false},"compareMask":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdSetStencilCompareMask = (input: vkCmdSetStencilCompareMaskInputWithDevice | vkCmdSetStencilCompareMaskInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetStencilCompareMaskParamsTypes[e[0] as keyof typeof vkCmdSetStencilCompareMaskParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetStencilCompareMask(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetStencilWriteMaskInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  faceMask: uint32_t | number | Membuf;
  writeMask: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetStencilWriteMaskInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  faceMask: uint32_t | number | Membuf;
  writeMask: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetStencilWriteMaskParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"faceMask":{"simple":"uint32_t","isPointer":false},"writeMask":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdSetStencilWriteMask = (input: vkCmdSetStencilWriteMaskInputWithDevice | vkCmdSetStencilWriteMaskInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetStencilWriteMaskParamsTypes[e[0] as keyof typeof vkCmdSetStencilWriteMaskParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetStencilWriteMask(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetStencilReferenceInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  faceMask: uint32_t | number | Membuf;
  reference: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetStencilReferenceInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  faceMask: uint32_t | number | Membuf;
  reference: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetStencilReferenceParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"faceMask":{"simple":"uint32_t","isPointer":false},"reference":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdSetStencilReference = (input: vkCmdSetStencilReferenceInputWithDevice | vkCmdSetStencilReferenceInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetStencilReferenceParamsTypes[e[0] as keyof typeof vkCmdSetStencilReferenceParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetStencilReference(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdBindDescriptorSetsInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pipelineBindPoint: int32_t | number | Membuf;
  layout: uint64_t | Membuf;
  firstSet: uint32_t | number | Membuf;
  descriptorSetCount: uint32_t | number | Membuf;
  pDescriptorSets: uint64_t[] | null | Membuf[] | Membuf;
  dynamicOffsetCount: uint32_t | nullptr_t | number | Membuf;
  pDynamicOffsets: uint32_t[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdBindDescriptorSetsInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pipelineBindPoint: int32_t | number | Membuf;
  layout: uint64_t | Membuf;
  firstSet: uint32_t | number | Membuf;
  descriptorSetCount: uint32_t | number | Membuf;
  pDescriptorSets: uint64_t[] | null | Membuf[] | Membuf;
  dynamicOffsetCount: uint32_t | nullptr_t | number | Membuf;
  pDynamicOffsets: uint32_t[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdBindDescriptorSetsParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pipelineBindPoint":{"simple":"int32_t","isPointer":false},"layout":{"simple":"uint64_t","isPointer":false},"firstSet":{"simple":"uint32_t","isPointer":false},"descriptorSetCount":{"simple":"uint32_t","isPointer":false},"pDescriptorSets":{"simple":"uint64_t","isPointer":true},"dynamicOffsetCount":{"simple":"uint32_t","isPointer":false},"pDynamicOffsets":{"simple":"uint32_t","isPointer":true}} as const;
export const vkCmdBindDescriptorSets = (input: vkCmdBindDescriptorSetsInputWithDevice | vkCmdBindDescriptorSetsInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdBindDescriptorSetsParamsTypes[e[0] as keyof typeof vkCmdBindDescriptorSetsParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdBindDescriptorSets(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdBindIndexBufferInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  offset: uint64_t | number | Membuf;
  indexType: int32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdBindIndexBufferInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  offset: uint64_t | number | Membuf;
  indexType: int32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdBindIndexBufferParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"buffer":{"simple":"uint64_t","isPointer":false},"offset":{"simple":"uint64_t","isPointer":false},"indexType":{"simple":"int32_t","isPointer":false}} as const;
export const vkCmdBindIndexBuffer = (input: vkCmdBindIndexBufferInputWithDevice | vkCmdBindIndexBufferInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdBindIndexBufferParamsTypes[e[0] as keyof typeof vkCmdBindIndexBufferParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdBindIndexBuffer(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdBindVertexBuffersInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  firstBinding: uint32_t | number | Membuf;
  bindingCount: uint32_t | number | Membuf;
  pBuffers: uint64_t[] | null | Membuf[] | Membuf;
  pOffsets: uint64_t[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdBindVertexBuffersInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  firstBinding: uint32_t | number | Membuf;
  bindingCount: uint32_t | number | Membuf;
  pBuffers: uint64_t[] | null | Membuf[] | Membuf;
  pOffsets: uint64_t[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdBindVertexBuffersParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"firstBinding":{"simple":"uint32_t","isPointer":false},"bindingCount":{"simple":"uint32_t","isPointer":false},"pBuffers":{"simple":"uint64_t","isPointer":true},"pOffsets":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCmdBindVertexBuffers = (input: vkCmdBindVertexBuffersInputWithDevice | vkCmdBindVertexBuffersInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdBindVertexBuffersParamsTypes[e[0] as keyof typeof vkCmdBindVertexBuffersParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdBindVertexBuffers(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdDrawInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  vertexCount: uint32_t | number | Membuf;
  instanceCount: uint32_t | number | Membuf;
  firstVertex: uint32_t | number | Membuf;
  firstInstance: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdDrawInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  vertexCount: uint32_t | number | Membuf;
  instanceCount: uint32_t | number | Membuf;
  firstVertex: uint32_t | number | Membuf;
  firstInstance: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdDrawParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"vertexCount":{"simple":"uint32_t","isPointer":false},"instanceCount":{"simple":"uint32_t","isPointer":false},"firstVertex":{"simple":"uint32_t","isPointer":false},"firstInstance":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdDraw = (input: vkCmdDrawInputWithDevice | vkCmdDrawInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdDrawParamsTypes[e[0] as keyof typeof vkCmdDrawParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdDraw(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdDrawIndexedInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  indexCount: uint32_t | number | Membuf;
  instanceCount: uint32_t | number | Membuf;
  firstIndex: uint32_t | number | Membuf;
  vertexOffset: int32_t | number | Membuf;
  firstInstance: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdDrawIndexedInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  indexCount: uint32_t | number | Membuf;
  instanceCount: uint32_t | number | Membuf;
  firstIndex: uint32_t | number | Membuf;
  vertexOffset: int32_t | number | Membuf;
  firstInstance: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdDrawIndexedParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"indexCount":{"simple":"uint32_t","isPointer":false},"instanceCount":{"simple":"uint32_t","isPointer":false},"firstIndex":{"simple":"uint32_t","isPointer":false},"vertexOffset":{"simple":"int32_t","isPointer":false},"firstInstance":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdDrawIndexed = (input: vkCmdDrawIndexedInputWithDevice | vkCmdDrawIndexedInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdDrawIndexedParamsTypes[e[0] as keyof typeof vkCmdDrawIndexedParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdDrawIndexed(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdDrawMultiEXTInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  drawCount: uint32_t | nullptr_t | number | Membuf;
  pVertexInfo: VkMultiDrawInfoEXT[] | null | Membuf[] | Membuf;
  instanceCount: uint32_t | number | Membuf;
  firstInstance: uint32_t | number | Membuf;
  stride: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdDrawMultiEXTInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  drawCount: uint32_t | nullptr_t | number | Membuf;
  pVertexInfo: VkMultiDrawInfoEXT[] | null | Membuf[] | Membuf;
  instanceCount: uint32_t | number | Membuf;
  firstInstance: uint32_t | number | Membuf;
  stride: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdDrawMultiEXTParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"drawCount":{"simple":"uint32_t","isPointer":false},"pVertexInfo":{"simple":"VkMultiDrawInfoEXT","isPointer":true},"instanceCount":{"simple":"uint32_t","isPointer":false},"firstInstance":{"simple":"uint32_t","isPointer":false},"stride":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdDrawMultiEXT = (input: vkCmdDrawMultiEXTInputWithDevice | vkCmdDrawMultiEXTInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdDrawMultiEXTParamsTypes[e[0] as keyof typeof vkCmdDrawMultiEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdDrawMultiEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdDrawMultiIndexedEXTInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  drawCount: uint32_t | nullptr_t | number | Membuf;
  pIndexInfo: VkMultiDrawIndexedInfoEXT[] | null | Membuf[] | Membuf;
  instanceCount: uint32_t | number | Membuf;
  firstInstance: uint32_t | number | Membuf;
  stride: uint32_t | number | Membuf;
  pVertexOffset?: int32_t| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdDrawMultiIndexedEXTInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  drawCount: uint32_t | nullptr_t | number | Membuf;
  pIndexInfo: VkMultiDrawIndexedInfoEXT[] | null | Membuf[] | Membuf;
  instanceCount: uint32_t | number | Membuf;
  firstInstance: uint32_t | number | Membuf;
  stride: uint32_t | number | Membuf;
  pVertexOffset?: int32_t| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdDrawMultiIndexedEXTParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"drawCount":{"simple":"uint32_t","isPointer":false},"pIndexInfo":{"simple":"VkMultiDrawIndexedInfoEXT","isPointer":true},"instanceCount":{"simple":"uint32_t","isPointer":false},"firstInstance":{"simple":"uint32_t","isPointer":false},"stride":{"simple":"uint32_t","isPointer":false},"pVertexOffset":{"simple":"int32_t","isPointer":true}} as const;
export const vkCmdDrawMultiIndexedEXT = (input: vkCmdDrawMultiIndexedEXTInputWithDevice | vkCmdDrawMultiIndexedEXTInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdDrawMultiIndexedEXTParamsTypes[e[0] as keyof typeof vkCmdDrawMultiIndexedEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdDrawMultiIndexedEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdDrawIndirectInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  offset: uint64_t | number | Membuf;
  drawCount: uint32_t | number | Membuf;
  stride: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdDrawIndirectInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  offset: uint64_t | number | Membuf;
  drawCount: uint32_t | number | Membuf;
  stride: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdDrawIndirectParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"buffer":{"simple":"uint64_t","isPointer":false},"offset":{"simple":"uint64_t","isPointer":false},"drawCount":{"simple":"uint32_t","isPointer":false},"stride":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdDrawIndirect = (input: vkCmdDrawIndirectInputWithDevice | vkCmdDrawIndirectInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdDrawIndirectParamsTypes[e[0] as keyof typeof vkCmdDrawIndirectParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdDrawIndirect(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdDrawIndexedIndirectInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  offset: uint64_t | number | Membuf;
  drawCount: uint32_t | number | Membuf;
  stride: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdDrawIndexedIndirectInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  offset: uint64_t | number | Membuf;
  drawCount: uint32_t | number | Membuf;
  stride: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdDrawIndexedIndirectParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"buffer":{"simple":"uint64_t","isPointer":false},"offset":{"simple":"uint64_t","isPointer":false},"drawCount":{"simple":"uint32_t","isPointer":false},"stride":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdDrawIndexedIndirect = (input: vkCmdDrawIndexedIndirectInputWithDevice | vkCmdDrawIndexedIndirectInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdDrawIndexedIndirectParamsTypes[e[0] as keyof typeof vkCmdDrawIndexedIndirectParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdDrawIndexedIndirect(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdDispatchInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  groupCountX: uint32_t | number | Membuf;
  groupCountY: uint32_t | number | Membuf;
  groupCountZ: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdDispatchInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  groupCountX: uint32_t | number | Membuf;
  groupCountY: uint32_t | number | Membuf;
  groupCountZ: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdDispatchParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"groupCountX":{"simple":"uint32_t","isPointer":false},"groupCountY":{"simple":"uint32_t","isPointer":false},"groupCountZ":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdDispatch = (input: vkCmdDispatchInputWithDevice | vkCmdDispatchInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdDispatchParamsTypes[e[0] as keyof typeof vkCmdDispatchParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdDispatch(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdDispatchIndirectInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  offset: uint64_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdDispatchIndirectInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  offset: uint64_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdDispatchIndirectParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"buffer":{"simple":"uint64_t","isPointer":false},"offset":{"simple":"uint64_t","isPointer":false}} as const;
export const vkCmdDispatchIndirect = (input: vkCmdDispatchIndirectInputWithDevice | vkCmdDispatchIndirectInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdDispatchIndirectParamsTypes[e[0] as keyof typeof vkCmdDispatchIndirectParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdDispatchIndirect(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdCopyBufferInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  srcBuffer: uint64_t | Membuf;
  dstBuffer: uint64_t | Membuf;
  regionCount: uint32_t | number | Membuf;
  pRegions: VkBufferCopy[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdCopyBufferInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  srcBuffer: uint64_t | Membuf;
  dstBuffer: uint64_t | Membuf;
  regionCount: uint32_t | number | Membuf;
  pRegions: VkBufferCopy[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdCopyBufferParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"srcBuffer":{"simple":"uint64_t","isPointer":false},"dstBuffer":{"simple":"uint64_t","isPointer":false},"regionCount":{"simple":"uint32_t","isPointer":false},"pRegions":{"simple":"VkBufferCopy","isPointer":true}} as const;
export const vkCmdCopyBuffer = (input: vkCmdCopyBufferInputWithDevice | vkCmdCopyBufferInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdCopyBufferParamsTypes[e[0] as keyof typeof vkCmdCopyBufferParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdCopyBuffer(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdCopyImageInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  srcImage: uint64_t | Membuf;
  srcImageLayout: int32_t | number | Membuf;
  dstImage: uint64_t | Membuf;
  dstImageLayout: int32_t | number | Membuf;
  regionCount: uint32_t | number | Membuf;
  pRegions: VkImageCopy[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdCopyImageInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  srcImage: uint64_t | Membuf;
  srcImageLayout: int32_t | number | Membuf;
  dstImage: uint64_t | Membuf;
  dstImageLayout: int32_t | number | Membuf;
  regionCount: uint32_t | number | Membuf;
  pRegions: VkImageCopy[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdCopyImageParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"srcImage":{"simple":"uint64_t","isPointer":false},"srcImageLayout":{"simple":"int32_t","isPointer":false},"dstImage":{"simple":"uint64_t","isPointer":false},"dstImageLayout":{"simple":"int32_t","isPointer":false},"regionCount":{"simple":"uint32_t","isPointer":false},"pRegions":{"simple":"VkImageCopy","isPointer":true}} as const;
export const vkCmdCopyImage = (input: vkCmdCopyImageInputWithDevice | vkCmdCopyImageInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdCopyImageParamsTypes[e[0] as keyof typeof vkCmdCopyImageParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdCopyImage(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdBlitImageInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  srcImage: uint64_t | Membuf;
  srcImageLayout: int32_t | number | Membuf;
  dstImage: uint64_t | Membuf;
  dstImageLayout: int32_t | number | Membuf;
  regionCount: uint32_t | number | Membuf;
  pRegions: VkImageBlit[] | null | Membuf[] | Membuf;
  filter: int32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdBlitImageInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  srcImage: uint64_t | Membuf;
  srcImageLayout: int32_t | number | Membuf;
  dstImage: uint64_t | Membuf;
  dstImageLayout: int32_t | number | Membuf;
  regionCount: uint32_t | number | Membuf;
  pRegions: VkImageBlit[] | null | Membuf[] | Membuf;
  filter: int32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdBlitImageParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"srcImage":{"simple":"uint64_t","isPointer":false},"srcImageLayout":{"simple":"int32_t","isPointer":false},"dstImage":{"simple":"uint64_t","isPointer":false},"dstImageLayout":{"simple":"int32_t","isPointer":false},"regionCount":{"simple":"uint32_t","isPointer":false},"pRegions":{"simple":"VkImageBlit","isPointer":true},"filter":{"simple":"int32_t","isPointer":false}} as const;
export const vkCmdBlitImage = (input: vkCmdBlitImageInputWithDevice | vkCmdBlitImageInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdBlitImageParamsTypes[e[0] as keyof typeof vkCmdBlitImageParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdBlitImage(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdCopyBufferToImageInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  srcBuffer: uint64_t | Membuf;
  dstImage: uint64_t | Membuf;
  dstImageLayout: int32_t | number | Membuf;
  regionCount: uint32_t | number | Membuf;
  pRegions: VkBufferImageCopy[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdCopyBufferToImageInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  srcBuffer: uint64_t | Membuf;
  dstImage: uint64_t | Membuf;
  dstImageLayout: int32_t | number | Membuf;
  regionCount: uint32_t | number | Membuf;
  pRegions: VkBufferImageCopy[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdCopyBufferToImageParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"srcBuffer":{"simple":"uint64_t","isPointer":false},"dstImage":{"simple":"uint64_t","isPointer":false},"dstImageLayout":{"simple":"int32_t","isPointer":false},"regionCount":{"simple":"uint32_t","isPointer":false},"pRegions":{"simple":"VkBufferImageCopy","isPointer":true}} as const;
export const vkCmdCopyBufferToImage = (input: vkCmdCopyBufferToImageInputWithDevice | vkCmdCopyBufferToImageInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdCopyBufferToImageParamsTypes[e[0] as keyof typeof vkCmdCopyBufferToImageParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdCopyBufferToImage(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdCopyImageToBufferInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  srcImage: uint64_t | Membuf;
  srcImageLayout: int32_t | number | Membuf;
  dstBuffer: uint64_t | Membuf;
  regionCount: uint32_t | number | Membuf;
  pRegions: VkBufferImageCopy[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdCopyImageToBufferInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  srcImage: uint64_t | Membuf;
  srcImageLayout: int32_t | number | Membuf;
  dstBuffer: uint64_t | Membuf;
  regionCount: uint32_t | number | Membuf;
  pRegions: VkBufferImageCopy[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdCopyImageToBufferParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"srcImage":{"simple":"uint64_t","isPointer":false},"srcImageLayout":{"simple":"int32_t","isPointer":false},"dstBuffer":{"simple":"uint64_t","isPointer":false},"regionCount":{"simple":"uint32_t","isPointer":false},"pRegions":{"simple":"VkBufferImageCopy","isPointer":true}} as const;
export const vkCmdCopyImageToBuffer = (input: vkCmdCopyImageToBufferInputWithDevice | vkCmdCopyImageToBufferInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdCopyImageToBufferParamsTypes[e[0] as keyof typeof vkCmdCopyImageToBufferParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdCopyImageToBuffer(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdUpdateBufferInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  dstBuffer: uint64_t | Membuf;
  dstOffset: uint64_t | number | Membuf;
  dataSize: uint64_t | number | Membuf;
  pData: uint64_t[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdUpdateBufferInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  dstBuffer: uint64_t | Membuf;
  dstOffset: uint64_t | number | Membuf;
  dataSize: uint64_t | number | Membuf;
  pData: uint64_t[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdUpdateBufferParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"dstBuffer":{"simple":"uint64_t","isPointer":false},"dstOffset":{"simple":"uint64_t","isPointer":false},"dataSize":{"simple":"uint64_t","isPointer":false},"pData":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCmdUpdateBuffer = (input: vkCmdUpdateBufferInputWithDevice | vkCmdUpdateBufferInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdUpdateBufferParamsTypes[e[0] as keyof typeof vkCmdUpdateBufferParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdUpdateBuffer(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdFillBufferInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  dstBuffer: uint64_t | Membuf;
  dstOffset: uint64_t | number | Membuf;
  size: uint64_t | number | Membuf;
  data: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdFillBufferInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  dstBuffer: uint64_t | Membuf;
  dstOffset: uint64_t | number | Membuf;
  size: uint64_t | number | Membuf;
  data: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdFillBufferParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"dstBuffer":{"simple":"uint64_t","isPointer":false},"dstOffset":{"simple":"uint64_t","isPointer":false},"size":{"simple":"uint64_t","isPointer":false},"data":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdFillBuffer = (input: vkCmdFillBufferInputWithDevice | vkCmdFillBufferInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdFillBufferParamsTypes[e[0] as keyof typeof vkCmdFillBufferParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdFillBuffer(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdClearColorImageInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  image: uint64_t | Membuf;
  imageLayout: int32_t | number | Membuf;
  pColor: VkClearColorValue| null | Membuf;
  rangeCount: uint32_t | number | Membuf;
  pRanges: VkImageSubresourceRange[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdClearColorImageInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  image: uint64_t | Membuf;
  imageLayout: int32_t | number | Membuf;
  pColor: VkClearColorValue| null | Membuf;
  rangeCount: uint32_t | number | Membuf;
  pRanges: VkImageSubresourceRange[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdClearColorImageParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"image":{"simple":"uint64_t","isPointer":false},"imageLayout":{"simple":"int32_t","isPointer":false},"pColor":{"simple":"VkClearColorValue","isPointer":true},"rangeCount":{"simple":"uint32_t","isPointer":false},"pRanges":{"simple":"VkImageSubresourceRange","isPointer":true}} as const;
export const vkCmdClearColorImage = (input: vkCmdClearColorImageInputWithDevice | vkCmdClearColorImageInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdClearColorImageParamsTypes[e[0] as keyof typeof vkCmdClearColorImageParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdClearColorImage(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdClearDepthStencilImageInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  image: uint64_t | Membuf;
  imageLayout: int32_t | number | Membuf;
  pDepthStencil: VkClearDepthStencilValue| null | Membuf;
  rangeCount: uint32_t | number | Membuf;
  pRanges: VkImageSubresourceRange[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdClearDepthStencilImageInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  image: uint64_t | Membuf;
  imageLayout: int32_t | number | Membuf;
  pDepthStencil: VkClearDepthStencilValue| null | Membuf;
  rangeCount: uint32_t | number | Membuf;
  pRanges: VkImageSubresourceRange[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdClearDepthStencilImageParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"image":{"simple":"uint64_t","isPointer":false},"imageLayout":{"simple":"int32_t","isPointer":false},"pDepthStencil":{"simple":"VkClearDepthStencilValue","isPointer":true},"rangeCount":{"simple":"uint32_t","isPointer":false},"pRanges":{"simple":"VkImageSubresourceRange","isPointer":true}} as const;
export const vkCmdClearDepthStencilImage = (input: vkCmdClearDepthStencilImageInputWithDevice | vkCmdClearDepthStencilImageInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdClearDepthStencilImageParamsTypes[e[0] as keyof typeof vkCmdClearDepthStencilImageParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdClearDepthStencilImage(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdClearAttachmentsInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  attachmentCount: uint32_t | number | Membuf;
  pAttachments: VkClearAttachment[] | null | Membuf[] | Membuf;
  rectCount: uint32_t | number | Membuf;
  pRects: VkClearRect[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdClearAttachmentsInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  attachmentCount: uint32_t | number | Membuf;
  pAttachments: VkClearAttachment[] | null | Membuf[] | Membuf;
  rectCount: uint32_t | number | Membuf;
  pRects: VkClearRect[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdClearAttachmentsParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"attachmentCount":{"simple":"uint32_t","isPointer":false},"pAttachments":{"simple":"VkClearAttachment","isPointer":true},"rectCount":{"simple":"uint32_t","isPointer":false},"pRects":{"simple":"VkClearRect","isPointer":true}} as const;
export const vkCmdClearAttachments = (input: vkCmdClearAttachmentsInputWithDevice | vkCmdClearAttachmentsInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdClearAttachmentsParamsTypes[e[0] as keyof typeof vkCmdClearAttachmentsParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdClearAttachments(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdResolveImageInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  srcImage: uint64_t | Membuf;
  srcImageLayout: int32_t | number | Membuf;
  dstImage: uint64_t | Membuf;
  dstImageLayout: int32_t | number | Membuf;
  regionCount: uint32_t | number | Membuf;
  pRegions: VkImageResolve[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdResolveImageInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  srcImage: uint64_t | Membuf;
  srcImageLayout: int32_t | number | Membuf;
  dstImage: uint64_t | Membuf;
  dstImageLayout: int32_t | number | Membuf;
  regionCount: uint32_t | number | Membuf;
  pRegions: VkImageResolve[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdResolveImageParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"srcImage":{"simple":"uint64_t","isPointer":false},"srcImageLayout":{"simple":"int32_t","isPointer":false},"dstImage":{"simple":"uint64_t","isPointer":false},"dstImageLayout":{"simple":"int32_t","isPointer":false},"regionCount":{"simple":"uint32_t","isPointer":false},"pRegions":{"simple":"VkImageResolve","isPointer":true}} as const;
export const vkCmdResolveImage = (input: vkCmdResolveImageInputWithDevice | vkCmdResolveImageInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdResolveImageParamsTypes[e[0] as keyof typeof vkCmdResolveImageParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdResolveImage(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetEventInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  event: uint64_t | Membuf;
  stageMask: uint32_t | nullptr_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetEventInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  event: uint64_t | Membuf;
  stageMask: uint32_t | nullptr_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetEventParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"event":{"simple":"uint64_t","isPointer":false},"stageMask":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdSetEvent = (input: vkCmdSetEventInputWithDevice | vkCmdSetEventInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetEventParamsTypes[e[0] as keyof typeof vkCmdSetEventParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetEvent(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdResetEventInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  event: uint64_t | Membuf;
  stageMask: uint32_t | nullptr_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdResetEventInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  event: uint64_t | Membuf;
  stageMask: uint32_t | nullptr_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdResetEventParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"event":{"simple":"uint64_t","isPointer":false},"stageMask":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdResetEvent = (input: vkCmdResetEventInputWithDevice | vkCmdResetEventInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdResetEventParamsTypes[e[0] as keyof typeof vkCmdResetEventParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdResetEvent(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdWaitEventsInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  eventCount: uint32_t | number | Membuf;
  pEvents: uint64_t[] | null | Membuf[] | Membuf;
  srcStageMask: uint32_t | nullptr_t | number | Membuf;
  dstStageMask: uint32_t | nullptr_t | number | Membuf;
  memoryBarrierCount: uint32_t | nullptr_t | number | Membuf;
  pMemoryBarriers: VkMemoryBarrier[] | null | Membuf[] | Membuf;
  bufferMemoryBarrierCount: uint32_t | nullptr_t | number | Membuf;
  pBufferMemoryBarriers: VkBufferMemoryBarrier[] | null | Membuf[] | Membuf;
  imageMemoryBarrierCount: uint32_t | nullptr_t | number | Membuf;
  pImageMemoryBarriers: VkImageMemoryBarrier[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdWaitEventsInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  eventCount: uint32_t | number | Membuf;
  pEvents: uint64_t[] | null | Membuf[] | Membuf;
  srcStageMask: uint32_t | nullptr_t | number | Membuf;
  dstStageMask: uint32_t | nullptr_t | number | Membuf;
  memoryBarrierCount: uint32_t | nullptr_t | number | Membuf;
  pMemoryBarriers: VkMemoryBarrier[] | null | Membuf[] | Membuf;
  bufferMemoryBarrierCount: uint32_t | nullptr_t | number | Membuf;
  pBufferMemoryBarriers: VkBufferMemoryBarrier[] | null | Membuf[] | Membuf;
  imageMemoryBarrierCount: uint32_t | nullptr_t | number | Membuf;
  pImageMemoryBarriers: VkImageMemoryBarrier[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdWaitEventsParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"eventCount":{"simple":"uint32_t","isPointer":false},"pEvents":{"simple":"uint64_t","isPointer":true},"srcStageMask":{"simple":"uint32_t","isPointer":false},"dstStageMask":{"simple":"uint32_t","isPointer":false},"memoryBarrierCount":{"simple":"uint32_t","isPointer":false},"pMemoryBarriers":{"simple":"VkMemoryBarrier","isPointer":true},"bufferMemoryBarrierCount":{"simple":"uint32_t","isPointer":false},"pBufferMemoryBarriers":{"simple":"VkBufferMemoryBarrier","isPointer":true},"imageMemoryBarrierCount":{"simple":"uint32_t","isPointer":false},"pImageMemoryBarriers":{"simple":"VkImageMemoryBarrier","isPointer":true}} as const;
export const vkCmdWaitEvents = (input: vkCmdWaitEventsInputWithDevice | vkCmdWaitEventsInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdWaitEventsParamsTypes[e[0] as keyof typeof vkCmdWaitEventsParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdWaitEvents(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdPipelineBarrierInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  srcStageMask: uint32_t | nullptr_t | number | Membuf;
  dstStageMask: uint32_t | nullptr_t | number | Membuf;
  dependencyFlags: uint32_t | nullptr_t | number | Membuf;
  memoryBarrierCount: uint32_t | nullptr_t | number | Membuf;
  pMemoryBarriers: VkMemoryBarrier[] | null | Membuf[] | Membuf;
  bufferMemoryBarrierCount: uint32_t | nullptr_t | number | Membuf;
  pBufferMemoryBarriers: VkBufferMemoryBarrier[] | null | Membuf[] | Membuf;
  imageMemoryBarrierCount: uint32_t | nullptr_t | number | Membuf;
  pImageMemoryBarriers: VkImageMemoryBarrier[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdPipelineBarrierInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  srcStageMask: uint32_t | nullptr_t | number | Membuf;
  dstStageMask: uint32_t | nullptr_t | number | Membuf;
  dependencyFlags: uint32_t | nullptr_t | number | Membuf;
  memoryBarrierCount: uint32_t | nullptr_t | number | Membuf;
  pMemoryBarriers: VkMemoryBarrier[] | null | Membuf[] | Membuf;
  bufferMemoryBarrierCount: uint32_t | nullptr_t | number | Membuf;
  pBufferMemoryBarriers: VkBufferMemoryBarrier[] | null | Membuf[] | Membuf;
  imageMemoryBarrierCount: uint32_t | nullptr_t | number | Membuf;
  pImageMemoryBarriers: VkImageMemoryBarrier[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdPipelineBarrierParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"srcStageMask":{"simple":"uint32_t","isPointer":false},"dstStageMask":{"simple":"uint32_t","isPointer":false},"dependencyFlags":{"simple":"uint32_t","isPointer":false},"memoryBarrierCount":{"simple":"uint32_t","isPointer":false},"pMemoryBarriers":{"simple":"VkMemoryBarrier","isPointer":true},"bufferMemoryBarrierCount":{"simple":"uint32_t","isPointer":false},"pBufferMemoryBarriers":{"simple":"VkBufferMemoryBarrier","isPointer":true},"imageMemoryBarrierCount":{"simple":"uint32_t","isPointer":false},"pImageMemoryBarriers":{"simple":"VkImageMemoryBarrier","isPointer":true}} as const;
export const vkCmdPipelineBarrier = (input: vkCmdPipelineBarrierInputWithDevice | vkCmdPipelineBarrierInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdPipelineBarrierParamsTypes[e[0] as keyof typeof vkCmdPipelineBarrierParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdPipelineBarrier(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdBeginQueryInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  queryPool: uint64_t | Membuf;
  query: uint32_t | number | Membuf;
  flags: uint32_t | nullptr_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdBeginQueryInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  queryPool: uint64_t | Membuf;
  query: uint32_t | number | Membuf;
  flags: uint32_t | nullptr_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdBeginQueryParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"queryPool":{"simple":"uint64_t","isPointer":false},"query":{"simple":"uint32_t","isPointer":false},"flags":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdBeginQuery = (input: vkCmdBeginQueryInputWithDevice | vkCmdBeginQueryInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdBeginQueryParamsTypes[e[0] as keyof typeof vkCmdBeginQueryParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdBeginQuery(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdEndQueryInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  queryPool: uint64_t | Membuf;
  query: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdEndQueryInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  queryPool: uint64_t | Membuf;
  query: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdEndQueryParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"queryPool":{"simple":"uint64_t","isPointer":false},"query":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdEndQuery = (input: vkCmdEndQueryInputWithDevice | vkCmdEndQueryInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdEndQueryParamsTypes[e[0] as keyof typeof vkCmdEndQueryParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdEndQuery(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdResetQueryPoolInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  queryPool: uint64_t | Membuf;
  firstQuery: uint32_t | number | Membuf;
  queryCount: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdResetQueryPoolInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  queryPool: uint64_t | Membuf;
  firstQuery: uint32_t | number | Membuf;
  queryCount: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdResetQueryPoolParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"queryPool":{"simple":"uint64_t","isPointer":false},"firstQuery":{"simple":"uint32_t","isPointer":false},"queryCount":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdResetQueryPool = (input: vkCmdResetQueryPoolInputWithDevice | vkCmdResetQueryPoolInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdResetQueryPoolParamsTypes[e[0] as keyof typeof vkCmdResetQueryPoolParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdResetQueryPool(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdWriteTimestampInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pipelineStage: uint32_t | number | Membuf;
  queryPool: uint64_t | Membuf;
  query: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdWriteTimestampInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pipelineStage: uint32_t | number | Membuf;
  queryPool: uint64_t | Membuf;
  query: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdWriteTimestampParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pipelineStage":{"simple":"uint32_t","isPointer":false},"queryPool":{"simple":"uint64_t","isPointer":false},"query":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdWriteTimestamp = (input: vkCmdWriteTimestampInputWithDevice | vkCmdWriteTimestampInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdWriteTimestampParamsTypes[e[0] as keyof typeof vkCmdWriteTimestampParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdWriteTimestamp(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdCopyQueryPoolResultsInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  queryPool: uint64_t | Membuf;
  firstQuery: uint32_t | number | Membuf;
  queryCount: uint32_t | number | Membuf;
  dstBuffer: uint64_t | Membuf;
  dstOffset: uint64_t | number | Membuf;
  stride: uint64_t | number | Membuf;
  flags: uint32_t | nullptr_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdCopyQueryPoolResultsInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  queryPool: uint64_t | Membuf;
  firstQuery: uint32_t | number | Membuf;
  queryCount: uint32_t | number | Membuf;
  dstBuffer: uint64_t | Membuf;
  dstOffset: uint64_t | number | Membuf;
  stride: uint64_t | number | Membuf;
  flags: uint32_t | nullptr_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdCopyQueryPoolResultsParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"queryPool":{"simple":"uint64_t","isPointer":false},"firstQuery":{"simple":"uint32_t","isPointer":false},"queryCount":{"simple":"uint32_t","isPointer":false},"dstBuffer":{"simple":"uint64_t","isPointer":false},"dstOffset":{"simple":"uint64_t","isPointer":false},"stride":{"simple":"uint64_t","isPointer":false},"flags":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdCopyQueryPoolResults = (input: vkCmdCopyQueryPoolResultsInputWithDevice | vkCmdCopyQueryPoolResultsInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdCopyQueryPoolResultsParamsTypes[e[0] as keyof typeof vkCmdCopyQueryPoolResultsParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdCopyQueryPoolResults(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdPushConstantsInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  layout: uint64_t | Membuf;
  stageFlags: uint32_t | number | Membuf;
  offset: uint32_t | number | Membuf;
  size: uint32_t | number | Membuf;
  pValues: uint64_t[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdPushConstantsInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  layout: uint64_t | Membuf;
  stageFlags: uint32_t | number | Membuf;
  offset: uint32_t | number | Membuf;
  size: uint32_t | number | Membuf;
  pValues: uint64_t[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdPushConstantsParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"layout":{"simple":"uint64_t","isPointer":false},"stageFlags":{"simple":"uint32_t","isPointer":false},"offset":{"simple":"uint32_t","isPointer":false},"size":{"simple":"uint32_t","isPointer":false},"pValues":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCmdPushConstants = (input: vkCmdPushConstantsInputWithDevice | vkCmdPushConstantsInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdPushConstantsParamsTypes[e[0] as keyof typeof vkCmdPushConstantsParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdPushConstants(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdBeginRenderPassInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pRenderPassBegin: VkRenderPassBeginInfo| null | Membuf;
  contents: int32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdBeginRenderPassInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pRenderPassBegin: VkRenderPassBeginInfo| null | Membuf;
  contents: int32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdBeginRenderPassParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pRenderPassBegin":{"simple":"VkRenderPassBeginInfo","isPointer":true},"contents":{"simple":"int32_t","isPointer":false}} as const;
export const vkCmdBeginRenderPass = (input: vkCmdBeginRenderPassInputWithDevice | vkCmdBeginRenderPassInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdBeginRenderPassParamsTypes[e[0] as keyof typeof vkCmdBeginRenderPassParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdBeginRenderPass(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdNextSubpassInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  contents: int32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdNextSubpassInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  contents: int32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdNextSubpassParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"contents":{"simple":"int32_t","isPointer":false}} as const;
export const vkCmdNextSubpass = (input: vkCmdNextSubpassInputWithDevice | vkCmdNextSubpassInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdNextSubpassParamsTypes[e[0] as keyof typeof vkCmdNextSubpassParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdNextSubpass(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdEndRenderPassInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdEndRenderPassInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdEndRenderPassParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false}} as const;
export const vkCmdEndRenderPass = (input: vkCmdEndRenderPassInputWithDevice | vkCmdEndRenderPassInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdEndRenderPassParamsTypes[e[0] as keyof typeof vkCmdEndRenderPassParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdEndRenderPass(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdExecuteCommandsInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  commandBufferCount: uint32_t | number | Membuf;
  pCommandBuffers: uint64_t[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdExecuteCommandsInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  commandBufferCount: uint32_t | number | Membuf;
  pCommandBuffers: uint64_t[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdExecuteCommandsParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"commandBufferCount":{"simple":"uint32_t","isPointer":false},"pCommandBuffers":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCmdExecuteCommands = (input: vkCmdExecuteCommandsInputWithDevice | vkCmdExecuteCommandsInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdExecuteCommandsParamsTypes[e[0] as keyof typeof vkCmdExecuteCommandsParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdExecuteCommands(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceDisplayPropertiesKHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkDisplayPropertiesKHR[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceDisplayPropertiesKHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkDisplayPropertiesKHR[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceDisplayPropertiesKHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pPropertyCount":{"simple":"uint32_t","isPointer":true},"pProperties":{"simple":"VkDisplayPropertiesKHR","isPointer":true}} as const;
export const vkGetPhysicalDeviceDisplayPropertiesKHR = (input: vkGetPhysicalDeviceDisplayPropertiesKHRInputWithDevice | vkGetPhysicalDeviceDisplayPropertiesKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceDisplayPropertiesKHRParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceDisplayPropertiesKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceDisplayPropertiesKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceDisplayPlanePropertiesKHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkDisplayPlanePropertiesKHR[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceDisplayPlanePropertiesKHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkDisplayPlanePropertiesKHR[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceDisplayPlanePropertiesKHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pPropertyCount":{"simple":"uint32_t","isPointer":true},"pProperties":{"simple":"VkDisplayPlanePropertiesKHR","isPointer":true}} as const;
export const vkGetPhysicalDeviceDisplayPlanePropertiesKHR = (input: vkGetPhysicalDeviceDisplayPlanePropertiesKHRInputWithDevice | vkGetPhysicalDeviceDisplayPlanePropertiesKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceDisplayPlanePropertiesKHRParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceDisplayPlanePropertiesKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetDisplayPlaneSupportedDisplaysKHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  planeIndex: uint32_t | number | Membuf;
  pDisplayCount: uint32_t| null | Membuf;
  pDisplays?: uint64_t[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetDisplayPlaneSupportedDisplaysKHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  planeIndex: uint32_t | number | Membuf;
  pDisplayCount: uint32_t| null | Membuf;
  pDisplays?: uint64_t[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetDisplayPlaneSupportedDisplaysKHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"planeIndex":{"simple":"uint32_t","isPointer":false},"pDisplayCount":{"simple":"uint32_t","isPointer":true},"pDisplays":{"simple":"uint64_t","isPointer":true}} as const;
export const vkGetDisplayPlaneSupportedDisplaysKHR = (input: vkGetDisplayPlaneSupportedDisplaysKHRInputWithDevice | vkGetDisplayPlaneSupportedDisplaysKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetDisplayPlaneSupportedDisplaysKHRParamsTypes[e[0] as keyof typeof vkGetDisplayPlaneSupportedDisplaysKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetDisplayPlaneSupportedDisplaysKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetDisplayModePropertiesKHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  display: uint64_t | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkDisplayModePropertiesKHR[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetDisplayModePropertiesKHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  display: uint64_t | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkDisplayModePropertiesKHR[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetDisplayModePropertiesKHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"display":{"simple":"uint64_t","isPointer":false},"pPropertyCount":{"simple":"uint32_t","isPointer":true},"pProperties":{"simple":"VkDisplayModePropertiesKHR","isPointer":true}} as const;
export const vkGetDisplayModePropertiesKHR = (input: vkGetDisplayModePropertiesKHRInputWithDevice | vkGetDisplayModePropertiesKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetDisplayModePropertiesKHRParamsTypes[e[0] as keyof typeof vkGetDisplayModePropertiesKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetDisplayModePropertiesKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateDisplayModeKHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  display: uint64_t | Membuf;
  pCreateInfo: VkDisplayModeCreateInfoKHR| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pMode: uint64_t| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCreateDisplayModeKHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  display: uint64_t | Membuf;
  pCreateInfo: VkDisplayModeCreateInfoKHR| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pMode: uint64_t| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCreateDisplayModeKHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"display":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkDisplayModeCreateInfoKHR","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pMode":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateDisplayModeKHR = (input: vkCreateDisplayModeKHRInputWithDevice | vkCreateDisplayModeKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_INITIALIZATION_FAILED => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateDisplayModeKHRParamsTypes[e[0] as keyof typeof vkCreateDisplayModeKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateDisplayModeKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetDisplayPlaneCapabilitiesKHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  mode: uint64_t | Membuf;
  planeIndex: uint32_t | number | Membuf;
  pCapabilities: VkDisplayPlaneCapabilitiesKHR| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetDisplayPlaneCapabilitiesKHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  mode: uint64_t | Membuf;
  planeIndex: uint32_t | number | Membuf;
  pCapabilities: VkDisplayPlaneCapabilitiesKHR| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetDisplayPlaneCapabilitiesKHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"mode":{"simple":"uint64_t","isPointer":false},"planeIndex":{"simple":"uint32_t","isPointer":false},"pCapabilities":{"simple":"VkDisplayPlaneCapabilitiesKHR","isPointer":true}} as const;
export const vkGetDisplayPlaneCapabilitiesKHR = (input: vkGetDisplayPlaneCapabilitiesKHRInputWithDevice | vkGetDisplayPlaneCapabilitiesKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetDisplayPlaneCapabilitiesKHRParamsTypes[e[0] as keyof typeof vkGetDisplayPlaneCapabilitiesKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetDisplayPlaneCapabilitiesKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateDisplayPlaneSurfaceKHRInputWithDevice {
  instance: uint64_t | Membuf;
  pCreateInfo: VkDisplaySurfaceCreateInfoKHR| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pSurface: uint64_t| null | Membuf;
}
export interface vkCreateDisplayPlaneSurfaceKHRInputWithInstance {
  instance: uint64_t | Membuf;
  pCreateInfo: VkDisplaySurfaceCreateInfoKHR| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pSurface: uint64_t| null | Membuf;
}

const vkCreateDisplayPlaneSurfaceKHRParamsTypes = {"instance":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkDisplaySurfaceCreateInfoKHR","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pSurface":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateDisplayPlaneSurfaceKHR = (input: vkCreateDisplayPlaneSurfaceKHRInputWithDevice | vkCreateDisplayPlaneSurfaceKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateDisplayPlaneSurfaceKHRParamsTypes[e[0] as keyof typeof vkCreateDisplayPlaneSurfaceKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateDisplayPlaneSurfaceKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateSharedSwapchainsKHRInputWithDevice {
  device: uint64_t | Membuf;
  swapchainCount: uint32_t | number | Membuf;
  pCreateInfos: VkSwapchainCreateInfoKHR[] | null | Membuf[] | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pSwapchains: uint64_t[] | null | Membuf[] | Membuf;
}
export interface vkCreateSharedSwapchainsKHRInputWithInstance {
  device: uint64_t | Membuf;
  swapchainCount: uint32_t | number | Membuf;
  pCreateInfos: VkSwapchainCreateInfoKHR[] | null | Membuf[] | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pSwapchains: uint64_t[] | null | Membuf[] | Membuf;
}

const vkCreateSharedSwapchainsKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"swapchainCount":{"simple":"uint32_t","isPointer":false},"pCreateInfos":{"simple":"VkSwapchainCreateInfoKHR","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pSwapchains":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateSharedSwapchainsKHR = (input: vkCreateSharedSwapchainsKHRInputWithDevice | vkCreateSharedSwapchainsKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_INCOMPATIBLE_DISPLAY_KHR | VkResult.VK_ERROR_DEVICE_LOST | VkResult.VK_ERROR_SURFACE_LOST_KHR => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateSharedSwapchainsKHRParamsTypes[e[0] as keyof typeof vkCreateSharedSwapchainsKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateSharedSwapchainsKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroySurfaceKHRInputWithDevice {
  instance: uint64_t | Membuf;
  surface: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroySurfaceKHRInputWithInstance {
  instance: uint64_t | Membuf;
  surface: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroySurfaceKHRParamsTypes = {"instance":{"simple":"uint64_t","isPointer":false},"surface":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroySurfaceKHR = (input: vkDestroySurfaceKHRInputWithDevice | vkDestroySurfaceKHRInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroySurfaceKHRParamsTypes[e[0] as keyof typeof vkDestroySurfaceKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroySurfaceKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceSurfaceSupportKHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  queueFamilyIndex: uint32_t | number | Membuf;
  surface: uint64_t | Membuf;
  pSupported: uint32_t| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceSurfaceSupportKHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  queueFamilyIndex: uint32_t | number | Membuf;
  surface: uint64_t | Membuf;
  pSupported: uint32_t| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceSurfaceSupportKHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"queueFamilyIndex":{"simple":"uint32_t","isPointer":false},"surface":{"simple":"uint64_t","isPointer":false},"pSupported":{"simple":"uint32_t","isPointer":true}} as const;
export const vkGetPhysicalDeviceSurfaceSupportKHR = (input: vkGetPhysicalDeviceSurfaceSupportKHRInputWithDevice | vkGetPhysicalDeviceSurfaceSupportKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_SURFACE_LOST_KHR => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceSurfaceSupportKHRParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceSurfaceSupportKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceSurfaceSupportKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceSurfaceCapabilitiesKHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  surface: uint64_t | Membuf;
  pSurfaceCapabilities: VkSurfaceCapabilitiesKHR| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceSurfaceCapabilitiesKHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  surface: uint64_t | Membuf;
  pSurfaceCapabilities: VkSurfaceCapabilitiesKHR| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceSurfaceCapabilitiesKHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"surface":{"simple":"uint64_t","isPointer":false},"pSurfaceCapabilities":{"simple":"VkSurfaceCapabilitiesKHR","isPointer":true}} as const;
export const vkGetPhysicalDeviceSurfaceCapabilitiesKHR = (input: vkGetPhysicalDeviceSurfaceCapabilitiesKHRInputWithDevice | vkGetPhysicalDeviceSurfaceCapabilitiesKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_SURFACE_LOST_KHR => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceSurfaceCapabilitiesKHRParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceSurfaceCapabilitiesKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceSurfaceFormatsKHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  surface: uint64_t | nullptr_t | Membuf;
  pSurfaceFormatCount: uint32_t| null | Membuf;
  pSurfaceFormats?: VkSurfaceFormatKHR[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceSurfaceFormatsKHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  surface: uint64_t | nullptr_t | Membuf;
  pSurfaceFormatCount: uint32_t| null | Membuf;
  pSurfaceFormats?: VkSurfaceFormatKHR[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceSurfaceFormatsKHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"surface":{"simple":"uint64_t","isPointer":false},"pSurfaceFormatCount":{"simple":"uint32_t","isPointer":true},"pSurfaceFormats":{"simple":"VkSurfaceFormatKHR","isPointer":true}} as const;
export const vkGetPhysicalDeviceSurfaceFormatsKHR = (input: vkGetPhysicalDeviceSurfaceFormatsKHRInputWithDevice | vkGetPhysicalDeviceSurfaceFormatsKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_SURFACE_LOST_KHR => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceSurfaceFormatsKHRParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceSurfaceFormatsKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceSurfaceFormatsKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceSurfacePresentModesKHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  surface: uint64_t | nullptr_t | Membuf;
  pPresentModeCount: uint32_t| null | Membuf;
  pPresentModes?: int32_t[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceSurfacePresentModesKHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  surface: uint64_t | nullptr_t | Membuf;
  pPresentModeCount: uint32_t| null | Membuf;
  pPresentModes?: int32_t[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceSurfacePresentModesKHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"surface":{"simple":"uint64_t","isPointer":false},"pPresentModeCount":{"simple":"uint32_t","isPointer":true},"pPresentModes":{"simple":"int32_t","isPointer":true}} as const;
export const vkGetPhysicalDeviceSurfacePresentModesKHR = (input: vkGetPhysicalDeviceSurfacePresentModesKHRInputWithDevice | vkGetPhysicalDeviceSurfacePresentModesKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_SURFACE_LOST_KHR => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceSurfacePresentModesKHRParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceSurfacePresentModesKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceSurfacePresentModesKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateSwapchainKHRInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkSwapchainCreateInfoKHR| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pSwapchain: uint64_t| null | Membuf;
}
export interface vkCreateSwapchainKHRInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkSwapchainCreateInfoKHR| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pSwapchain: uint64_t| null | Membuf;
}

const vkCreateSwapchainKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkSwapchainCreateInfoKHR","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pSwapchain":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateSwapchainKHR = (input: vkCreateSwapchainKHRInputWithDevice | vkCreateSwapchainKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_DEVICE_LOST | VkResult.VK_ERROR_SURFACE_LOST_KHR | VkResult.VK_ERROR_NATIVE_WINDOW_IN_USE_KHR | VkResult.VK_ERROR_INITIALIZATION_FAILED | VkResult.VK_ERROR_COMPRESSION_EXHAUSTED_EXT => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateSwapchainKHRParamsTypes[e[0] as keyof typeof vkCreateSwapchainKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateSwapchainKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroySwapchainKHRInputWithDevice {
  device: uint64_t | Membuf;
  swapchain: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroySwapchainKHRInputWithInstance {
  device: uint64_t | Membuf;
  swapchain: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroySwapchainKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"swapchain":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroySwapchainKHR = (input: vkDestroySwapchainKHRInputWithDevice | vkDestroySwapchainKHRInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroySwapchainKHRParamsTypes[e[0] as keyof typeof vkDestroySwapchainKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroySwapchainKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetSwapchainImagesKHRInputWithDevice {
  device: uint64_t | Membuf;
  swapchain: uint64_t | Membuf;
  pSwapchainImageCount: uint32_t| null | Membuf;
  pSwapchainImages?: uint64_t[] | null | Membuf[] | Membuf;
}
export interface vkGetSwapchainImagesKHRInputWithInstance {
  device: uint64_t | Membuf;
  swapchain: uint64_t | Membuf;
  pSwapchainImageCount: uint32_t| null | Membuf;
  pSwapchainImages?: uint64_t[] | null | Membuf[] | Membuf;
}

const vkGetSwapchainImagesKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"swapchain":{"simple":"uint64_t","isPointer":false},"pSwapchainImageCount":{"simple":"uint32_t","isPointer":true},"pSwapchainImages":{"simple":"uint64_t","isPointer":true}} as const;
export const vkGetSwapchainImagesKHR = (input: vkGetSwapchainImagesKHRInputWithDevice | vkGetSwapchainImagesKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetSwapchainImagesKHRParamsTypes[e[0] as keyof typeof vkGetSwapchainImagesKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetSwapchainImagesKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkAcquireNextImageKHRInputWithDevice {
  device: uint64_t | Membuf;
  swapchain: uint64_t | Membuf;
  timeout: uint64_t | number | Membuf;
  semaphore: uint64_t | nullptr_t | Membuf;
  fence: uint64_t | nullptr_t | Membuf;
  pImageIndex: uint32_t| null | Membuf;
}
export interface vkAcquireNextImageKHRInputWithInstance {
  device: uint64_t | Membuf;
  swapchain: uint64_t | Membuf;
  timeout: uint64_t | number | Membuf;
  semaphore: uint64_t | nullptr_t | Membuf;
  fence: uint64_t | nullptr_t | Membuf;
  pImageIndex: uint32_t| null | Membuf;
}

const vkAcquireNextImageKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"swapchain":{"simple":"uint64_t","isPointer":false},"timeout":{"simple":"uint64_t","isPointer":false},"semaphore":{"simple":"uint64_t","isPointer":false},"fence":{"simple":"uint64_t","isPointer":false},"pImageIndex":{"simple":"uint32_t","isPointer":true}} as const;
export const vkAcquireNextImageKHR = (input: vkAcquireNextImageKHRInputWithDevice | vkAcquireNextImageKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_TIMEOUT | VkResult.VK_NOT_READY | VkResult.VK_SUBOPTIMAL_KHR | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_DEVICE_LOST | VkResult.VK_ERROR_OUT_OF_DATE_KHR | VkResult.VK_ERROR_SURFACE_LOST_KHR | VkResult.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkAcquireNextImageKHRParamsTypes[e[0] as keyof typeof vkAcquireNextImageKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkAcquireNextImageKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkQueuePresentKHRInputWithDevice {
  queue: uint64_t | Membuf;
  pPresentInfo: VkPresentInfoKHR| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkQueuePresentKHRInputWithInstance {
  queue: uint64_t | Membuf;
  pPresentInfo: VkPresentInfoKHR| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkQueuePresentKHRParamsTypes = {"queue":{"simple":"uint64_t","isPointer":false},"pPresentInfo":{"simple":"VkPresentInfoKHR","isPointer":true}} as const;
export const vkQueuePresentKHR = (input: vkQueuePresentKHRInputWithDevice | vkQueuePresentKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_SUBOPTIMAL_KHR | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_DEVICE_LOST | VkResult.VK_ERROR_OUT_OF_DATE_KHR | VkResult.VK_ERROR_SURFACE_LOST_KHR | VkResult.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkQueuePresentKHRParamsTypes[e[0] as keyof typeof vkQueuePresentKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkQueuePresentKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceFeatures2InputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pFeatures: VkPhysicalDeviceFeatures2| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceFeatures2InputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pFeatures: VkPhysicalDeviceFeatures2| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceFeatures2ParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pFeatures":{"simple":"VkPhysicalDeviceFeatures2","isPointer":true}} as const;
export const vkGetPhysicalDeviceFeatures2 = (input: vkGetPhysicalDeviceFeatures2InputWithDevice | vkGetPhysicalDeviceFeatures2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceFeatures2ParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceFeatures2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceFeatures2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceProperties2InputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pProperties: VkPhysicalDeviceProperties2| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceProperties2InputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pProperties: VkPhysicalDeviceProperties2| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceProperties2ParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pProperties":{"simple":"VkPhysicalDeviceProperties2","isPointer":true}} as const;
export const vkGetPhysicalDeviceProperties2 = (input: vkGetPhysicalDeviceProperties2InputWithDevice | vkGetPhysicalDeviceProperties2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceProperties2ParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceProperties2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceProperties2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceFormatProperties2InputWithDevice {
  physicalDevice: uint64_t | Membuf;
  format: int32_t | number | Membuf;
  pFormatProperties: VkFormatProperties2| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceFormatProperties2InputWithInstance {
  physicalDevice: uint64_t | Membuf;
  format: int32_t | number | Membuf;
  pFormatProperties: VkFormatProperties2| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceFormatProperties2ParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"format":{"simple":"int32_t","isPointer":false},"pFormatProperties":{"simple":"VkFormatProperties2","isPointer":true}} as const;
export const vkGetPhysicalDeviceFormatProperties2 = (input: vkGetPhysicalDeviceFormatProperties2InputWithDevice | vkGetPhysicalDeviceFormatProperties2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceFormatProperties2ParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceFormatProperties2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceFormatProperties2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceImageFormatProperties2InputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pImageFormatInfo: VkPhysicalDeviceImageFormatInfo2| null | Membuf;
  pImageFormatProperties: VkImageFormatProperties2| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceImageFormatProperties2InputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pImageFormatInfo: VkPhysicalDeviceImageFormatInfo2| null | Membuf;
  pImageFormatProperties: VkImageFormatProperties2| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceImageFormatProperties2ParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pImageFormatInfo":{"simple":"VkPhysicalDeviceImageFormatInfo2","isPointer":true},"pImageFormatProperties":{"simple":"VkImageFormatProperties2","isPointer":true}} as const;
export const vkGetPhysicalDeviceImageFormatProperties2 = (input: vkGetPhysicalDeviceImageFormatProperties2InputWithDevice | vkGetPhysicalDeviceImageFormatProperties2InputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_FORMAT_NOT_SUPPORTED | VkResult.VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR | VkResult.VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR | VkResult.VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR | VkResult.VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR | VkResult.VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceImageFormatProperties2ParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceImageFormatProperties2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceImageFormatProperties2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceQueueFamilyProperties2InputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pQueueFamilyPropertyCount: uint32_t| null | Membuf;
  pQueueFamilyProperties?: VkQueueFamilyProperties2[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceQueueFamilyProperties2InputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pQueueFamilyPropertyCount: uint32_t| null | Membuf;
  pQueueFamilyProperties?: VkQueueFamilyProperties2[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceQueueFamilyProperties2ParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pQueueFamilyPropertyCount":{"simple":"uint32_t","isPointer":true},"pQueueFamilyProperties":{"simple":"VkQueueFamilyProperties2","isPointer":true}} as const;
export const vkGetPhysicalDeviceQueueFamilyProperties2 = (input: vkGetPhysicalDeviceQueueFamilyProperties2InputWithDevice | vkGetPhysicalDeviceQueueFamilyProperties2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceQueueFamilyProperties2ParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceQueueFamilyProperties2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceQueueFamilyProperties2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceMemoryProperties2InputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pMemoryProperties: VkPhysicalDeviceMemoryProperties2| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceMemoryProperties2InputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pMemoryProperties: VkPhysicalDeviceMemoryProperties2| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceMemoryProperties2ParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pMemoryProperties":{"simple":"VkPhysicalDeviceMemoryProperties2","isPointer":true}} as const;
export const vkGetPhysicalDeviceMemoryProperties2 = (input: vkGetPhysicalDeviceMemoryProperties2InputWithDevice | vkGetPhysicalDeviceMemoryProperties2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceMemoryProperties2ParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceMemoryProperties2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceMemoryProperties2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceSparseImageFormatProperties2InputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pFormatInfo: VkPhysicalDeviceSparseImageFormatInfo2| null | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkSparseImageFormatProperties2[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceSparseImageFormatProperties2InputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pFormatInfo: VkPhysicalDeviceSparseImageFormatInfo2| null | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkSparseImageFormatProperties2[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceSparseImageFormatProperties2ParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pFormatInfo":{"simple":"VkPhysicalDeviceSparseImageFormatInfo2","isPointer":true},"pPropertyCount":{"simple":"uint32_t","isPointer":true},"pProperties":{"simple":"VkSparseImageFormatProperties2","isPointer":true}} as const;
export const vkGetPhysicalDeviceSparseImageFormatProperties2 = (input: vkGetPhysicalDeviceSparseImageFormatProperties2InputWithDevice | vkGetPhysicalDeviceSparseImageFormatProperties2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceSparseImageFormatProperties2ParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceSparseImageFormatProperties2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceSparseImageFormatProperties2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdPushDescriptorSetKHRInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pipelineBindPoint: int32_t | number | Membuf;
  layout: uint64_t | Membuf;
  set: uint32_t | number | Membuf;
  descriptorWriteCount: uint32_t | number | Membuf;
  pDescriptorWrites: VkWriteDescriptorSet[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdPushDescriptorSetKHRInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pipelineBindPoint: int32_t | number | Membuf;
  layout: uint64_t | Membuf;
  set: uint32_t | number | Membuf;
  descriptorWriteCount: uint32_t | number | Membuf;
  pDescriptorWrites: VkWriteDescriptorSet[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdPushDescriptorSetKHRParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pipelineBindPoint":{"simple":"int32_t","isPointer":false},"layout":{"simple":"uint64_t","isPointer":false},"set":{"simple":"uint32_t","isPointer":false},"descriptorWriteCount":{"simple":"uint32_t","isPointer":false},"pDescriptorWrites":{"simple":"VkWriteDescriptorSet","isPointer":true}} as const;
export const vkCmdPushDescriptorSetKHR = (input: vkCmdPushDescriptorSetKHRInputWithDevice | vkCmdPushDescriptorSetKHRInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdPushDescriptorSetKHRParamsTypes[e[0] as keyof typeof vkCmdPushDescriptorSetKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdPushDescriptorSetKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkTrimCommandPoolInputWithDevice {
  device: uint64_t | Membuf;
  commandPool: uint64_t | Membuf;
  flags: int32_t | nullptr_t | number | Membuf;
}
export interface vkTrimCommandPoolInputWithInstance {
  device: uint64_t | Membuf;
  commandPool: uint64_t | Membuf;
  flags: int32_t | nullptr_t | number | Membuf;
}

const vkTrimCommandPoolParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"commandPool":{"simple":"uint64_t","isPointer":false},"flags":{"simple":"int32_t","isPointer":false}} as const;
export const vkTrimCommandPool = (input: vkTrimCommandPoolInputWithDevice | vkTrimCommandPoolInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkTrimCommandPoolParamsTypes[e[0] as keyof typeof vkTrimCommandPoolParamsTypes])];
    }));
    const result = vsnative.vts_native_vkTrimCommandPool(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceExternalBufferPropertiesInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pExternalBufferInfo: VkPhysicalDeviceExternalBufferInfo| null | Membuf;
  pExternalBufferProperties: VkExternalBufferProperties| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceExternalBufferPropertiesInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pExternalBufferInfo: VkPhysicalDeviceExternalBufferInfo| null | Membuf;
  pExternalBufferProperties: VkExternalBufferProperties| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceExternalBufferPropertiesParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pExternalBufferInfo":{"simple":"VkPhysicalDeviceExternalBufferInfo","isPointer":true},"pExternalBufferProperties":{"simple":"VkExternalBufferProperties","isPointer":true}} as const;
export const vkGetPhysicalDeviceExternalBufferProperties = (input: vkGetPhysicalDeviceExternalBufferPropertiesInputWithDevice | vkGetPhysicalDeviceExternalBufferPropertiesInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceExternalBufferPropertiesParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceExternalBufferPropertiesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceExternalBufferProperties(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceExternalSemaphorePropertiesInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pExternalSemaphoreInfo: VkPhysicalDeviceExternalSemaphoreInfo| null | Membuf;
  pExternalSemaphoreProperties: VkExternalSemaphoreProperties| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceExternalSemaphorePropertiesInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pExternalSemaphoreInfo: VkPhysicalDeviceExternalSemaphoreInfo| null | Membuf;
  pExternalSemaphoreProperties: VkExternalSemaphoreProperties| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceExternalSemaphorePropertiesParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pExternalSemaphoreInfo":{"simple":"VkPhysicalDeviceExternalSemaphoreInfo","isPointer":true},"pExternalSemaphoreProperties":{"simple":"VkExternalSemaphoreProperties","isPointer":true}} as const;
export const vkGetPhysicalDeviceExternalSemaphoreProperties = (input: vkGetPhysicalDeviceExternalSemaphorePropertiesInputWithDevice | vkGetPhysicalDeviceExternalSemaphorePropertiesInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceExternalSemaphorePropertiesParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceExternalSemaphorePropertiesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceExternalSemaphoreProperties(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceExternalFencePropertiesInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pExternalFenceInfo: VkPhysicalDeviceExternalFenceInfo| null | Membuf;
  pExternalFenceProperties: VkExternalFenceProperties| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceExternalFencePropertiesInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pExternalFenceInfo: VkPhysicalDeviceExternalFenceInfo| null | Membuf;
  pExternalFenceProperties: VkExternalFenceProperties| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceExternalFencePropertiesParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pExternalFenceInfo":{"simple":"VkPhysicalDeviceExternalFenceInfo","isPointer":true},"pExternalFenceProperties":{"simple":"VkExternalFenceProperties","isPointer":true}} as const;
export const vkGetPhysicalDeviceExternalFenceProperties = (input: vkGetPhysicalDeviceExternalFencePropertiesInputWithDevice | vkGetPhysicalDeviceExternalFencePropertiesInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceExternalFencePropertiesParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceExternalFencePropertiesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceExternalFenceProperties(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkEnumeratePhysicalDeviceGroupsInputWithDevice {
  instance: uint64_t | Membuf;
  pPhysicalDeviceGroupCount: uint32_t| null | Membuf;
  pPhysicalDeviceGroupProperties?: VkPhysicalDeviceGroupProperties[] | null | Membuf[] | Membuf;
}
export interface vkEnumeratePhysicalDeviceGroupsInputWithInstance {
  instance: uint64_t | Membuf;
  pPhysicalDeviceGroupCount: uint32_t| null | Membuf;
  pPhysicalDeviceGroupProperties?: VkPhysicalDeviceGroupProperties[] | null | Membuf[] | Membuf;
}

const vkEnumeratePhysicalDeviceGroupsParamsTypes = {"instance":{"simple":"uint64_t","isPointer":false},"pPhysicalDeviceGroupCount":{"simple":"uint32_t","isPointer":true},"pPhysicalDeviceGroupProperties":{"simple":"VkPhysicalDeviceGroupProperties","isPointer":true}} as const;
export const vkEnumeratePhysicalDeviceGroups = (input: vkEnumeratePhysicalDeviceGroupsInputWithDevice | vkEnumeratePhysicalDeviceGroupsInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_INITIALIZATION_FAILED => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkEnumeratePhysicalDeviceGroupsParamsTypes[e[0] as keyof typeof vkEnumeratePhysicalDeviceGroupsParamsTypes])];
    }));
    const result = vsnative.vts_native_vkEnumeratePhysicalDeviceGroups(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetDeviceGroupPeerMemoryFeaturesInputWithDevice {
  device: uint64_t | Membuf;
  heapIndex: uint32_t | number | Membuf;
  localDeviceIndex: uint32_t | number | Membuf;
  remoteDeviceIndex: uint32_t | number | Membuf;
  pPeerMemoryFeatures: uint32_t| null | Membuf;
}
export interface vkGetDeviceGroupPeerMemoryFeaturesInputWithInstance {
  device: uint64_t | Membuf;
  heapIndex: uint32_t | number | Membuf;
  localDeviceIndex: uint32_t | number | Membuf;
  remoteDeviceIndex: uint32_t | number | Membuf;
  pPeerMemoryFeatures: uint32_t| null | Membuf;
}

const vkGetDeviceGroupPeerMemoryFeaturesParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"heapIndex":{"simple":"uint32_t","isPointer":false},"localDeviceIndex":{"simple":"uint32_t","isPointer":false},"remoteDeviceIndex":{"simple":"uint32_t","isPointer":false},"pPeerMemoryFeatures":{"simple":"uint32_t","isPointer":true}} as const;
export const vkGetDeviceGroupPeerMemoryFeatures = (input: vkGetDeviceGroupPeerMemoryFeaturesInputWithDevice | vkGetDeviceGroupPeerMemoryFeaturesInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetDeviceGroupPeerMemoryFeaturesParamsTypes[e[0] as keyof typeof vkGetDeviceGroupPeerMemoryFeaturesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetDeviceGroupPeerMemoryFeatures(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkBindBufferMemory2InputWithDevice {
  device: uint64_t | Membuf;
  bindInfoCount: uint32_t | number | Membuf;
  pBindInfos: VkBindBufferMemoryInfo[] | null | Membuf[] | Membuf;
}
export interface vkBindBufferMemory2InputWithInstance {
  device: uint64_t | Membuf;
  bindInfoCount: uint32_t | number | Membuf;
  pBindInfos: VkBindBufferMemoryInfo[] | null | Membuf[] | Membuf;
}

const vkBindBufferMemory2ParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"bindInfoCount":{"simple":"uint32_t","isPointer":false},"pBindInfos":{"simple":"VkBindBufferMemoryInfo","isPointer":true}} as const;
export const vkBindBufferMemory2 = (input: vkBindBufferMemory2InputWithDevice | vkBindBufferMemory2InputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkBindBufferMemory2ParamsTypes[e[0] as keyof typeof vkBindBufferMemory2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkBindBufferMemory2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkBindImageMemory2InputWithDevice {
  device: uint64_t | Membuf;
  bindInfoCount: uint32_t | number | Membuf;
  pBindInfos: VkBindImageMemoryInfo[] | null | Membuf[] | Membuf;
}
export interface vkBindImageMemory2InputWithInstance {
  device: uint64_t | Membuf;
  bindInfoCount: uint32_t | number | Membuf;
  pBindInfos: VkBindImageMemoryInfo[] | null | Membuf[] | Membuf;
}

const vkBindImageMemory2ParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"bindInfoCount":{"simple":"uint32_t","isPointer":false},"pBindInfos":{"simple":"VkBindImageMemoryInfo","isPointer":true}} as const;
export const vkBindImageMemory2 = (input: vkBindImageMemory2InputWithDevice | vkBindImageMemory2InputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkBindImageMemory2ParamsTypes[e[0] as keyof typeof vkBindImageMemory2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkBindImageMemory2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetDeviceMaskInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  deviceMask: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetDeviceMaskInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  deviceMask: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetDeviceMaskParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"deviceMask":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdSetDeviceMask = (input: vkCmdSetDeviceMaskInputWithDevice | vkCmdSetDeviceMaskInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetDeviceMaskParamsTypes[e[0] as keyof typeof vkCmdSetDeviceMaskParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetDeviceMask(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetDeviceGroupPresentCapabilitiesKHRInputWithDevice {
  device: uint64_t | Membuf;
  pDeviceGroupPresentCapabilities: VkDeviceGroupPresentCapabilitiesKHR| null | Membuf;
}
export interface vkGetDeviceGroupPresentCapabilitiesKHRInputWithInstance {
  device: uint64_t | Membuf;
  pDeviceGroupPresentCapabilities: VkDeviceGroupPresentCapabilitiesKHR| null | Membuf;
}

const vkGetDeviceGroupPresentCapabilitiesKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pDeviceGroupPresentCapabilities":{"simple":"VkDeviceGroupPresentCapabilitiesKHR","isPointer":true}} as const;
export const vkGetDeviceGroupPresentCapabilitiesKHR = (input: vkGetDeviceGroupPresentCapabilitiesKHRInputWithDevice | vkGetDeviceGroupPresentCapabilitiesKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetDeviceGroupPresentCapabilitiesKHRParamsTypes[e[0] as keyof typeof vkGetDeviceGroupPresentCapabilitiesKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetDeviceGroupPresentCapabilitiesKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetDeviceGroupSurfacePresentModesKHRInputWithDevice {
  device: uint64_t | Membuf;
  surface: uint64_t | Membuf;
  pModes: uint32_t| null | Membuf;
}
export interface vkGetDeviceGroupSurfacePresentModesKHRInputWithInstance {
  device: uint64_t | Membuf;
  surface: uint64_t | Membuf;
  pModes: uint32_t| null | Membuf;
}

const vkGetDeviceGroupSurfacePresentModesKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"surface":{"simple":"uint64_t","isPointer":false},"pModes":{"simple":"uint32_t","isPointer":true}} as const;
export const vkGetDeviceGroupSurfacePresentModesKHR = (input: vkGetDeviceGroupSurfacePresentModesKHRInputWithDevice | vkGetDeviceGroupSurfacePresentModesKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_SURFACE_LOST_KHR => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetDeviceGroupSurfacePresentModesKHRParamsTypes[e[0] as keyof typeof vkGetDeviceGroupSurfacePresentModesKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetDeviceGroupSurfacePresentModesKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkAcquireNextImage2KHRInputWithDevice {
  device: uint64_t | Membuf;
  pAcquireInfo: VkAcquireNextImageInfoKHR| null | Membuf;
  pImageIndex: uint32_t| null | Membuf;
}
export interface vkAcquireNextImage2KHRInputWithInstance {
  device: uint64_t | Membuf;
  pAcquireInfo: VkAcquireNextImageInfoKHR| null | Membuf;
  pImageIndex: uint32_t| null | Membuf;
}

const vkAcquireNextImage2KHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pAcquireInfo":{"simple":"VkAcquireNextImageInfoKHR","isPointer":true},"pImageIndex":{"simple":"uint32_t","isPointer":true}} as const;
export const vkAcquireNextImage2KHR = (input: vkAcquireNextImage2KHRInputWithDevice | vkAcquireNextImage2KHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_TIMEOUT | VkResult.VK_NOT_READY | VkResult.VK_SUBOPTIMAL_KHR | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_DEVICE_LOST | VkResult.VK_ERROR_OUT_OF_DATE_KHR | VkResult.VK_ERROR_SURFACE_LOST_KHR | VkResult.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkAcquireNextImage2KHRParamsTypes[e[0] as keyof typeof vkAcquireNextImage2KHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkAcquireNextImage2KHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdDispatchBaseInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  baseGroupX: uint32_t | number | Membuf;
  baseGroupY: uint32_t | number | Membuf;
  baseGroupZ: uint32_t | number | Membuf;
  groupCountX: uint32_t | number | Membuf;
  groupCountY: uint32_t | number | Membuf;
  groupCountZ: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdDispatchBaseInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  baseGroupX: uint32_t | number | Membuf;
  baseGroupY: uint32_t | number | Membuf;
  baseGroupZ: uint32_t | number | Membuf;
  groupCountX: uint32_t | number | Membuf;
  groupCountY: uint32_t | number | Membuf;
  groupCountZ: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdDispatchBaseParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"baseGroupX":{"simple":"uint32_t","isPointer":false},"baseGroupY":{"simple":"uint32_t","isPointer":false},"baseGroupZ":{"simple":"uint32_t","isPointer":false},"groupCountX":{"simple":"uint32_t","isPointer":false},"groupCountY":{"simple":"uint32_t","isPointer":false},"groupCountZ":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdDispatchBase = (input: vkCmdDispatchBaseInputWithDevice | vkCmdDispatchBaseInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdDispatchBaseParamsTypes[e[0] as keyof typeof vkCmdDispatchBaseParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdDispatchBase(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDevicePresentRectanglesKHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  surface: uint64_t | Membuf;
  pRectCount: uint32_t| null | Membuf;
  pRects?: VkRect2D[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDevicePresentRectanglesKHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  surface: uint64_t | Membuf;
  pRectCount: uint32_t| null | Membuf;
  pRects?: VkRect2D[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDevicePresentRectanglesKHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"surface":{"simple":"uint64_t","isPointer":false},"pRectCount":{"simple":"uint32_t","isPointer":true},"pRects":{"simple":"VkRect2D","isPointer":true}} as const;
export const vkGetPhysicalDevicePresentRectanglesKHR = (input: vkGetPhysicalDevicePresentRectanglesKHRInputWithDevice | vkGetPhysicalDevicePresentRectanglesKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDevicePresentRectanglesKHRParamsTypes[e[0] as keyof typeof vkGetPhysicalDevicePresentRectanglesKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDevicePresentRectanglesKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateDescriptorUpdateTemplateInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkDescriptorUpdateTemplateCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pDescriptorUpdateTemplate: uint64_t| null | Membuf;
}
export interface vkCreateDescriptorUpdateTemplateInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkDescriptorUpdateTemplateCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pDescriptorUpdateTemplate: uint64_t| null | Membuf;
}

const vkCreateDescriptorUpdateTemplateParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkDescriptorUpdateTemplateCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pDescriptorUpdateTemplate":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateDescriptorUpdateTemplate = (input: vkCreateDescriptorUpdateTemplateInputWithDevice | vkCreateDescriptorUpdateTemplateInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateDescriptorUpdateTemplateParamsTypes[e[0] as keyof typeof vkCreateDescriptorUpdateTemplateParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateDescriptorUpdateTemplate(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyDescriptorUpdateTemplateInputWithDevice {
  device: uint64_t | Membuf;
  descriptorUpdateTemplate: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyDescriptorUpdateTemplateInputWithInstance {
  device: uint64_t | Membuf;
  descriptorUpdateTemplate: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyDescriptorUpdateTemplateParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"descriptorUpdateTemplate":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyDescriptorUpdateTemplate = (input: vkDestroyDescriptorUpdateTemplateInputWithDevice | vkDestroyDescriptorUpdateTemplateInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyDescriptorUpdateTemplateParamsTypes[e[0] as keyof typeof vkDestroyDescriptorUpdateTemplateParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyDescriptorUpdateTemplate(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkUpdateDescriptorSetWithTemplateInputWithDevice {
  device: uint64_t | Membuf;
  descriptorSet: uint64_t | Membuf;
  descriptorUpdateTemplate: uint64_t | Membuf;
  pData: uint64_t| null | Membuf;
}
export interface vkUpdateDescriptorSetWithTemplateInputWithInstance {
  device: uint64_t | Membuf;
  descriptorSet: uint64_t | Membuf;
  descriptorUpdateTemplate: uint64_t | Membuf;
  pData: uint64_t| null | Membuf;
}

const vkUpdateDescriptorSetWithTemplateParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"descriptorSet":{"simple":"uint64_t","isPointer":false},"descriptorUpdateTemplate":{"simple":"uint64_t","isPointer":false},"pData":{"simple":"uint64_t","isPointer":true}} as const;
export const vkUpdateDescriptorSetWithTemplate = (input: vkUpdateDescriptorSetWithTemplateInputWithDevice | vkUpdateDescriptorSetWithTemplateInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkUpdateDescriptorSetWithTemplateParamsTypes[e[0] as keyof typeof vkUpdateDescriptorSetWithTemplateParamsTypes])];
    }));
    const result = vsnative.vts_native_vkUpdateDescriptorSetWithTemplate(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdPushDescriptorSetWithTemplateKHRInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  descriptorUpdateTemplate: uint64_t | Membuf;
  layout: uint64_t | Membuf;
  set: uint32_t | number | Membuf;
  pData: uint64_t| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdPushDescriptorSetWithTemplateKHRInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  descriptorUpdateTemplate: uint64_t | Membuf;
  layout: uint64_t | Membuf;
  set: uint32_t | number | Membuf;
  pData: uint64_t| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdPushDescriptorSetWithTemplateKHRParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"descriptorUpdateTemplate":{"simple":"uint64_t","isPointer":false},"layout":{"simple":"uint64_t","isPointer":false},"set":{"simple":"uint32_t","isPointer":false},"pData":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCmdPushDescriptorSetWithTemplateKHR = (input: vkCmdPushDescriptorSetWithTemplateKHRInputWithDevice | vkCmdPushDescriptorSetWithTemplateKHRInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdPushDescriptorSetWithTemplateKHRParamsTypes[e[0] as keyof typeof vkCmdPushDescriptorSetWithTemplateKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdPushDescriptorSetWithTemplateKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkSetHdrMetadataEXTInputWithDevice {
  device: uint64_t | Membuf;
  swapchainCount: uint32_t | number | Membuf;
  pSwapchains: uint64_t[] | null | Membuf[] | Membuf;
  pMetadata: VkHdrMetadataEXT[] | null | Membuf[] | Membuf;
}
export interface vkSetHdrMetadataEXTInputWithInstance {
  device: uint64_t | Membuf;
  swapchainCount: uint32_t | number | Membuf;
  pSwapchains: uint64_t[] | null | Membuf[] | Membuf;
  pMetadata: VkHdrMetadataEXT[] | null | Membuf[] | Membuf;
}

const vkSetHdrMetadataEXTParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"swapchainCount":{"simple":"uint32_t","isPointer":false},"pSwapchains":{"simple":"uint64_t","isPointer":true},"pMetadata":{"simple":"VkHdrMetadataEXT","isPointer":true}} as const;
export const vkSetHdrMetadataEXT = (input: vkSetHdrMetadataEXTInputWithDevice | vkSetHdrMetadataEXTInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkSetHdrMetadataEXTParamsTypes[e[0] as keyof typeof vkSetHdrMetadataEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkSetHdrMetadataEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetSwapchainStatusKHRInputWithDevice {
  device: uint64_t | Membuf;
  swapchain: uint64_t | Membuf;
}
export interface vkGetSwapchainStatusKHRInputWithInstance {
  device: uint64_t | Membuf;
  swapchain: uint64_t | Membuf;
}

const vkGetSwapchainStatusKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"swapchain":{"simple":"uint64_t","isPointer":false}} as const;
export const vkGetSwapchainStatusKHR = (input: vkGetSwapchainStatusKHRInputWithDevice | vkGetSwapchainStatusKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_SUBOPTIMAL_KHR | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_DEVICE_LOST | VkResult.VK_ERROR_OUT_OF_DATE_KHR | VkResult.VK_ERROR_SURFACE_LOST_KHR | VkResult.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetSwapchainStatusKHRParamsTypes[e[0] as keyof typeof vkGetSwapchainStatusKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetSwapchainStatusKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetSampleLocationsEXTInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pSampleLocationsInfo: VkSampleLocationsInfoEXT| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetSampleLocationsEXTInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pSampleLocationsInfo: VkSampleLocationsInfoEXT| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetSampleLocationsEXTParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pSampleLocationsInfo":{"simple":"VkSampleLocationsInfoEXT","isPointer":true}} as const;
export const vkCmdSetSampleLocationsEXT = (input: vkCmdSetSampleLocationsEXTInputWithDevice | vkCmdSetSampleLocationsEXTInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetSampleLocationsEXTParamsTypes[e[0] as keyof typeof vkCmdSetSampleLocationsEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetSampleLocationsEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceMultisamplePropertiesEXTInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  samples: uint32_t | number | Membuf;
  pMultisampleProperties: VkMultisamplePropertiesEXT| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceMultisamplePropertiesEXTInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  samples: uint32_t | number | Membuf;
  pMultisampleProperties: VkMultisamplePropertiesEXT| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceMultisamplePropertiesEXTParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"samples":{"simple":"uint32_t","isPointer":false},"pMultisampleProperties":{"simple":"VkMultisamplePropertiesEXT","isPointer":true}} as const;
export const vkGetPhysicalDeviceMultisamplePropertiesEXT = (input: vkGetPhysicalDeviceMultisamplePropertiesEXTInputWithDevice | vkGetPhysicalDeviceMultisamplePropertiesEXTInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceMultisamplePropertiesEXTParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceMultisamplePropertiesEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceMultisamplePropertiesEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceSurfaceCapabilities2KHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pSurfaceInfo: VkPhysicalDeviceSurfaceInfo2KHR| null | Membuf;
  pSurfaceCapabilities: VkSurfaceCapabilities2KHR| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceSurfaceCapabilities2KHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pSurfaceInfo: VkPhysicalDeviceSurfaceInfo2KHR| null | Membuf;
  pSurfaceCapabilities: VkSurfaceCapabilities2KHR| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceSurfaceCapabilities2KHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pSurfaceInfo":{"simple":"VkPhysicalDeviceSurfaceInfo2KHR","isPointer":true},"pSurfaceCapabilities":{"simple":"VkSurfaceCapabilities2KHR","isPointer":true}} as const;
export const vkGetPhysicalDeviceSurfaceCapabilities2KHR = (input: vkGetPhysicalDeviceSurfaceCapabilities2KHRInputWithDevice | vkGetPhysicalDeviceSurfaceCapabilities2KHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_SURFACE_LOST_KHR => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceSurfaceCapabilities2KHRParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceSurfaceCapabilities2KHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceSurfaceCapabilities2KHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceSurfaceFormats2KHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pSurfaceInfo: VkPhysicalDeviceSurfaceInfo2KHR| null | Membuf;
  pSurfaceFormatCount: uint32_t| null | Membuf;
  pSurfaceFormats?: VkSurfaceFormat2KHR[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceSurfaceFormats2KHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pSurfaceInfo: VkPhysicalDeviceSurfaceInfo2KHR| null | Membuf;
  pSurfaceFormatCount: uint32_t| null | Membuf;
  pSurfaceFormats?: VkSurfaceFormat2KHR[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceSurfaceFormats2KHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pSurfaceInfo":{"simple":"VkPhysicalDeviceSurfaceInfo2KHR","isPointer":true},"pSurfaceFormatCount":{"simple":"uint32_t","isPointer":true},"pSurfaceFormats":{"simple":"VkSurfaceFormat2KHR","isPointer":true}} as const;
export const vkGetPhysicalDeviceSurfaceFormats2KHR = (input: vkGetPhysicalDeviceSurfaceFormats2KHRInputWithDevice | vkGetPhysicalDeviceSurfaceFormats2KHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_SURFACE_LOST_KHR => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceSurfaceFormats2KHRParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceSurfaceFormats2KHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceSurfaceFormats2KHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceDisplayProperties2KHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkDisplayProperties2KHR[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceDisplayProperties2KHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkDisplayProperties2KHR[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceDisplayProperties2KHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pPropertyCount":{"simple":"uint32_t","isPointer":true},"pProperties":{"simple":"VkDisplayProperties2KHR","isPointer":true}} as const;
export const vkGetPhysicalDeviceDisplayProperties2KHR = (input: vkGetPhysicalDeviceDisplayProperties2KHRInputWithDevice | vkGetPhysicalDeviceDisplayProperties2KHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceDisplayProperties2KHRParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceDisplayProperties2KHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceDisplayProperties2KHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceDisplayPlaneProperties2KHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkDisplayPlaneProperties2KHR[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceDisplayPlaneProperties2KHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkDisplayPlaneProperties2KHR[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceDisplayPlaneProperties2KHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pPropertyCount":{"simple":"uint32_t","isPointer":true},"pProperties":{"simple":"VkDisplayPlaneProperties2KHR","isPointer":true}} as const;
export const vkGetPhysicalDeviceDisplayPlaneProperties2KHR = (input: vkGetPhysicalDeviceDisplayPlaneProperties2KHRInputWithDevice | vkGetPhysicalDeviceDisplayPlaneProperties2KHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceDisplayPlaneProperties2KHRParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceDisplayPlaneProperties2KHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetDisplayModeProperties2KHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  display: uint64_t | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkDisplayModeProperties2KHR[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetDisplayModeProperties2KHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  display: uint64_t | Membuf;
  pPropertyCount: uint32_t| null | Membuf;
  pProperties?: VkDisplayModeProperties2KHR[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetDisplayModeProperties2KHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"display":{"simple":"uint64_t","isPointer":false},"pPropertyCount":{"simple":"uint32_t","isPointer":true},"pProperties":{"simple":"VkDisplayModeProperties2KHR","isPointer":true}} as const;
export const vkGetDisplayModeProperties2KHR = (input: vkGetDisplayModeProperties2KHRInputWithDevice | vkGetDisplayModeProperties2KHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetDisplayModeProperties2KHRParamsTypes[e[0] as keyof typeof vkGetDisplayModeProperties2KHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetDisplayModeProperties2KHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetDisplayPlaneCapabilities2KHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pDisplayPlaneInfo: VkDisplayPlaneInfo2KHR| null | Membuf;
  pCapabilities: VkDisplayPlaneCapabilities2KHR| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetDisplayPlaneCapabilities2KHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pDisplayPlaneInfo: VkDisplayPlaneInfo2KHR| null | Membuf;
  pCapabilities: VkDisplayPlaneCapabilities2KHR| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetDisplayPlaneCapabilities2KHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pDisplayPlaneInfo":{"simple":"VkDisplayPlaneInfo2KHR","isPointer":true},"pCapabilities":{"simple":"VkDisplayPlaneCapabilities2KHR","isPointer":true}} as const;
export const vkGetDisplayPlaneCapabilities2KHR = (input: vkGetDisplayPlaneCapabilities2KHRInputWithDevice | vkGetDisplayPlaneCapabilities2KHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetDisplayPlaneCapabilities2KHRParamsTypes[e[0] as keyof typeof vkGetDisplayPlaneCapabilities2KHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetDisplayPlaneCapabilities2KHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetBufferMemoryRequirements2InputWithDevice {
  device: uint64_t | Membuf;
  pInfo: VkBufferMemoryRequirementsInfo2| null | Membuf;
  pMemoryRequirements: VkMemoryRequirements2| null | Membuf;
}
export interface vkGetBufferMemoryRequirements2InputWithInstance {
  device: uint64_t | Membuf;
  pInfo: VkBufferMemoryRequirementsInfo2| null | Membuf;
  pMemoryRequirements: VkMemoryRequirements2| null | Membuf;
}

const vkGetBufferMemoryRequirements2ParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pInfo":{"simple":"VkBufferMemoryRequirementsInfo2","isPointer":true},"pMemoryRequirements":{"simple":"VkMemoryRequirements2","isPointer":true}} as const;
export const vkGetBufferMemoryRequirements2 = (input: vkGetBufferMemoryRequirements2InputWithDevice | vkGetBufferMemoryRequirements2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetBufferMemoryRequirements2ParamsTypes[e[0] as keyof typeof vkGetBufferMemoryRequirements2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetBufferMemoryRequirements2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetImageMemoryRequirements2InputWithDevice {
  device: uint64_t | Membuf;
  pInfo: VkImageMemoryRequirementsInfo2| null | Membuf;
  pMemoryRequirements: VkMemoryRequirements2| null | Membuf;
}
export interface vkGetImageMemoryRequirements2InputWithInstance {
  device: uint64_t | Membuf;
  pInfo: VkImageMemoryRequirementsInfo2| null | Membuf;
  pMemoryRequirements: VkMemoryRequirements2| null | Membuf;
}

const vkGetImageMemoryRequirements2ParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pInfo":{"simple":"VkImageMemoryRequirementsInfo2","isPointer":true},"pMemoryRequirements":{"simple":"VkMemoryRequirements2","isPointer":true}} as const;
export const vkGetImageMemoryRequirements2 = (input: vkGetImageMemoryRequirements2InputWithDevice | vkGetImageMemoryRequirements2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetImageMemoryRequirements2ParamsTypes[e[0] as keyof typeof vkGetImageMemoryRequirements2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetImageMemoryRequirements2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetImageSparseMemoryRequirements2InputWithDevice {
  device: uint64_t | Membuf;
  pInfo: VkImageSparseMemoryRequirementsInfo2| null | Membuf;
  pSparseMemoryRequirementCount: uint32_t| null | Membuf;
  pSparseMemoryRequirements?: VkSparseImageMemoryRequirements2[] | null | Membuf[] | Membuf;
}
export interface vkGetImageSparseMemoryRequirements2InputWithInstance {
  device: uint64_t | Membuf;
  pInfo: VkImageSparseMemoryRequirementsInfo2| null | Membuf;
  pSparseMemoryRequirementCount: uint32_t| null | Membuf;
  pSparseMemoryRequirements?: VkSparseImageMemoryRequirements2[] | null | Membuf[] | Membuf;
}

const vkGetImageSparseMemoryRequirements2ParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pInfo":{"simple":"VkImageSparseMemoryRequirementsInfo2","isPointer":true},"pSparseMemoryRequirementCount":{"simple":"uint32_t","isPointer":true},"pSparseMemoryRequirements":{"simple":"VkSparseImageMemoryRequirements2","isPointer":true}} as const;
export const vkGetImageSparseMemoryRequirements2 = (input: vkGetImageSparseMemoryRequirements2InputWithDevice | vkGetImageSparseMemoryRequirements2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetImageSparseMemoryRequirements2ParamsTypes[e[0] as keyof typeof vkGetImageSparseMemoryRequirements2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetImageSparseMemoryRequirements2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetDeviceBufferMemoryRequirementsInputWithDevice {
  device: uint64_t | Membuf;
  pInfo: VkDeviceBufferMemoryRequirements| null | Membuf;
  pMemoryRequirements: VkMemoryRequirements2| null | Membuf;
}
export interface vkGetDeviceBufferMemoryRequirementsInputWithInstance {
  device: uint64_t | Membuf;
  pInfo: VkDeviceBufferMemoryRequirements| null | Membuf;
  pMemoryRequirements: VkMemoryRequirements2| null | Membuf;
}

const vkGetDeviceBufferMemoryRequirementsParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pInfo":{"simple":"VkDeviceBufferMemoryRequirements","isPointer":true},"pMemoryRequirements":{"simple":"VkMemoryRequirements2","isPointer":true}} as const;
export const vkGetDeviceBufferMemoryRequirements = (input: vkGetDeviceBufferMemoryRequirementsInputWithDevice | vkGetDeviceBufferMemoryRequirementsInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetDeviceBufferMemoryRequirementsParamsTypes[e[0] as keyof typeof vkGetDeviceBufferMemoryRequirementsParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetDeviceBufferMemoryRequirements(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetDeviceImageMemoryRequirementsInputWithDevice {
  device: uint64_t | Membuf;
  pInfo: VkDeviceImageMemoryRequirements| null | Membuf;
  pMemoryRequirements: VkMemoryRequirements2| null | Membuf;
}
export interface vkGetDeviceImageMemoryRequirementsInputWithInstance {
  device: uint64_t | Membuf;
  pInfo: VkDeviceImageMemoryRequirements| null | Membuf;
  pMemoryRequirements: VkMemoryRequirements2| null | Membuf;
}

const vkGetDeviceImageMemoryRequirementsParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pInfo":{"simple":"VkDeviceImageMemoryRequirements","isPointer":true},"pMemoryRequirements":{"simple":"VkMemoryRequirements2","isPointer":true}} as const;
export const vkGetDeviceImageMemoryRequirements = (input: vkGetDeviceImageMemoryRequirementsInputWithDevice | vkGetDeviceImageMemoryRequirementsInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetDeviceImageMemoryRequirementsParamsTypes[e[0] as keyof typeof vkGetDeviceImageMemoryRequirementsParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetDeviceImageMemoryRequirements(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetDeviceImageSparseMemoryRequirementsInputWithDevice {
  device: uint64_t | Membuf;
  pInfo: VkDeviceImageMemoryRequirements| null | Membuf;
  pSparseMemoryRequirementCount: uint32_t| null | Membuf;
  pSparseMemoryRequirements?: VkSparseImageMemoryRequirements2[] | null | Membuf[] | Membuf;
}
export interface vkGetDeviceImageSparseMemoryRequirementsInputWithInstance {
  device: uint64_t | Membuf;
  pInfo: VkDeviceImageMemoryRequirements| null | Membuf;
  pSparseMemoryRequirementCount: uint32_t| null | Membuf;
  pSparseMemoryRequirements?: VkSparseImageMemoryRequirements2[] | null | Membuf[] | Membuf;
}

const vkGetDeviceImageSparseMemoryRequirementsParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pInfo":{"simple":"VkDeviceImageMemoryRequirements","isPointer":true},"pSparseMemoryRequirementCount":{"simple":"uint32_t","isPointer":true},"pSparseMemoryRequirements":{"simple":"VkSparseImageMemoryRequirements2","isPointer":true}} as const;
export const vkGetDeviceImageSparseMemoryRequirements = (input: vkGetDeviceImageSparseMemoryRequirementsInputWithDevice | vkGetDeviceImageSparseMemoryRequirementsInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetDeviceImageSparseMemoryRequirementsParamsTypes[e[0] as keyof typeof vkGetDeviceImageSparseMemoryRequirementsParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetDeviceImageSparseMemoryRequirements(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateSamplerYcbcrConversionInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkSamplerYcbcrConversionCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pYcbcrConversion: uint64_t| null | Membuf;
}
export interface vkCreateSamplerYcbcrConversionInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkSamplerYcbcrConversionCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pYcbcrConversion: uint64_t| null | Membuf;
}

const vkCreateSamplerYcbcrConversionParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkSamplerYcbcrConversionCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pYcbcrConversion":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateSamplerYcbcrConversion = (input: vkCreateSamplerYcbcrConversionInputWithDevice | vkCreateSamplerYcbcrConversionInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateSamplerYcbcrConversionParamsTypes[e[0] as keyof typeof vkCreateSamplerYcbcrConversionParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateSamplerYcbcrConversion(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroySamplerYcbcrConversionInputWithDevice {
  device: uint64_t | Membuf;
  ycbcrConversion: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroySamplerYcbcrConversionInputWithInstance {
  device: uint64_t | Membuf;
  ycbcrConversion: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroySamplerYcbcrConversionParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"ycbcrConversion":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroySamplerYcbcrConversion = (input: vkDestroySamplerYcbcrConversionInputWithDevice | vkDestroySamplerYcbcrConversionInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroySamplerYcbcrConversionParamsTypes[e[0] as keyof typeof vkDestroySamplerYcbcrConversionParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroySamplerYcbcrConversion(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetDeviceQueue2InputWithDevice {
  device: uint64_t | Membuf;
  pQueueInfo: VkDeviceQueueInfo2| null | Membuf;
  pQueue: uint64_t| null | Membuf;
}
export interface vkGetDeviceQueue2InputWithInstance {
  device: uint64_t | Membuf;
  pQueueInfo: VkDeviceQueueInfo2| null | Membuf;
  pQueue: uint64_t| null | Membuf;
}

const vkGetDeviceQueue2ParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pQueueInfo":{"simple":"VkDeviceQueueInfo2","isPointer":true},"pQueue":{"simple":"uint64_t","isPointer":true}} as const;
export const vkGetDeviceQueue2 = (input: vkGetDeviceQueue2InputWithDevice | vkGetDeviceQueue2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetDeviceQueue2ParamsTypes[e[0] as keyof typeof vkGetDeviceQueue2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetDeviceQueue2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateValidationCacheEXTInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkValidationCacheCreateInfoEXT| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pValidationCache: uint64_t| null | Membuf;
}
export interface vkCreateValidationCacheEXTInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkValidationCacheCreateInfoEXT| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pValidationCache: uint64_t| null | Membuf;
}

const vkCreateValidationCacheEXTParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkValidationCacheCreateInfoEXT","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pValidationCache":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateValidationCacheEXT = (input: vkCreateValidationCacheEXTInputWithDevice | vkCreateValidationCacheEXTInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateValidationCacheEXTParamsTypes[e[0] as keyof typeof vkCreateValidationCacheEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateValidationCacheEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyValidationCacheEXTInputWithDevice {
  device: uint64_t | Membuf;
  validationCache: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyValidationCacheEXTInputWithInstance {
  device: uint64_t | Membuf;
  validationCache: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyValidationCacheEXTParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"validationCache":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyValidationCacheEXT = (input: vkDestroyValidationCacheEXTInputWithDevice | vkDestroyValidationCacheEXTInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyValidationCacheEXTParamsTypes[e[0] as keyof typeof vkDestroyValidationCacheEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyValidationCacheEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetValidationCacheDataEXTInputWithDevice {
  device: uint64_t | Membuf;
  validationCache: uint64_t | Membuf;
  pDataSize: size_t| null | Membuf;
  pData?: uint64_t[] | null | Membuf[] | Membuf;
}
export interface vkGetValidationCacheDataEXTInputWithInstance {
  device: uint64_t | Membuf;
  validationCache: uint64_t | Membuf;
  pDataSize: size_t| null | Membuf;
  pData?: uint64_t[] | null | Membuf[] | Membuf;
}

const vkGetValidationCacheDataEXTParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"validationCache":{"simple":"uint64_t","isPointer":false},"pDataSize":{"simple":"size_t","isPointer":true},"pData":{"simple":"uint64_t","isPointer":true}} as const;
export const vkGetValidationCacheDataEXT = (input: vkGetValidationCacheDataEXTInputWithDevice | vkGetValidationCacheDataEXTInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetValidationCacheDataEXTParamsTypes[e[0] as keyof typeof vkGetValidationCacheDataEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetValidationCacheDataEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkMergeValidationCachesEXTInputWithDevice {
  device: uint64_t | Membuf;
  dstCache: uint64_t | Membuf;
  srcCacheCount: uint32_t | number | Membuf;
  pSrcCaches: uint64_t[] | null | Membuf[] | Membuf;
}
export interface vkMergeValidationCachesEXTInputWithInstance {
  device: uint64_t | Membuf;
  dstCache: uint64_t | Membuf;
  srcCacheCount: uint32_t | number | Membuf;
  pSrcCaches: uint64_t[] | null | Membuf[] | Membuf;
}

const vkMergeValidationCachesEXTParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"dstCache":{"simple":"uint64_t","isPointer":false},"srcCacheCount":{"simple":"uint32_t","isPointer":false},"pSrcCaches":{"simple":"uint64_t","isPointer":true}} as const;
export const vkMergeValidationCachesEXT = (input: vkMergeValidationCachesEXTInputWithDevice | vkMergeValidationCachesEXTInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkMergeValidationCachesEXTParamsTypes[e[0] as keyof typeof vkMergeValidationCachesEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkMergeValidationCachesEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetDescriptorSetLayoutSupportInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkDescriptorSetLayoutCreateInfo| null | Membuf;
  pSupport: VkDescriptorSetLayoutSupport| null | Membuf;
}
export interface vkGetDescriptorSetLayoutSupportInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkDescriptorSetLayoutCreateInfo| null | Membuf;
  pSupport: VkDescriptorSetLayoutSupport| null | Membuf;
}

const vkGetDescriptorSetLayoutSupportParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkDescriptorSetLayoutCreateInfo","isPointer":true},"pSupport":{"simple":"VkDescriptorSetLayoutSupport","isPointer":true}} as const;
export const vkGetDescriptorSetLayoutSupport = (input: vkGetDescriptorSetLayoutSupportInputWithDevice | vkGetDescriptorSetLayoutSupportInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetDescriptorSetLayoutSupportParamsTypes[e[0] as keyof typeof vkGetDescriptorSetLayoutSupportParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetDescriptorSetLayoutSupport(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetMemoryHostPointerPropertiesEXTInputWithDevice {
  device: uint64_t | Membuf;
  handleType: uint32_t | number | Membuf;
  pHostPointer: uint64_t| null | Membuf;
  pMemoryHostPointerProperties: VkMemoryHostPointerPropertiesEXT| null | Membuf;
}
export interface vkGetMemoryHostPointerPropertiesEXTInputWithInstance {
  device: uint64_t | Membuf;
  handleType: uint32_t | number | Membuf;
  pHostPointer: uint64_t| null | Membuf;
  pMemoryHostPointerProperties: VkMemoryHostPointerPropertiesEXT| null | Membuf;
}

const vkGetMemoryHostPointerPropertiesEXTParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"handleType":{"simple":"uint32_t","isPointer":false},"pHostPointer":{"simple":"uint64_t","isPointer":true},"pMemoryHostPointerProperties":{"simple":"VkMemoryHostPointerPropertiesEXT","isPointer":true}} as const;
export const vkGetMemoryHostPointerPropertiesEXT = (input: vkGetMemoryHostPointerPropertiesEXTInputWithDevice | vkGetMemoryHostPointerPropertiesEXTInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_INVALID_EXTERNAL_HANDLE => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetMemoryHostPointerPropertiesEXTParamsTypes[e[0] as keyof typeof vkGetMemoryHostPointerPropertiesEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetMemoryHostPointerPropertiesEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateRenderPass2InputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkRenderPassCreateInfo2| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pRenderPass: uint64_t| null | Membuf;
}
export interface vkCreateRenderPass2InputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkRenderPassCreateInfo2| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pRenderPass: uint64_t| null | Membuf;
}

const vkCreateRenderPass2ParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkRenderPassCreateInfo2","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pRenderPass":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateRenderPass2 = (input: vkCreateRenderPass2InputWithDevice | vkCreateRenderPass2InputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateRenderPass2ParamsTypes[e[0] as keyof typeof vkCreateRenderPass2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateRenderPass2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdBeginRenderPass2InputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pRenderPassBegin: VkRenderPassBeginInfo| null | Membuf;
  pSubpassBeginInfo: VkSubpassBeginInfo| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdBeginRenderPass2InputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pRenderPassBegin: VkRenderPassBeginInfo| null | Membuf;
  pSubpassBeginInfo: VkSubpassBeginInfo| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdBeginRenderPass2ParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pRenderPassBegin":{"simple":"VkRenderPassBeginInfo","isPointer":true},"pSubpassBeginInfo":{"simple":"VkSubpassBeginInfo","isPointer":true}} as const;
export const vkCmdBeginRenderPass2 = (input: vkCmdBeginRenderPass2InputWithDevice | vkCmdBeginRenderPass2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdBeginRenderPass2ParamsTypes[e[0] as keyof typeof vkCmdBeginRenderPass2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdBeginRenderPass2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdNextSubpass2InputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pSubpassBeginInfo: VkSubpassBeginInfo| null | Membuf;
  pSubpassEndInfo: VkSubpassEndInfo| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdNextSubpass2InputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pSubpassBeginInfo: VkSubpassBeginInfo| null | Membuf;
  pSubpassEndInfo: VkSubpassEndInfo| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdNextSubpass2ParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pSubpassBeginInfo":{"simple":"VkSubpassBeginInfo","isPointer":true},"pSubpassEndInfo":{"simple":"VkSubpassEndInfo","isPointer":true}} as const;
export const vkCmdNextSubpass2 = (input: vkCmdNextSubpass2InputWithDevice | vkCmdNextSubpass2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdNextSubpass2ParamsTypes[e[0] as keyof typeof vkCmdNextSubpass2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdNextSubpass2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdEndRenderPass2InputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pSubpassEndInfo: VkSubpassEndInfo| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdEndRenderPass2InputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pSubpassEndInfo: VkSubpassEndInfo| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdEndRenderPass2ParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pSubpassEndInfo":{"simple":"VkSubpassEndInfo","isPointer":true}} as const;
export const vkCmdEndRenderPass2 = (input: vkCmdEndRenderPass2InputWithDevice | vkCmdEndRenderPass2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdEndRenderPass2ParamsTypes[e[0] as keyof typeof vkCmdEndRenderPass2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdEndRenderPass2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetSemaphoreCounterValueInputWithDevice {
  device: uint64_t | Membuf;
  semaphore: uint64_t | Membuf;
  pValue: uint64_t| null | Membuf;
}
export interface vkGetSemaphoreCounterValueInputWithInstance {
  device: uint64_t | Membuf;
  semaphore: uint64_t | Membuf;
  pValue: uint64_t| null | Membuf;
}

const vkGetSemaphoreCounterValueParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"semaphore":{"simple":"uint64_t","isPointer":false},"pValue":{"simple":"uint64_t","isPointer":true}} as const;
export const vkGetSemaphoreCounterValue = (input: vkGetSemaphoreCounterValueInputWithDevice | vkGetSemaphoreCounterValueInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_DEVICE_LOST => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetSemaphoreCounterValueParamsTypes[e[0] as keyof typeof vkGetSemaphoreCounterValueParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetSemaphoreCounterValue(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkWaitSemaphoresInputWithDevice {
  device: uint64_t | Membuf;
  pWaitInfo: VkSemaphoreWaitInfo| null | Membuf;
  timeout: uint64_t | number | Membuf;
}
export interface vkWaitSemaphoresInputWithInstance {
  device: uint64_t | Membuf;
  pWaitInfo: VkSemaphoreWaitInfo| null | Membuf;
  timeout: uint64_t | number | Membuf;
}

const vkWaitSemaphoresParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pWaitInfo":{"simple":"VkSemaphoreWaitInfo","isPointer":true},"timeout":{"simple":"uint64_t","isPointer":false}} as const;
export const vkWaitSemaphores = (input: vkWaitSemaphoresInputWithDevice | vkWaitSemaphoresInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_TIMEOUT | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_DEVICE_LOST => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkWaitSemaphoresParamsTypes[e[0] as keyof typeof vkWaitSemaphoresParamsTypes])];
    }));
    const result = vsnative.vts_native_vkWaitSemaphores(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkSignalSemaphoreInputWithDevice {
  device: uint64_t | Membuf;
  pSignalInfo: VkSemaphoreSignalInfo| null | Membuf;
}
export interface vkSignalSemaphoreInputWithInstance {
  device: uint64_t | Membuf;
  pSignalInfo: VkSemaphoreSignalInfo| null | Membuf;
}

const vkSignalSemaphoreParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pSignalInfo":{"simple":"VkSemaphoreSignalInfo","isPointer":true}} as const;
export const vkSignalSemaphore = (input: vkSignalSemaphoreInputWithDevice | vkSignalSemaphoreInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkSignalSemaphoreParamsTypes[e[0] as keyof typeof vkSignalSemaphoreParamsTypes])];
    }));
    const result = vsnative.vts_native_vkSignalSemaphore(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdDrawIndirectCountInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  offset: uint64_t | number | Membuf;
  countBuffer: uint64_t | Membuf;
  countBufferOffset: uint64_t | number | Membuf;
  maxDrawCount: uint32_t | number | Membuf;
  stride: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdDrawIndirectCountInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  offset: uint64_t | number | Membuf;
  countBuffer: uint64_t | Membuf;
  countBufferOffset: uint64_t | number | Membuf;
  maxDrawCount: uint32_t | number | Membuf;
  stride: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdDrawIndirectCountParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"buffer":{"simple":"uint64_t","isPointer":false},"offset":{"simple":"uint64_t","isPointer":false},"countBuffer":{"simple":"uint64_t","isPointer":false},"countBufferOffset":{"simple":"uint64_t","isPointer":false},"maxDrawCount":{"simple":"uint32_t","isPointer":false},"stride":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdDrawIndirectCount = (input: vkCmdDrawIndirectCountInputWithDevice | vkCmdDrawIndirectCountInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdDrawIndirectCountParamsTypes[e[0] as keyof typeof vkCmdDrawIndirectCountParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdDrawIndirectCount(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdDrawIndexedIndirectCountInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  offset: uint64_t | number | Membuf;
  countBuffer: uint64_t | Membuf;
  countBufferOffset: uint64_t | number | Membuf;
  maxDrawCount: uint32_t | number | Membuf;
  stride: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdDrawIndexedIndirectCountInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  offset: uint64_t | number | Membuf;
  countBuffer: uint64_t | Membuf;
  countBufferOffset: uint64_t | number | Membuf;
  maxDrawCount: uint32_t | number | Membuf;
  stride: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdDrawIndexedIndirectCountParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"buffer":{"simple":"uint64_t","isPointer":false},"offset":{"simple":"uint64_t","isPointer":false},"countBuffer":{"simple":"uint64_t","isPointer":false},"countBufferOffset":{"simple":"uint64_t","isPointer":false},"maxDrawCount":{"simple":"uint32_t","isPointer":false},"stride":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdDrawIndexedIndirectCount = (input: vkCmdDrawIndexedIndirectCountInputWithDevice | vkCmdDrawIndexedIndirectCountInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdDrawIndexedIndirectCountParamsTypes[e[0] as keyof typeof vkCmdDrawIndexedIndirectCountParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdDrawIndexedIndirectCount(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdBindTransformFeedbackBuffersEXTInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  firstBinding: uint32_t | number | Membuf;
  bindingCount: uint32_t | number | Membuf;
  pBuffers: uint64_t[] | null | Membuf[] | Membuf;
  pOffsets: uint64_t[] | null | Membuf[] | Membuf;
  pSizes?: uint64_t[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdBindTransformFeedbackBuffersEXTInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  firstBinding: uint32_t | number | Membuf;
  bindingCount: uint32_t | number | Membuf;
  pBuffers: uint64_t[] | null | Membuf[] | Membuf;
  pOffsets: uint64_t[] | null | Membuf[] | Membuf;
  pSizes?: uint64_t[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdBindTransformFeedbackBuffersEXTParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"firstBinding":{"simple":"uint32_t","isPointer":false},"bindingCount":{"simple":"uint32_t","isPointer":false},"pBuffers":{"simple":"uint64_t","isPointer":true},"pOffsets":{"simple":"uint64_t","isPointer":true},"pSizes":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCmdBindTransformFeedbackBuffersEXT = (input: vkCmdBindTransformFeedbackBuffersEXTInputWithDevice | vkCmdBindTransformFeedbackBuffersEXTInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdBindTransformFeedbackBuffersEXTParamsTypes[e[0] as keyof typeof vkCmdBindTransformFeedbackBuffersEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdBindTransformFeedbackBuffersEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdBeginTransformFeedbackEXTInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  firstCounterBuffer: uint32_t | number | Membuf;
  counterBufferCount: uint32_t | nullptr_t | number | Membuf;
  pCounterBuffers: uint64_t[] | null | Membuf[] | Membuf;
  pCounterBufferOffsets?: uint64_t[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdBeginTransformFeedbackEXTInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  firstCounterBuffer: uint32_t | number | Membuf;
  counterBufferCount: uint32_t | nullptr_t | number | Membuf;
  pCounterBuffers: uint64_t[] | null | Membuf[] | Membuf;
  pCounterBufferOffsets?: uint64_t[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdBeginTransformFeedbackEXTParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"firstCounterBuffer":{"simple":"uint32_t","isPointer":false},"counterBufferCount":{"simple":"uint32_t","isPointer":false},"pCounterBuffers":{"simple":"uint64_t","isPointer":true},"pCounterBufferOffsets":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCmdBeginTransformFeedbackEXT = (input: vkCmdBeginTransformFeedbackEXTInputWithDevice | vkCmdBeginTransformFeedbackEXTInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdBeginTransformFeedbackEXTParamsTypes[e[0] as keyof typeof vkCmdBeginTransformFeedbackEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdBeginTransformFeedbackEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdEndTransformFeedbackEXTInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  firstCounterBuffer: uint32_t | number | Membuf;
  counterBufferCount: uint32_t | nullptr_t | number | Membuf;
  pCounterBuffers: uint64_t[] | null | Membuf[] | Membuf;
  pCounterBufferOffsets?: uint64_t[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdEndTransformFeedbackEXTInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  firstCounterBuffer: uint32_t | number | Membuf;
  counterBufferCount: uint32_t | nullptr_t | number | Membuf;
  pCounterBuffers: uint64_t[] | null | Membuf[] | Membuf;
  pCounterBufferOffsets?: uint64_t[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdEndTransformFeedbackEXTParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"firstCounterBuffer":{"simple":"uint32_t","isPointer":false},"counterBufferCount":{"simple":"uint32_t","isPointer":false},"pCounterBuffers":{"simple":"uint64_t","isPointer":true},"pCounterBufferOffsets":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCmdEndTransformFeedbackEXT = (input: vkCmdEndTransformFeedbackEXTInputWithDevice | vkCmdEndTransformFeedbackEXTInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdEndTransformFeedbackEXTParamsTypes[e[0] as keyof typeof vkCmdEndTransformFeedbackEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdEndTransformFeedbackEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdBeginQueryIndexedEXTInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  queryPool: uint64_t | Membuf;
  query: uint32_t | number | Membuf;
  flags: uint32_t | nullptr_t | number | Membuf;
  index: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdBeginQueryIndexedEXTInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  queryPool: uint64_t | Membuf;
  query: uint32_t | number | Membuf;
  flags: uint32_t | nullptr_t | number | Membuf;
  index: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdBeginQueryIndexedEXTParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"queryPool":{"simple":"uint64_t","isPointer":false},"query":{"simple":"uint32_t","isPointer":false},"flags":{"simple":"uint32_t","isPointer":false},"index":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdBeginQueryIndexedEXT = (input: vkCmdBeginQueryIndexedEXTInputWithDevice | vkCmdBeginQueryIndexedEXTInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdBeginQueryIndexedEXTParamsTypes[e[0] as keyof typeof vkCmdBeginQueryIndexedEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdBeginQueryIndexedEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdEndQueryIndexedEXTInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  queryPool: uint64_t | Membuf;
  query: uint32_t | number | Membuf;
  index: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdEndQueryIndexedEXTInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  queryPool: uint64_t | Membuf;
  query: uint32_t | number | Membuf;
  index: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdEndQueryIndexedEXTParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"queryPool":{"simple":"uint64_t","isPointer":false},"query":{"simple":"uint32_t","isPointer":false},"index":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdEndQueryIndexedEXT = (input: vkCmdEndQueryIndexedEXTInputWithDevice | vkCmdEndQueryIndexedEXTInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdEndQueryIndexedEXTParamsTypes[e[0] as keyof typeof vkCmdEndQueryIndexedEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdEndQueryIndexedEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdDrawIndirectByteCountEXTInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  instanceCount: uint32_t | number | Membuf;
  firstInstance: uint32_t | number | Membuf;
  counterBuffer: uint64_t | Membuf;
  counterBufferOffset: uint64_t | number | Membuf;
  counterOffset: uint32_t | number | Membuf;
  vertexStride: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdDrawIndirectByteCountEXTInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  instanceCount: uint32_t | number | Membuf;
  firstInstance: uint32_t | number | Membuf;
  counterBuffer: uint64_t | Membuf;
  counterBufferOffset: uint64_t | number | Membuf;
  counterOffset: uint32_t | number | Membuf;
  vertexStride: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdDrawIndirectByteCountEXTParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"instanceCount":{"simple":"uint32_t","isPointer":false},"firstInstance":{"simple":"uint32_t","isPointer":false},"counterBuffer":{"simple":"uint64_t","isPointer":false},"counterBufferOffset":{"simple":"uint64_t","isPointer":false},"counterOffset":{"simple":"uint32_t","isPointer":false},"vertexStride":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdDrawIndirectByteCountEXT = (input: vkCmdDrawIndirectByteCountEXTInputWithDevice | vkCmdDrawIndirectByteCountEXTInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdDrawIndirectByteCountEXTParamsTypes[e[0] as keyof typeof vkCmdDrawIndirectByteCountEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdDrawIndirectByteCountEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdDrawMeshTasksEXTInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  groupCountX: uint32_t | number | Membuf;
  groupCountY: uint32_t | number | Membuf;
  groupCountZ: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdDrawMeshTasksEXTInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  groupCountX: uint32_t | number | Membuf;
  groupCountY: uint32_t | number | Membuf;
  groupCountZ: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdDrawMeshTasksEXTParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"groupCountX":{"simple":"uint32_t","isPointer":false},"groupCountY":{"simple":"uint32_t","isPointer":false},"groupCountZ":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdDrawMeshTasksEXT = (input: vkCmdDrawMeshTasksEXTInputWithDevice | vkCmdDrawMeshTasksEXTInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdDrawMeshTasksEXTParamsTypes[e[0] as keyof typeof vkCmdDrawMeshTasksEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdDrawMeshTasksEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdDrawMeshTasksIndirectEXTInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  offset: uint64_t | number | Membuf;
  drawCount: uint32_t | number | Membuf;
  stride: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdDrawMeshTasksIndirectEXTInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  offset: uint64_t | number | Membuf;
  drawCount: uint32_t | number | Membuf;
  stride: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdDrawMeshTasksIndirectEXTParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"buffer":{"simple":"uint64_t","isPointer":false},"offset":{"simple":"uint64_t","isPointer":false},"drawCount":{"simple":"uint32_t","isPointer":false},"stride":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdDrawMeshTasksIndirectEXT = (input: vkCmdDrawMeshTasksIndirectEXTInputWithDevice | vkCmdDrawMeshTasksIndirectEXTInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdDrawMeshTasksIndirectEXTParamsTypes[e[0] as keyof typeof vkCmdDrawMeshTasksIndirectEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdDrawMeshTasksIndirectEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdDrawMeshTasksIndirectCountEXTInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  offset: uint64_t | number | Membuf;
  countBuffer: uint64_t | Membuf;
  countBufferOffset: uint64_t | number | Membuf;
  maxDrawCount: uint32_t | number | Membuf;
  stride: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdDrawMeshTasksIndirectCountEXTInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  buffer: uint64_t | Membuf;
  offset: uint64_t | number | Membuf;
  countBuffer: uint64_t | Membuf;
  countBufferOffset: uint64_t | number | Membuf;
  maxDrawCount: uint32_t | number | Membuf;
  stride: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdDrawMeshTasksIndirectCountEXTParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"buffer":{"simple":"uint64_t","isPointer":false},"offset":{"simple":"uint64_t","isPointer":false},"countBuffer":{"simple":"uint64_t","isPointer":false},"countBufferOffset":{"simple":"uint64_t","isPointer":false},"maxDrawCount":{"simple":"uint32_t","isPointer":false},"stride":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdDrawMeshTasksIndirectCountEXT = (input: vkCmdDrawMeshTasksIndirectCountEXTInputWithDevice | vkCmdDrawMeshTasksIndirectCountEXTInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdDrawMeshTasksIndirectCountEXTParamsTypes[e[0] as keyof typeof vkCmdDrawMeshTasksIndirectCountEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdDrawMeshTasksIndirectCountEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdTraceRaysKHRInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pRaygenShaderBindingTable: VkStridedDeviceAddressRegionKHR| null | Membuf;
  pMissShaderBindingTable: VkStridedDeviceAddressRegionKHR| null | Membuf;
  pHitShaderBindingTable: VkStridedDeviceAddressRegionKHR| null | Membuf;
  pCallableShaderBindingTable: VkStridedDeviceAddressRegionKHR| null | Membuf;
  width: uint32_t | number | Membuf;
  height: uint32_t | number | Membuf;
  depth: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdTraceRaysKHRInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pRaygenShaderBindingTable: VkStridedDeviceAddressRegionKHR| null | Membuf;
  pMissShaderBindingTable: VkStridedDeviceAddressRegionKHR| null | Membuf;
  pHitShaderBindingTable: VkStridedDeviceAddressRegionKHR| null | Membuf;
  pCallableShaderBindingTable: VkStridedDeviceAddressRegionKHR| null | Membuf;
  width: uint32_t | number | Membuf;
  height: uint32_t | number | Membuf;
  depth: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdTraceRaysKHRParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pRaygenShaderBindingTable":{"simple":"VkStridedDeviceAddressRegionKHR","isPointer":true},"pMissShaderBindingTable":{"simple":"VkStridedDeviceAddressRegionKHR","isPointer":true},"pHitShaderBindingTable":{"simple":"VkStridedDeviceAddressRegionKHR","isPointer":true},"pCallableShaderBindingTable":{"simple":"VkStridedDeviceAddressRegionKHR","isPointer":true},"width":{"simple":"uint32_t","isPointer":false},"height":{"simple":"uint32_t","isPointer":false},"depth":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdTraceRaysKHR = (input: vkCmdTraceRaysKHRInputWithDevice | vkCmdTraceRaysKHRInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdTraceRaysKHRParamsTypes[e[0] as keyof typeof vkCmdTraceRaysKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdTraceRaysKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetRayTracingShaderGroupHandlesKHRInputWithDevice {
  device: uint64_t | Membuf;
  pipeline: uint64_t | Membuf;
  firstGroup: uint32_t | number | Membuf;
  groupCount: uint32_t | number | Membuf;
  dataSize: size_t | number | Membuf;
  pData: uint64_t[] | null | Membuf[] | Membuf;
}
export interface vkGetRayTracingShaderGroupHandlesKHRInputWithInstance {
  device: uint64_t | Membuf;
  pipeline: uint64_t | Membuf;
  firstGroup: uint32_t | number | Membuf;
  groupCount: uint32_t | number | Membuf;
  dataSize: size_t | number | Membuf;
  pData: uint64_t[] | null | Membuf[] | Membuf;
}

const vkGetRayTracingShaderGroupHandlesKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pipeline":{"simple":"uint64_t","isPointer":false},"firstGroup":{"simple":"uint32_t","isPointer":false},"groupCount":{"simple":"uint32_t","isPointer":false},"dataSize":{"simple":"size_t","isPointer":false},"pData":{"simple":"uint64_t","isPointer":true}} as const;
export const vkGetRayTracingShaderGroupHandlesKHR = (input: vkGetRayTracingShaderGroupHandlesKHRInputWithDevice | vkGetRayTracingShaderGroupHandlesKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetRayTracingShaderGroupHandlesKHRParamsTypes[e[0] as keyof typeof vkGetRayTracingShaderGroupHandlesKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetRayTracingShaderGroupHandlesKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetRayTracingCaptureReplayShaderGroupHandlesKHRInputWithDevice {
  device: uint64_t | Membuf;
  pipeline: uint64_t | Membuf;
  firstGroup: uint32_t | number | Membuf;
  groupCount: uint32_t | number | Membuf;
  dataSize: size_t | number | Membuf;
  pData: uint64_t[] | null | Membuf[] | Membuf;
}
export interface vkGetRayTracingCaptureReplayShaderGroupHandlesKHRInputWithInstance {
  device: uint64_t | Membuf;
  pipeline: uint64_t | Membuf;
  firstGroup: uint32_t | number | Membuf;
  groupCount: uint32_t | number | Membuf;
  dataSize: size_t | number | Membuf;
  pData: uint64_t[] | null | Membuf[] | Membuf;
}

const vkGetRayTracingCaptureReplayShaderGroupHandlesKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pipeline":{"simple":"uint64_t","isPointer":false},"firstGroup":{"simple":"uint32_t","isPointer":false},"groupCount":{"simple":"uint32_t","isPointer":false},"dataSize":{"simple":"size_t","isPointer":false},"pData":{"simple":"uint64_t","isPointer":true}} as const;
export const vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = (input: vkGetRayTracingCaptureReplayShaderGroupHandlesKHRInputWithDevice | vkGetRayTracingCaptureReplayShaderGroupHandlesKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetRayTracingCaptureReplayShaderGroupHandlesKHRParamsTypes[e[0] as keyof typeof vkGetRayTracingCaptureReplayShaderGroupHandlesKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateRayTracingPipelinesKHRInputWithDevice {
  device: uint64_t | Membuf;
  deferredOperation: uint64_t | nullptr_t | Membuf;
  pipelineCache: uint64_t | nullptr_t | Membuf;
  createInfoCount: uint32_t | number | Membuf;
  pCreateInfos: VkRayTracingPipelineCreateInfoKHR[] | null | Membuf[] | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pPipelines: uint64_t[] | null | Membuf[] | Membuf;
}
export interface vkCreateRayTracingPipelinesKHRInputWithInstance {
  device: uint64_t | Membuf;
  deferredOperation: uint64_t | nullptr_t | Membuf;
  pipelineCache: uint64_t | nullptr_t | Membuf;
  createInfoCount: uint32_t | number | Membuf;
  pCreateInfos: VkRayTracingPipelineCreateInfoKHR[] | null | Membuf[] | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pPipelines: uint64_t[] | null | Membuf[] | Membuf;
}

const vkCreateRayTracingPipelinesKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"deferredOperation":{"simple":"uint64_t","isPointer":false},"pipelineCache":{"simple":"uint64_t","isPointer":false},"createInfoCount":{"simple":"uint32_t","isPointer":false},"pCreateInfos":{"simple":"VkRayTracingPipelineCreateInfoKHR","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pPipelines":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateRayTracingPipelinesKHR = (input: vkCreateRayTracingPipelinesKHRInputWithDevice | vkCreateRayTracingPipelinesKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_OPERATION_DEFERRED_KHR | VkResult.VK_OPERATION_NOT_DEFERRED_KHR | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateRayTracingPipelinesKHRParamsTypes[e[0] as keyof typeof vkCreateRayTracingPipelinesKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateRayTracingPipelinesKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdTraceRaysIndirectKHRInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pRaygenShaderBindingTable: VkStridedDeviceAddressRegionKHR| null | Membuf;
  pMissShaderBindingTable: VkStridedDeviceAddressRegionKHR| null | Membuf;
  pHitShaderBindingTable: VkStridedDeviceAddressRegionKHR| null | Membuf;
  pCallableShaderBindingTable: VkStridedDeviceAddressRegionKHR| null | Membuf;
  indirectDeviceAddress: uint64_t | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdTraceRaysIndirectKHRInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pRaygenShaderBindingTable: VkStridedDeviceAddressRegionKHR| null | Membuf;
  pMissShaderBindingTable: VkStridedDeviceAddressRegionKHR| null | Membuf;
  pHitShaderBindingTable: VkStridedDeviceAddressRegionKHR| null | Membuf;
  pCallableShaderBindingTable: VkStridedDeviceAddressRegionKHR| null | Membuf;
  indirectDeviceAddress: uint64_t | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdTraceRaysIndirectKHRParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pRaygenShaderBindingTable":{"simple":"VkStridedDeviceAddressRegionKHR","isPointer":true},"pMissShaderBindingTable":{"simple":"VkStridedDeviceAddressRegionKHR","isPointer":true},"pHitShaderBindingTable":{"simple":"VkStridedDeviceAddressRegionKHR","isPointer":true},"pCallableShaderBindingTable":{"simple":"VkStridedDeviceAddressRegionKHR","isPointer":true},"indirectDeviceAddress":{"simple":"uint64_t","isPointer":false}} as const;
export const vkCmdTraceRaysIndirectKHR = (input: vkCmdTraceRaysIndirectKHRInputWithDevice | vkCmdTraceRaysIndirectKHRInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdTraceRaysIndirectKHRParamsTypes[e[0] as keyof typeof vkCmdTraceRaysIndirectKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdTraceRaysIndirectKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdTraceRaysIndirect2KHRInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  indirectDeviceAddress: uint64_t | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdTraceRaysIndirect2KHRInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  indirectDeviceAddress: uint64_t | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdTraceRaysIndirect2KHRParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"indirectDeviceAddress":{"simple":"uint64_t","isPointer":false}} as const;
export const vkCmdTraceRaysIndirect2KHR = (input: vkCmdTraceRaysIndirect2KHRInputWithDevice | vkCmdTraceRaysIndirect2KHRInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdTraceRaysIndirect2KHRParamsTypes[e[0] as keyof typeof vkCmdTraceRaysIndirect2KHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdTraceRaysIndirect2KHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetRayTracingShaderGroupStackSizeKHRInputWithDevice {
  device: uint64_t | Membuf;
  pipeline: uint64_t | Membuf;
  group: uint32_t | number | Membuf;
  groupShader: int32_t | number | Membuf;
}
export interface vkGetRayTracingShaderGroupStackSizeKHRInputWithInstance {
  device: uint64_t | Membuf;
  pipeline: uint64_t | Membuf;
  group: uint32_t | number | Membuf;
  groupShader: int32_t | number | Membuf;
}

const vkGetRayTracingShaderGroupStackSizeKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pipeline":{"simple":"uint64_t","isPointer":false},"group":{"simple":"uint32_t","isPointer":false},"groupShader":{"simple":"int32_t","isPointer":false}} as const;
export const vkGetRayTracingShaderGroupStackSizeKHR = (input: vkGetRayTracingShaderGroupStackSizeKHRInputWithDevice | vkGetRayTracingShaderGroupStackSizeKHRInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetRayTracingShaderGroupStackSizeKHRParamsTypes[e[0] as keyof typeof vkGetRayTracingShaderGroupStackSizeKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetRayTracingShaderGroupStackSizeKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetRayTracingPipelineStackSizeKHRInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pipelineStackSize: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetRayTracingPipelineStackSizeKHRInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pipelineStackSize: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetRayTracingPipelineStackSizeKHRParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pipelineStackSize":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdSetRayTracingPipelineStackSizeKHR = (input: vkCmdSetRayTracingPipelineStackSizeKHRInputWithDevice | vkCmdSetRayTracingPipelineStackSizeKHRInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetRayTracingPipelineStackSizeKHRParamsTypes[e[0] as keyof typeof vkCmdSetRayTracingPipelineStackSizeKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetRayTracingPipelineStackSizeKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetImageDrmFormatModifierPropertiesEXTInputWithDevice {
  device: uint64_t | Membuf;
  image: uint64_t | Membuf;
  pProperties: VkImageDrmFormatModifierPropertiesEXT| null | Membuf;
}
export interface vkGetImageDrmFormatModifierPropertiesEXTInputWithInstance {
  device: uint64_t | Membuf;
  image: uint64_t | Membuf;
  pProperties: VkImageDrmFormatModifierPropertiesEXT| null | Membuf;
}

const vkGetImageDrmFormatModifierPropertiesEXTParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"image":{"simple":"uint64_t","isPointer":false},"pProperties":{"simple":"VkImageDrmFormatModifierPropertiesEXT","isPointer":true}} as const;
export const vkGetImageDrmFormatModifierPropertiesEXT = (input: vkGetImageDrmFormatModifierPropertiesEXTInputWithDevice | vkGetImageDrmFormatModifierPropertiesEXTInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetImageDrmFormatModifierPropertiesEXTParamsTypes[e[0] as keyof typeof vkGetImageDrmFormatModifierPropertiesEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetImageDrmFormatModifierPropertiesEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetBufferOpaqueCaptureAddressInputWithDevice {
  device: uint64_t | Membuf;
  pInfo: VkBufferDeviceAddressInfo| null | Membuf;
}
export interface vkGetBufferOpaqueCaptureAddressInputWithInstance {
  device: uint64_t | Membuf;
  pInfo: VkBufferDeviceAddressInfo| null | Membuf;
}

const vkGetBufferOpaqueCaptureAddressParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pInfo":{"simple":"VkBufferDeviceAddressInfo","isPointer":true}} as const;
export const vkGetBufferOpaqueCaptureAddress = (input: vkGetBufferOpaqueCaptureAddressInputWithDevice | vkGetBufferOpaqueCaptureAddressInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetBufferOpaqueCaptureAddressParamsTypes[e[0] as keyof typeof vkGetBufferOpaqueCaptureAddressParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetBufferOpaqueCaptureAddress(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetBufferDeviceAddressInputWithDevice {
  device: uint64_t | Membuf;
  pInfo: VkBufferDeviceAddressInfo| null | Membuf;
}
export interface vkGetBufferDeviceAddressInputWithInstance {
  device: uint64_t | Membuf;
  pInfo: VkBufferDeviceAddressInfo| null | Membuf;
}

const vkGetBufferDeviceAddressParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pInfo":{"simple":"VkBufferDeviceAddressInfo","isPointer":true}} as const;
export const vkGetBufferDeviceAddress = (input: vkGetBufferDeviceAddressInputWithDevice | vkGetBufferDeviceAddressInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetBufferDeviceAddressParamsTypes[e[0] as keyof typeof vkGetBufferDeviceAddressParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetBufferDeviceAddress(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateHeadlessSurfaceEXTInputWithDevice {
  instance: uint64_t | Membuf;
  pCreateInfo: VkHeadlessSurfaceCreateInfoEXT| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pSurface: uint64_t| null | Membuf;
}
export interface vkCreateHeadlessSurfaceEXTInputWithInstance {
  instance: uint64_t | Membuf;
  pCreateInfo: VkHeadlessSurfaceCreateInfoEXT| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pSurface: uint64_t| null | Membuf;
}

const vkCreateHeadlessSurfaceEXTParamsTypes = {"instance":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkHeadlessSurfaceCreateInfoEXT","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pSurface":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateHeadlessSurfaceEXT = (input: vkCreateHeadlessSurfaceEXTInputWithDevice | vkCreateHeadlessSurfaceEXTInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateHeadlessSurfaceEXTParamsTypes[e[0] as keyof typeof vkCreateHeadlessSurfaceEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateHeadlessSurfaceEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetDeviceMemoryOpaqueCaptureAddressInputWithDevice {
  device: uint64_t | Membuf;
  pInfo: VkDeviceMemoryOpaqueCaptureAddressInfo| null | Membuf;
}
export interface vkGetDeviceMemoryOpaqueCaptureAddressInputWithInstance {
  device: uint64_t | Membuf;
  pInfo: VkDeviceMemoryOpaqueCaptureAddressInfo| null | Membuf;
}

const vkGetDeviceMemoryOpaqueCaptureAddressParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pInfo":{"simple":"VkDeviceMemoryOpaqueCaptureAddressInfo","isPointer":true}} as const;
export const vkGetDeviceMemoryOpaqueCaptureAddress = (input: vkGetDeviceMemoryOpaqueCaptureAddressInputWithDevice | vkGetDeviceMemoryOpaqueCaptureAddressInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetDeviceMemoryOpaqueCaptureAddressParamsTypes[e[0] as keyof typeof vkGetDeviceMemoryOpaqueCaptureAddressParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetDeviceMemoryOpaqueCaptureAddress(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetLineStippleEXTInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  lineStippleFactor: uint32_t | number | Membuf;
  lineStipplePattern: uint16_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetLineStippleEXTInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  lineStippleFactor: uint32_t | number | Membuf;
  lineStipplePattern: uint16_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetLineStippleEXTParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"lineStippleFactor":{"simple":"uint32_t","isPointer":false},"lineStipplePattern":{"simple":"uint16_t","isPointer":false}} as const;
export const vkCmdSetLineStippleEXT = (input: vkCmdSetLineStippleEXTInputWithDevice | vkCmdSetLineStippleEXTInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetLineStippleEXTParamsTypes[e[0] as keyof typeof vkCmdSetLineStippleEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetLineStippleEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceToolPropertiesInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pToolCount: uint32_t| null | Membuf;
  pToolProperties?: VkPhysicalDeviceToolProperties[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceToolPropertiesInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pToolCount: uint32_t| null | Membuf;
  pToolProperties?: VkPhysicalDeviceToolProperties[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceToolPropertiesParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pToolCount":{"simple":"uint32_t","isPointer":true},"pToolProperties":{"simple":"VkPhysicalDeviceToolProperties","isPointer":true}} as const;
export const vkGetPhysicalDeviceToolProperties = (input: vkGetPhysicalDeviceToolPropertiesInputWithDevice | vkGetPhysicalDeviceToolPropertiesInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceToolPropertiesParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceToolPropertiesParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceToolProperties(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateDeferredOperationKHRInputWithDevice {
  device: uint64_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pDeferredOperation: uint64_t| null | Membuf;
}
export interface vkCreateDeferredOperationKHRInputWithInstance {
  device: uint64_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pDeferredOperation: uint64_t| null | Membuf;
}

const vkCreateDeferredOperationKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pDeferredOperation":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateDeferredOperationKHR = (input: vkCreateDeferredOperationKHRInputWithDevice | vkCreateDeferredOperationKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateDeferredOperationKHRParamsTypes[e[0] as keyof typeof vkCreateDeferredOperationKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateDeferredOperationKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyDeferredOperationKHRInputWithDevice {
  device: uint64_t | Membuf;
  operation: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyDeferredOperationKHRInputWithInstance {
  device: uint64_t | Membuf;
  operation: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyDeferredOperationKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"operation":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyDeferredOperationKHR = (input: vkDestroyDeferredOperationKHRInputWithDevice | vkDestroyDeferredOperationKHRInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyDeferredOperationKHRParamsTypes[e[0] as keyof typeof vkDestroyDeferredOperationKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyDeferredOperationKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetDeferredOperationMaxConcurrencyKHRInputWithDevice {
  device: uint64_t | Membuf;
  operation: uint64_t | Membuf;
}
export interface vkGetDeferredOperationMaxConcurrencyKHRInputWithInstance {
  device: uint64_t | Membuf;
  operation: uint64_t | Membuf;
}

const vkGetDeferredOperationMaxConcurrencyKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"operation":{"simple":"uint64_t","isPointer":false}} as const;
export const vkGetDeferredOperationMaxConcurrencyKHR = (input: vkGetDeferredOperationMaxConcurrencyKHRInputWithDevice | vkGetDeferredOperationMaxConcurrencyKHRInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetDeferredOperationMaxConcurrencyKHRParamsTypes[e[0] as keyof typeof vkGetDeferredOperationMaxConcurrencyKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetDeferredOperationMaxConcurrencyKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetDeferredOperationResultKHRInputWithDevice {
  device: uint64_t | Membuf;
  operation: uint64_t | Membuf;
}
export interface vkGetDeferredOperationResultKHRInputWithInstance {
  device: uint64_t | Membuf;
  operation: uint64_t | Membuf;
}

const vkGetDeferredOperationResultKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"operation":{"simple":"uint64_t","isPointer":false}} as const;
export const vkGetDeferredOperationResultKHR = (input: vkGetDeferredOperationResultKHRInputWithDevice | vkGetDeferredOperationResultKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_NOT_READY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetDeferredOperationResultKHRParamsTypes[e[0] as keyof typeof vkGetDeferredOperationResultKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetDeferredOperationResultKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDeferredOperationJoinKHRInputWithDevice {
  device: uint64_t | Membuf;
  operation: uint64_t | Membuf;
}
export interface vkDeferredOperationJoinKHRInputWithInstance {
  device: uint64_t | Membuf;
  operation: uint64_t | Membuf;
}

const vkDeferredOperationJoinKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"operation":{"simple":"uint64_t","isPointer":false}} as const;
export const vkDeferredOperationJoinKHR = (input: vkDeferredOperationJoinKHRInputWithDevice | vkDeferredOperationJoinKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_THREAD_DONE_KHR | VkResult.VK_THREAD_IDLE_KHR | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDeferredOperationJoinKHRParamsTypes[e[0] as keyof typeof vkDeferredOperationJoinKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDeferredOperationJoinKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetCullModeInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  cullMode: uint32_t | nullptr_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetCullModeInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  cullMode: uint32_t | nullptr_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetCullModeParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"cullMode":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdSetCullMode = (input: vkCmdSetCullModeInputWithDevice | vkCmdSetCullModeInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetCullModeParamsTypes[e[0] as keyof typeof vkCmdSetCullModeParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetCullMode(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetFrontFaceInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  frontFace: int32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetFrontFaceInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  frontFace: int32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetFrontFaceParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"frontFace":{"simple":"int32_t","isPointer":false}} as const;
export const vkCmdSetFrontFace = (input: vkCmdSetFrontFaceInputWithDevice | vkCmdSetFrontFaceInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetFrontFaceParamsTypes[e[0] as keyof typeof vkCmdSetFrontFaceParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetFrontFace(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetPrimitiveTopologyInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  primitiveTopology: int32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetPrimitiveTopologyInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  primitiveTopology: int32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetPrimitiveTopologyParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"primitiveTopology":{"simple":"int32_t","isPointer":false}} as const;
export const vkCmdSetPrimitiveTopology = (input: vkCmdSetPrimitiveTopologyInputWithDevice | vkCmdSetPrimitiveTopologyInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetPrimitiveTopologyParamsTypes[e[0] as keyof typeof vkCmdSetPrimitiveTopologyParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetPrimitiveTopology(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetViewportWithCountInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  viewportCount: uint32_t | number | Membuf;
  pViewports: VkViewport[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetViewportWithCountInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  viewportCount: uint32_t | number | Membuf;
  pViewports: VkViewport[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetViewportWithCountParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"viewportCount":{"simple":"uint32_t","isPointer":false},"pViewports":{"simple":"VkViewport","isPointer":true}} as const;
export const vkCmdSetViewportWithCount = (input: vkCmdSetViewportWithCountInputWithDevice | vkCmdSetViewportWithCountInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetViewportWithCountParamsTypes[e[0] as keyof typeof vkCmdSetViewportWithCountParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetViewportWithCount(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetScissorWithCountInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  scissorCount: uint32_t | number | Membuf;
  pScissors: VkRect2D[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetScissorWithCountInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  scissorCount: uint32_t | number | Membuf;
  pScissors: VkRect2D[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetScissorWithCountParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"scissorCount":{"simple":"uint32_t","isPointer":false},"pScissors":{"simple":"VkRect2D","isPointer":true}} as const;
export const vkCmdSetScissorWithCount = (input: vkCmdSetScissorWithCountInputWithDevice | vkCmdSetScissorWithCountInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetScissorWithCountParamsTypes[e[0] as keyof typeof vkCmdSetScissorWithCountParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetScissorWithCount(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdBindVertexBuffers2InputWithDevice {
  commandBuffer: uint64_t | Membuf;
  firstBinding: uint32_t | number | Membuf;
  bindingCount: uint32_t | number | Membuf;
  pBuffers: uint64_t[] | null | Membuf[] | Membuf;
  pOffsets: uint64_t[] | null | Membuf[] | Membuf;
  pSizes?: uint64_t[] | null | Membuf[] | Membuf;
  pStrides?: uint64_t[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdBindVertexBuffers2InputWithInstance {
  commandBuffer: uint64_t | Membuf;
  firstBinding: uint32_t | number | Membuf;
  bindingCount: uint32_t | number | Membuf;
  pBuffers: uint64_t[] | null | Membuf[] | Membuf;
  pOffsets: uint64_t[] | null | Membuf[] | Membuf;
  pSizes?: uint64_t[] | null | Membuf[] | Membuf;
  pStrides?: uint64_t[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdBindVertexBuffers2ParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"firstBinding":{"simple":"uint32_t","isPointer":false},"bindingCount":{"simple":"uint32_t","isPointer":false},"pBuffers":{"simple":"uint64_t","isPointer":true},"pOffsets":{"simple":"uint64_t","isPointer":true},"pSizes":{"simple":"uint64_t","isPointer":true},"pStrides":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCmdBindVertexBuffers2 = (input: vkCmdBindVertexBuffers2InputWithDevice | vkCmdBindVertexBuffers2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdBindVertexBuffers2ParamsTypes[e[0] as keyof typeof vkCmdBindVertexBuffers2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdBindVertexBuffers2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetDepthTestEnableInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  depthTestEnable: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetDepthTestEnableInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  depthTestEnable: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetDepthTestEnableParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"depthTestEnable":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdSetDepthTestEnable = (input: vkCmdSetDepthTestEnableInputWithDevice | vkCmdSetDepthTestEnableInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetDepthTestEnableParamsTypes[e[0] as keyof typeof vkCmdSetDepthTestEnableParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetDepthTestEnable(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetDepthWriteEnableInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  depthWriteEnable: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetDepthWriteEnableInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  depthWriteEnable: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetDepthWriteEnableParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"depthWriteEnable":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdSetDepthWriteEnable = (input: vkCmdSetDepthWriteEnableInputWithDevice | vkCmdSetDepthWriteEnableInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetDepthWriteEnableParamsTypes[e[0] as keyof typeof vkCmdSetDepthWriteEnableParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetDepthWriteEnable(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetDepthCompareOpInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  depthCompareOp: int32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetDepthCompareOpInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  depthCompareOp: int32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetDepthCompareOpParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"depthCompareOp":{"simple":"int32_t","isPointer":false}} as const;
export const vkCmdSetDepthCompareOp = (input: vkCmdSetDepthCompareOpInputWithDevice | vkCmdSetDepthCompareOpInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetDepthCompareOpParamsTypes[e[0] as keyof typeof vkCmdSetDepthCompareOpParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetDepthCompareOp(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetDepthBoundsTestEnableInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  depthBoundsTestEnable: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetDepthBoundsTestEnableInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  depthBoundsTestEnable: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetDepthBoundsTestEnableParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"depthBoundsTestEnable":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdSetDepthBoundsTestEnable = (input: vkCmdSetDepthBoundsTestEnableInputWithDevice | vkCmdSetDepthBoundsTestEnableInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetDepthBoundsTestEnableParamsTypes[e[0] as keyof typeof vkCmdSetDepthBoundsTestEnableParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetDepthBoundsTestEnable(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetStencilTestEnableInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  stencilTestEnable: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetStencilTestEnableInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  stencilTestEnable: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetStencilTestEnableParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"stencilTestEnable":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdSetStencilTestEnable = (input: vkCmdSetStencilTestEnableInputWithDevice | vkCmdSetStencilTestEnableInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetStencilTestEnableParamsTypes[e[0] as keyof typeof vkCmdSetStencilTestEnableParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetStencilTestEnable(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetStencilOpInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  faceMask: uint32_t | number | Membuf;
  failOp: int32_t | number | Membuf;
  passOp: int32_t | number | Membuf;
  depthFailOp: int32_t | number | Membuf;
  compareOp: int32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetStencilOpInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  faceMask: uint32_t | number | Membuf;
  failOp: int32_t | number | Membuf;
  passOp: int32_t | number | Membuf;
  depthFailOp: int32_t | number | Membuf;
  compareOp: int32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetStencilOpParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"faceMask":{"simple":"uint32_t","isPointer":false},"failOp":{"simple":"int32_t","isPointer":false},"passOp":{"simple":"int32_t","isPointer":false},"depthFailOp":{"simple":"int32_t","isPointer":false},"compareOp":{"simple":"int32_t","isPointer":false}} as const;
export const vkCmdSetStencilOp = (input: vkCmdSetStencilOpInputWithDevice | vkCmdSetStencilOpInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetStencilOpParamsTypes[e[0] as keyof typeof vkCmdSetStencilOpParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetStencilOp(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetRasterizerDiscardEnableInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  rasterizerDiscardEnable: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetRasterizerDiscardEnableInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  rasterizerDiscardEnable: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetRasterizerDiscardEnableParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"rasterizerDiscardEnable":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdSetRasterizerDiscardEnable = (input: vkCmdSetRasterizerDiscardEnableInputWithDevice | vkCmdSetRasterizerDiscardEnableInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetRasterizerDiscardEnableParamsTypes[e[0] as keyof typeof vkCmdSetRasterizerDiscardEnableParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetRasterizerDiscardEnable(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetDepthBiasEnableInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  depthBiasEnable: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetDepthBiasEnableInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  depthBiasEnable: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetDepthBiasEnableParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"depthBiasEnable":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdSetDepthBiasEnable = (input: vkCmdSetDepthBiasEnableInputWithDevice | vkCmdSetDepthBiasEnableInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetDepthBiasEnableParamsTypes[e[0] as keyof typeof vkCmdSetDepthBiasEnableParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetDepthBiasEnable(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetPrimitiveRestartEnableInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  primitiveRestartEnable: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetPrimitiveRestartEnableInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  primitiveRestartEnable: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetPrimitiveRestartEnableParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"primitiveRestartEnable":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdSetPrimitiveRestartEnable = (input: vkCmdSetPrimitiveRestartEnableInputWithDevice | vkCmdSetPrimitiveRestartEnableInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetPrimitiveRestartEnableParamsTypes[e[0] as keyof typeof vkCmdSetPrimitiveRestartEnableParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetPrimitiveRestartEnable(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreatePrivateDataSlotInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkPrivateDataSlotCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pPrivateDataSlot: uint64_t| null | Membuf;
}
export interface vkCreatePrivateDataSlotInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkPrivateDataSlotCreateInfo| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pPrivateDataSlot: uint64_t| null | Membuf;
}

const vkCreatePrivateDataSlotParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkPrivateDataSlotCreateInfo","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pPrivateDataSlot":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreatePrivateDataSlot = (input: vkCreatePrivateDataSlotInputWithDevice | vkCreatePrivateDataSlotInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreatePrivateDataSlotParamsTypes[e[0] as keyof typeof vkCreatePrivateDataSlotParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreatePrivateDataSlot(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyPrivateDataSlotInputWithDevice {
  device: uint64_t | Membuf;
  privateDataSlot: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyPrivateDataSlotInputWithInstance {
  device: uint64_t | Membuf;
  privateDataSlot: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyPrivateDataSlotParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"privateDataSlot":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyPrivateDataSlot = (input: vkDestroyPrivateDataSlotInputWithDevice | vkDestroyPrivateDataSlotInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyPrivateDataSlotParamsTypes[e[0] as keyof typeof vkDestroyPrivateDataSlotParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyPrivateDataSlot(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkSetPrivateDataInputWithDevice {
  device: uint64_t | Membuf;
  objectType: int32_t | number | Membuf;
  objectHandle: uint64_t | number | Membuf;
  privateDataSlot: uint64_t | Membuf;
  data: uint64_t | number | Membuf;
}
export interface vkSetPrivateDataInputWithInstance {
  device: uint64_t | Membuf;
  objectType: int32_t | number | Membuf;
  objectHandle: uint64_t | number | Membuf;
  privateDataSlot: uint64_t | Membuf;
  data: uint64_t | number | Membuf;
}

const vkSetPrivateDataParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"objectType":{"simple":"int32_t","isPointer":false},"objectHandle":{"simple":"uint64_t","isPointer":false},"privateDataSlot":{"simple":"uint64_t","isPointer":false},"data":{"simple":"uint64_t","isPointer":false}} as const;
export const vkSetPrivateData = (input: vkSetPrivateDataInputWithDevice | vkSetPrivateDataInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkSetPrivateDataParamsTypes[e[0] as keyof typeof vkSetPrivateDataParamsTypes])];
    }));
    const result = vsnative.vts_native_vkSetPrivateData(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPrivateDataInputWithDevice {
  device: uint64_t | Membuf;
  objectType: int32_t | number | Membuf;
  objectHandle: uint64_t | number | Membuf;
  privateDataSlot: uint64_t | Membuf;
  pData: uint64_t| null | Membuf;
}
export interface vkGetPrivateDataInputWithInstance {
  device: uint64_t | Membuf;
  objectType: int32_t | number | Membuf;
  objectHandle: uint64_t | number | Membuf;
  privateDataSlot: uint64_t | Membuf;
  pData: uint64_t| null | Membuf;
}

const vkGetPrivateDataParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"objectType":{"simple":"int32_t","isPointer":false},"objectHandle":{"simple":"uint64_t","isPointer":false},"privateDataSlot":{"simple":"uint64_t","isPointer":false},"pData":{"simple":"uint64_t","isPointer":true}} as const;
export const vkGetPrivateData = (input: vkGetPrivateDataInputWithDevice | vkGetPrivateDataInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPrivateDataParamsTypes[e[0] as keyof typeof vkGetPrivateDataParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPrivateData(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdCopyBuffer2InputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pCopyBufferInfo: VkCopyBufferInfo2| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdCopyBuffer2InputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pCopyBufferInfo: VkCopyBufferInfo2| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdCopyBuffer2ParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pCopyBufferInfo":{"simple":"VkCopyBufferInfo2","isPointer":true}} as const;
export const vkCmdCopyBuffer2 = (input: vkCmdCopyBuffer2InputWithDevice | vkCmdCopyBuffer2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdCopyBuffer2ParamsTypes[e[0] as keyof typeof vkCmdCopyBuffer2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdCopyBuffer2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdCopyImage2InputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pCopyImageInfo: VkCopyImageInfo2| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdCopyImage2InputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pCopyImageInfo: VkCopyImageInfo2| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdCopyImage2ParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pCopyImageInfo":{"simple":"VkCopyImageInfo2","isPointer":true}} as const;
export const vkCmdCopyImage2 = (input: vkCmdCopyImage2InputWithDevice | vkCmdCopyImage2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdCopyImage2ParamsTypes[e[0] as keyof typeof vkCmdCopyImage2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdCopyImage2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdBlitImage2InputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pBlitImageInfo: VkBlitImageInfo2| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdBlitImage2InputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pBlitImageInfo: VkBlitImageInfo2| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdBlitImage2ParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pBlitImageInfo":{"simple":"VkBlitImageInfo2","isPointer":true}} as const;
export const vkCmdBlitImage2 = (input: vkCmdBlitImage2InputWithDevice | vkCmdBlitImage2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdBlitImage2ParamsTypes[e[0] as keyof typeof vkCmdBlitImage2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdBlitImage2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdCopyBufferToImage2InputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pCopyBufferToImageInfo: VkCopyBufferToImageInfo2| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdCopyBufferToImage2InputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pCopyBufferToImageInfo: VkCopyBufferToImageInfo2| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdCopyBufferToImage2ParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pCopyBufferToImageInfo":{"simple":"VkCopyBufferToImageInfo2","isPointer":true}} as const;
export const vkCmdCopyBufferToImage2 = (input: vkCmdCopyBufferToImage2InputWithDevice | vkCmdCopyBufferToImage2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdCopyBufferToImage2ParamsTypes[e[0] as keyof typeof vkCmdCopyBufferToImage2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdCopyBufferToImage2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdCopyImageToBuffer2InputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pCopyImageToBufferInfo: VkCopyImageToBufferInfo2| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdCopyImageToBuffer2InputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pCopyImageToBufferInfo: VkCopyImageToBufferInfo2| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdCopyImageToBuffer2ParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pCopyImageToBufferInfo":{"simple":"VkCopyImageToBufferInfo2","isPointer":true}} as const;
export const vkCmdCopyImageToBuffer2 = (input: vkCmdCopyImageToBuffer2InputWithDevice | vkCmdCopyImageToBuffer2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdCopyImageToBuffer2ParamsTypes[e[0] as keyof typeof vkCmdCopyImageToBuffer2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdCopyImageToBuffer2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdResolveImage2InputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pResolveImageInfo: VkResolveImageInfo2| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdResolveImage2InputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pResolveImageInfo: VkResolveImageInfo2| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdResolveImage2ParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pResolveImageInfo":{"simple":"VkResolveImageInfo2","isPointer":true}} as const;
export const vkCmdResolveImage2 = (input: vkCmdResolveImage2InputWithDevice | vkCmdResolveImage2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdResolveImage2ParamsTypes[e[0] as keyof typeof vkCmdResolveImage2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdResolveImage2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetFragmentShadingRateKHRInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pFragmentSize: VkExtent2D| null | Membuf;
  combinerOps: int32_t[] | null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetFragmentShadingRateKHRInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pFragmentSize: VkExtent2D| null | Membuf;
  combinerOps: int32_t[] | null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetFragmentShadingRateKHRParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pFragmentSize":{"simple":"VkExtent2D","isPointer":true},"combinerOps":{"simple":"int32_t","isPointer":false}} as const;
export const vkCmdSetFragmentShadingRateKHR = (input: vkCmdSetFragmentShadingRateKHRInputWithDevice | vkCmdSetFragmentShadingRateKHRInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetFragmentShadingRateKHRParamsTypes[e[0] as keyof typeof vkCmdSetFragmentShadingRateKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetFragmentShadingRateKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceFragmentShadingRatesKHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pFragmentShadingRateCount: uint32_t| null | Membuf;
  pFragmentShadingRates?: VkPhysicalDeviceFragmentShadingRateKHR[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceFragmentShadingRatesKHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pFragmentShadingRateCount: uint32_t| null | Membuf;
  pFragmentShadingRates?: VkPhysicalDeviceFragmentShadingRateKHR[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceFragmentShadingRatesKHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pFragmentShadingRateCount":{"simple":"uint32_t","isPointer":true},"pFragmentShadingRates":{"simple":"VkPhysicalDeviceFragmentShadingRateKHR","isPointer":true}} as const;
export const vkGetPhysicalDeviceFragmentShadingRatesKHR = (input: vkGetPhysicalDeviceFragmentShadingRatesKHRInputWithDevice | vkGetPhysicalDeviceFragmentShadingRatesKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceFragmentShadingRatesKHRParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceFragmentShadingRatesKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceFragmentShadingRatesKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdSetEvent2InputWithDevice {
  commandBuffer: uint64_t | Membuf;
  event: uint64_t | Membuf;
  pDependencyInfo: VkDependencyInfo| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdSetEvent2InputWithInstance {
  commandBuffer: uint64_t | Membuf;
  event: uint64_t | Membuf;
  pDependencyInfo: VkDependencyInfo| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdSetEvent2ParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"event":{"simple":"uint64_t","isPointer":false},"pDependencyInfo":{"simple":"VkDependencyInfo","isPointer":true}} as const;
export const vkCmdSetEvent2 = (input: vkCmdSetEvent2InputWithDevice | vkCmdSetEvent2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdSetEvent2ParamsTypes[e[0] as keyof typeof vkCmdSetEvent2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdSetEvent2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdResetEvent2InputWithDevice {
  commandBuffer: uint64_t | Membuf;
  event: uint64_t | Membuf;
  stageMask: uint64_t | nullptr_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdResetEvent2InputWithInstance {
  commandBuffer: uint64_t | Membuf;
  event: uint64_t | Membuf;
  stageMask: uint64_t | nullptr_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdResetEvent2ParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"event":{"simple":"uint64_t","isPointer":false},"stageMask":{"simple":"uint64_t","isPointer":false}} as const;
export const vkCmdResetEvent2 = (input: vkCmdResetEvent2InputWithDevice | vkCmdResetEvent2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdResetEvent2ParamsTypes[e[0] as keyof typeof vkCmdResetEvent2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdResetEvent2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdWaitEvents2InputWithDevice {
  commandBuffer: uint64_t | Membuf;
  eventCount: uint32_t | number | Membuf;
  pEvents: uint64_t[] | null | Membuf[] | Membuf;
  pDependencyInfos: VkDependencyInfo[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdWaitEvents2InputWithInstance {
  commandBuffer: uint64_t | Membuf;
  eventCount: uint32_t | number | Membuf;
  pEvents: uint64_t[] | null | Membuf[] | Membuf;
  pDependencyInfos: VkDependencyInfo[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdWaitEvents2ParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"eventCount":{"simple":"uint32_t","isPointer":false},"pEvents":{"simple":"uint64_t","isPointer":true},"pDependencyInfos":{"simple":"VkDependencyInfo","isPointer":true}} as const;
export const vkCmdWaitEvents2 = (input: vkCmdWaitEvents2InputWithDevice | vkCmdWaitEvents2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdWaitEvents2ParamsTypes[e[0] as keyof typeof vkCmdWaitEvents2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdWaitEvents2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdPipelineBarrier2InputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pDependencyInfo: VkDependencyInfo| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdPipelineBarrier2InputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pDependencyInfo: VkDependencyInfo| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdPipelineBarrier2ParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pDependencyInfo":{"simple":"VkDependencyInfo","isPointer":true}} as const;
export const vkCmdPipelineBarrier2 = (input: vkCmdPipelineBarrier2InputWithDevice | vkCmdPipelineBarrier2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdPipelineBarrier2ParamsTypes[e[0] as keyof typeof vkCmdPipelineBarrier2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdPipelineBarrier2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkQueueSubmit2InputWithDevice {
  queue: uint64_t | Membuf;
  submitCount: uint32_t | nullptr_t | number | Membuf;
  pSubmits: VkSubmitInfo2[] | null | Membuf[] | Membuf;
  fence: uint64_t | nullptr_t | Membuf;
  device: uint64_t | Membuf;
}
export interface vkQueueSubmit2InputWithInstance {
  queue: uint64_t | Membuf;
  submitCount: uint32_t | nullptr_t | number | Membuf;
  pSubmits: VkSubmitInfo2[] | null | Membuf[] | Membuf;
  fence: uint64_t | nullptr_t | Membuf;
  instance: uint64_t | Membuf;
}

const vkQueueSubmit2ParamsTypes = {"queue":{"simple":"uint64_t","isPointer":false},"submitCount":{"simple":"uint32_t","isPointer":false},"pSubmits":{"simple":"VkSubmitInfo2","isPointer":true},"fence":{"simple":"uint64_t","isPointer":false}} as const;
export const vkQueueSubmit2 = (input: vkQueueSubmit2InputWithDevice | vkQueueSubmit2InputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_DEVICE_LOST => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkQueueSubmit2ParamsTypes[e[0] as keyof typeof vkQueueSubmit2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkQueueSubmit2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdWriteTimestamp2InputWithDevice {
  commandBuffer: uint64_t | Membuf;
  stage: uint64_t | nullptr_t | number | Membuf;
  queryPool: uint64_t | Membuf;
  query: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdWriteTimestamp2InputWithInstance {
  commandBuffer: uint64_t | Membuf;
  stage: uint64_t | nullptr_t | number | Membuf;
  queryPool: uint64_t | Membuf;
  query: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdWriteTimestamp2ParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"stage":{"simple":"uint64_t","isPointer":false},"queryPool":{"simple":"uint64_t","isPointer":false},"query":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdWriteTimestamp2 = (input: vkCmdWriteTimestamp2InputWithDevice | vkCmdWriteTimestamp2InputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdWriteTimestamp2ParamsTypes[e[0] as keyof typeof vkCmdWriteTimestamp2ParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdWriteTimestamp2(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdWriteBufferMarker2AMDInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  stage: uint64_t | nullptr_t | number | Membuf;
  dstBuffer: uint64_t | Membuf;
  dstOffset: uint64_t | number | Membuf;
  marker: uint32_t | number | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdWriteBufferMarker2AMDInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  stage: uint64_t | nullptr_t | number | Membuf;
  dstBuffer: uint64_t | Membuf;
  dstOffset: uint64_t | number | Membuf;
  marker: uint32_t | number | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdWriteBufferMarker2AMDParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"stage":{"simple":"uint64_t","isPointer":false},"dstBuffer":{"simple":"uint64_t","isPointer":false},"dstOffset":{"simple":"uint64_t","isPointer":false},"marker":{"simple":"uint32_t","isPointer":false}} as const;
export const vkCmdWriteBufferMarker2AMD = (input: vkCmdWriteBufferMarker2AMDInputWithDevice | vkCmdWriteBufferMarker2AMDInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdWriteBufferMarker2AMDParamsTypes[e[0] as keyof typeof vkCmdWriteBufferMarker2AMDParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdWriteBufferMarker2AMD(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetQueueCheckpointData2NVInputWithDevice {
  queue: uint64_t | Membuf;
  pCheckpointDataCount: uint32_t| null | Membuf;
  pCheckpointData?: VkCheckpointData2NV[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetQueueCheckpointData2NVInputWithInstance {
  queue: uint64_t | Membuf;
  pCheckpointDataCount: uint32_t| null | Membuf;
  pCheckpointData?: VkCheckpointData2NV[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetQueueCheckpointData2NVParamsTypes = {"queue":{"simple":"uint64_t","isPointer":false},"pCheckpointDataCount":{"simple":"uint32_t","isPointer":true},"pCheckpointData":{"simple":"VkCheckpointData2NV","isPointer":true}} as const;
export const vkGetQueueCheckpointData2NV = (input: vkGetQueueCheckpointData2NVInputWithDevice | vkGetQueueCheckpointData2NVInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetQueueCheckpointData2NVParamsTypes[e[0] as keyof typeof vkGetQueueCheckpointData2NVParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetQueueCheckpointData2NV(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceVideoCapabilitiesKHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pVideoProfile: VkVideoProfileInfoKHR| null | Membuf;
  pCapabilities: VkVideoCapabilitiesKHR| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceVideoCapabilitiesKHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pVideoProfile: VkVideoProfileInfoKHR| null | Membuf;
  pCapabilities: VkVideoCapabilitiesKHR| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceVideoCapabilitiesKHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pVideoProfile":{"simple":"VkVideoProfileInfoKHR","isPointer":true},"pCapabilities":{"simple":"VkVideoCapabilitiesKHR","isPointer":true}} as const;
export const vkGetPhysicalDeviceVideoCapabilitiesKHR = (input: vkGetPhysicalDeviceVideoCapabilitiesKHRInputWithDevice | vkGetPhysicalDeviceVideoCapabilitiesKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR | VkResult.VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR | VkResult.VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR | VkResult.VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceVideoCapabilitiesKHRParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceVideoCapabilitiesKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceVideoCapabilitiesKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPhysicalDeviceVideoFormatPropertiesKHRInputWithDevice {
  physicalDevice: uint64_t | Membuf;
  pVideoFormatInfo: VkPhysicalDeviceVideoFormatInfoKHR| null | Membuf;
  pVideoFormatPropertyCount: uint32_t| null | Membuf;
  pVideoFormatProperties?: VkVideoFormatPropertiesKHR[] | null | Membuf[] | Membuf;
  device: uint64_t | Membuf;
}
export interface vkGetPhysicalDeviceVideoFormatPropertiesKHRInputWithInstance {
  physicalDevice: uint64_t | Membuf;
  pVideoFormatInfo: VkPhysicalDeviceVideoFormatInfoKHR| null | Membuf;
  pVideoFormatPropertyCount: uint32_t| null | Membuf;
  pVideoFormatProperties?: VkVideoFormatPropertiesKHR[] | null | Membuf[] | Membuf;
  instance: uint64_t | Membuf;
}

const vkGetPhysicalDeviceVideoFormatPropertiesKHRParamsTypes = {"physicalDevice":{"simple":"uint64_t","isPointer":false},"pVideoFormatInfo":{"simple":"VkPhysicalDeviceVideoFormatInfoKHR","isPointer":true},"pVideoFormatPropertyCount":{"simple":"uint32_t","isPointer":true},"pVideoFormatProperties":{"simple":"VkVideoFormatPropertiesKHR","isPointer":true}} as const;
export const vkGetPhysicalDeviceVideoFormatPropertiesKHR = (input: vkGetPhysicalDeviceVideoFormatPropertiesKHRInputWithDevice | vkGetPhysicalDeviceVideoFormatPropertiesKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR | VkResult.VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR | VkResult.VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR | VkResult.VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR | VkResult.VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPhysicalDeviceVideoFormatPropertiesKHRParamsTypes[e[0] as keyof typeof vkGetPhysicalDeviceVideoFormatPropertiesKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPhysicalDeviceVideoFormatPropertiesKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateVideoSessionKHRInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkVideoSessionCreateInfoKHR| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pVideoSession: uint64_t| null | Membuf;
}
export interface vkCreateVideoSessionKHRInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkVideoSessionCreateInfoKHR| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pVideoSession: uint64_t| null | Membuf;
}

const vkCreateVideoSessionKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkVideoSessionCreateInfoKHR","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pVideoSession":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateVideoSessionKHR = (input: vkCreateVideoSessionKHRInputWithDevice | vkCreateVideoSessionKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_INITIALIZATION_FAILED | VkResult.VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR | VkResult.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateVideoSessionKHRParamsTypes[e[0] as keyof typeof vkCreateVideoSessionKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateVideoSessionKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyVideoSessionKHRInputWithDevice {
  device: uint64_t | Membuf;
  videoSession: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyVideoSessionKHRInputWithInstance {
  device: uint64_t | Membuf;
  videoSession: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyVideoSessionKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"videoSession":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyVideoSessionKHR = (input: vkDestroyVideoSessionKHRInputWithDevice | vkDestroyVideoSessionKHRInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyVideoSessionKHRParamsTypes[e[0] as keyof typeof vkDestroyVideoSessionKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyVideoSessionKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCreateVideoSessionParametersKHRInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkVideoSessionParametersCreateInfoKHR| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pVideoSessionParameters: uint64_t| null | Membuf;
}
export interface vkCreateVideoSessionParametersKHRInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkVideoSessionParametersCreateInfoKHR| null | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
  pVideoSessionParameters: uint64_t| null | Membuf;
}

const vkCreateVideoSessionParametersKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkVideoSessionParametersCreateInfoKHR","isPointer":true},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true},"pVideoSessionParameters":{"simple":"uint64_t","isPointer":true}} as const;
export const vkCreateVideoSessionParametersKHR = (input: vkCreateVideoSessionParametersKHRInputWithDevice | vkCreateVideoSessionParametersKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_INITIALIZATION_FAILED | VkResult.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCreateVideoSessionParametersKHRParamsTypes[e[0] as keyof typeof vkCreateVideoSessionParametersKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCreateVideoSessionParametersKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkUpdateVideoSessionParametersKHRInputWithDevice {
  device: uint64_t | Membuf;
  videoSessionParameters: uint64_t | Membuf;
  pUpdateInfo: VkVideoSessionParametersUpdateInfoKHR| null | Membuf;
}
export interface vkUpdateVideoSessionParametersKHRInputWithInstance {
  device: uint64_t | Membuf;
  videoSessionParameters: uint64_t | Membuf;
  pUpdateInfo: VkVideoSessionParametersUpdateInfoKHR| null | Membuf;
}

const vkUpdateVideoSessionParametersKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"videoSessionParameters":{"simple":"uint64_t","isPointer":false},"pUpdateInfo":{"simple":"VkVideoSessionParametersUpdateInfoKHR","isPointer":true}} as const;
export const vkUpdateVideoSessionParametersKHR = (input: vkUpdateVideoSessionParametersKHRInputWithDevice | vkUpdateVideoSessionParametersKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkUpdateVideoSessionParametersKHRParamsTypes[e[0] as keyof typeof vkUpdateVideoSessionParametersKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkUpdateVideoSessionParametersKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkDestroyVideoSessionParametersKHRInputWithDevice {
  device: uint64_t | Membuf;
  videoSessionParameters: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}
export interface vkDestroyVideoSessionParametersKHRInputWithInstance {
  device: uint64_t | Membuf;
  videoSessionParameters: uint64_t | nullptr_t | Membuf;
  pAllocator?: VkAllocationCallbacks| null | Membuf;
}

const vkDestroyVideoSessionParametersKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"videoSessionParameters":{"simple":"uint64_t","isPointer":false},"pAllocator":{"simple":"VkAllocationCallbacks","isPointer":true}} as const;
export const vkDestroyVideoSessionParametersKHR = (input: vkDestroyVideoSessionParametersKHRInputWithDevice | vkDestroyVideoSessionParametersKHRInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkDestroyVideoSessionParametersKHRParamsTypes[e[0] as keyof typeof vkDestroyVideoSessionParametersKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkDestroyVideoSessionParametersKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetVideoSessionMemoryRequirementsKHRInputWithDevice {
  device: uint64_t | Membuf;
  videoSession: uint64_t | Membuf;
  pMemoryRequirementsCount: uint32_t| null | Membuf;
  pMemoryRequirements?: VkVideoSessionMemoryRequirementsKHR[] | null | Membuf[] | Membuf;
}
export interface vkGetVideoSessionMemoryRequirementsKHRInputWithInstance {
  device: uint64_t | Membuf;
  videoSession: uint64_t | Membuf;
  pMemoryRequirementsCount: uint32_t| null | Membuf;
  pMemoryRequirements?: VkVideoSessionMemoryRequirementsKHR[] | null | Membuf[] | Membuf;
}

const vkGetVideoSessionMemoryRequirementsKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"videoSession":{"simple":"uint64_t","isPointer":false},"pMemoryRequirementsCount":{"simple":"uint32_t","isPointer":true},"pMemoryRequirements":{"simple":"VkVideoSessionMemoryRequirementsKHR","isPointer":true}} as const;
export const vkGetVideoSessionMemoryRequirementsKHR = (input: vkGetVideoSessionMemoryRequirementsKHRInputWithDevice | vkGetVideoSessionMemoryRequirementsKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_INCOMPLETE => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetVideoSessionMemoryRequirementsKHRParamsTypes[e[0] as keyof typeof vkGetVideoSessionMemoryRequirementsKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetVideoSessionMemoryRequirementsKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkBindVideoSessionMemoryKHRInputWithDevice {
  device: uint64_t | Membuf;
  videoSession: uint64_t | Membuf;
  bindSessionMemoryInfoCount: uint32_t | number | Membuf;
  pBindSessionMemoryInfos: VkBindVideoSessionMemoryInfoKHR[] | null | Membuf[] | Membuf;
}
export interface vkBindVideoSessionMemoryKHRInputWithInstance {
  device: uint64_t | Membuf;
  videoSession: uint64_t | Membuf;
  bindSessionMemoryInfoCount: uint32_t | number | Membuf;
  pBindSessionMemoryInfos: VkBindVideoSessionMemoryInfoKHR[] | null | Membuf[] | Membuf;
}

const vkBindVideoSessionMemoryKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"videoSession":{"simple":"uint64_t","isPointer":false},"bindSessionMemoryInfoCount":{"simple":"uint32_t","isPointer":false},"pBindSessionMemoryInfos":{"simple":"VkBindVideoSessionMemoryInfoKHR","isPointer":true}} as const;
export const vkBindVideoSessionMemoryKHR = (input: vkBindVideoSessionMemoryKHRInputWithDevice | vkBindVideoSessionMemoryKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkBindVideoSessionMemoryKHRParamsTypes[e[0] as keyof typeof vkBindVideoSessionMemoryKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkBindVideoSessionMemoryKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdBeginVideoCodingKHRInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pBeginInfo: VkVideoBeginCodingInfoKHR| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdBeginVideoCodingKHRInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pBeginInfo: VkVideoBeginCodingInfoKHR| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdBeginVideoCodingKHRParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pBeginInfo":{"simple":"VkVideoBeginCodingInfoKHR","isPointer":true}} as const;
export const vkCmdBeginVideoCodingKHR = (input: vkCmdBeginVideoCodingKHRInputWithDevice | vkCmdBeginVideoCodingKHRInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdBeginVideoCodingKHRParamsTypes[e[0] as keyof typeof vkCmdBeginVideoCodingKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdBeginVideoCodingKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdControlVideoCodingKHRInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pCodingControlInfo: VkVideoCodingControlInfoKHR| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdControlVideoCodingKHRInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pCodingControlInfo: VkVideoCodingControlInfoKHR| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdControlVideoCodingKHRParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pCodingControlInfo":{"simple":"VkVideoCodingControlInfoKHR","isPointer":true}} as const;
export const vkCmdControlVideoCodingKHR = (input: vkCmdControlVideoCodingKHRInputWithDevice | vkCmdControlVideoCodingKHRInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdControlVideoCodingKHRParamsTypes[e[0] as keyof typeof vkCmdControlVideoCodingKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdControlVideoCodingKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdEndVideoCodingKHRInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pEndCodingInfo: VkVideoEndCodingInfoKHR| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdEndVideoCodingKHRInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pEndCodingInfo: VkVideoEndCodingInfoKHR| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdEndVideoCodingKHRParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pEndCodingInfo":{"simple":"VkVideoEndCodingInfoKHR","isPointer":true}} as const;
export const vkCmdEndVideoCodingKHR = (input: vkCmdEndVideoCodingKHRInputWithDevice | vkCmdEndVideoCodingKHRInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdEndVideoCodingKHRParamsTypes[e[0] as keyof typeof vkCmdEndVideoCodingKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdEndVideoCodingKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkSetDeviceMemoryPriorityEXTInputWithDevice {
  device: uint64_t | Membuf;
  memory: uint64_t | Membuf;
  priority: float | number | Membuf;
}
export interface vkSetDeviceMemoryPriorityEXTInputWithInstance {
  device: uint64_t | Membuf;
  memory: uint64_t | Membuf;
  priority: float | number | Membuf;
}

const vkSetDeviceMemoryPriorityEXTParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"memory":{"simple":"uint64_t","isPointer":false},"priority":{"simple":"float","isPointer":false}} as const;
export const vkSetDeviceMemoryPriorityEXT = (input: vkSetDeviceMemoryPriorityEXTInputWithDevice | vkSetDeviceMemoryPriorityEXTInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkSetDeviceMemoryPriorityEXTParamsTypes[e[0] as keyof typeof vkSetDeviceMemoryPriorityEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkSetDeviceMemoryPriorityEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkWaitForPresentKHRInputWithDevice {
  device: uint64_t | Membuf;
  swapchain: uint64_t | Membuf;
  presentId: uint64_t | number | Membuf;
  timeout: uint64_t | number | Membuf;
}
export interface vkWaitForPresentKHRInputWithInstance {
  device: uint64_t | Membuf;
  swapchain: uint64_t | Membuf;
  presentId: uint64_t | number | Membuf;
  timeout: uint64_t | number | Membuf;
}

const vkWaitForPresentKHRParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"swapchain":{"simple":"uint64_t","isPointer":false},"presentId":{"simple":"uint64_t","isPointer":false},"timeout":{"simple":"uint64_t","isPointer":false}} as const;
export const vkWaitForPresentKHR = (input: vkWaitForPresentKHRInputWithDevice | vkWaitForPresentKHRInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_TIMEOUT | VkResult.VK_SUBOPTIMAL_KHR | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY | VkResult.VK_ERROR_OUT_OF_DEVICE_MEMORY | VkResult.VK_ERROR_DEVICE_LOST | VkResult.VK_ERROR_OUT_OF_DATE_KHR | VkResult.VK_ERROR_SURFACE_LOST_KHR | VkResult.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkWaitForPresentKHRParamsTypes[e[0] as keyof typeof vkWaitForPresentKHRParamsTypes])];
    }));
    const result = vsnative.vts_native_vkWaitForPresentKHR(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdBeginRenderingInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  pRenderingInfo: VkRenderingInfo| null | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdBeginRenderingInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  pRenderingInfo: VkRenderingInfo| null | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdBeginRenderingParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false},"pRenderingInfo":{"simple":"VkRenderingInfo","isPointer":true}} as const;
export const vkCmdBeginRendering = (input: vkCmdBeginRenderingInputWithDevice | vkCmdBeginRenderingInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdBeginRenderingParamsTypes[e[0] as keyof typeof vkCmdBeginRenderingParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdBeginRendering(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkCmdEndRenderingInputWithDevice {
  commandBuffer: uint64_t | Membuf;
  device: uint64_t | Membuf;
}
export interface vkCmdEndRenderingInputWithInstance {
  commandBuffer: uint64_t | Membuf;
  instance: uint64_t | Membuf;
}

const vkCmdEndRenderingParamsTypes = {"commandBuffer":{"simple":"uint64_t","isPointer":false}} as const;
export const vkCmdEndRendering = (input: vkCmdEndRenderingInputWithDevice | vkCmdEndRenderingInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkCmdEndRenderingParamsTypes[e[0] as keyof typeof vkCmdEndRenderingParamsTypes])];
    }));
    const result = vsnative.vts_native_vkCmdEndRendering(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetShaderModuleIdentifierEXTInputWithDevice {
  device: uint64_t | Membuf;
  shaderModule: uint64_t | Membuf;
  pIdentifier: VkShaderModuleIdentifierEXT| null | Membuf;
}
export interface vkGetShaderModuleIdentifierEXTInputWithInstance {
  device: uint64_t | Membuf;
  shaderModule: uint64_t | Membuf;
  pIdentifier: VkShaderModuleIdentifierEXT| null | Membuf;
}

const vkGetShaderModuleIdentifierEXTParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"shaderModule":{"simple":"uint64_t","isPointer":false},"pIdentifier":{"simple":"VkShaderModuleIdentifierEXT","isPointer":true}} as const;
export const vkGetShaderModuleIdentifierEXT = (input: vkGetShaderModuleIdentifierEXTInputWithDevice | vkGetShaderModuleIdentifierEXTInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetShaderModuleIdentifierEXTParamsTypes[e[0] as keyof typeof vkGetShaderModuleIdentifierEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetShaderModuleIdentifierEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetShaderModuleCreateInfoIdentifierEXTInputWithDevice {
  device: uint64_t | Membuf;
  pCreateInfo: VkShaderModuleCreateInfo| null | Membuf;
  pIdentifier: VkShaderModuleIdentifierEXT| null | Membuf;
}
export interface vkGetShaderModuleCreateInfoIdentifierEXTInputWithInstance {
  device: uint64_t | Membuf;
  pCreateInfo: VkShaderModuleCreateInfo| null | Membuf;
  pIdentifier: VkShaderModuleIdentifierEXT| null | Membuf;
}

const vkGetShaderModuleCreateInfoIdentifierEXTParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pCreateInfo":{"simple":"VkShaderModuleCreateInfo","isPointer":true},"pIdentifier":{"simple":"VkShaderModuleIdentifierEXT","isPointer":true}} as const;
export const vkGetShaderModuleCreateInfoIdentifierEXT = (input: vkGetShaderModuleCreateInfoIdentifierEXTInputWithDevice | vkGetShaderModuleCreateInfoIdentifierEXTInputWithInstance): void => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetShaderModuleCreateInfoIdentifierEXTParamsTypes[e[0] as keyof typeof vkGetShaderModuleCreateInfoIdentifierEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetShaderModuleCreateInfoIdentifierEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkGetPipelinePropertiesEXTInputWithDevice {
  device: uint64_t | Membuf;
  pPipelineInfo: VkPipelineInfoEXT| null | Membuf;
  pPipelineProperties: VkBaseOutStructure| null | Membuf;
}
export interface vkGetPipelinePropertiesEXTInputWithInstance {
  device: uint64_t | Membuf;
  pPipelineInfo: VkPipelineInfoEXT| null | Membuf;
  pPipelineProperties: VkBaseOutStructure| null | Membuf;
}

const vkGetPipelinePropertiesEXTParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pPipelineInfo":{"simple":"VkPipelineInfoEXT","isPointer":true},"pPipelineProperties":{"simple":"VkBaseOutStructure","isPointer":true}} as const;
export const vkGetPipelinePropertiesEXT = (input: vkGetPipelinePropertiesEXTInputWithDevice | vkGetPipelinePropertiesEXTInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_OUT_OF_HOST_MEMORY => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkGetPipelinePropertiesEXTParamsTypes[e[0] as keyof typeof vkGetPipelinePropertiesEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkGetPipelinePropertiesEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
export interface vkReleaseSwapchainImagesEXTInputWithDevice {
  device: uint64_t | Membuf;
  pReleaseInfo: VkReleaseSwapchainImagesInfoEXT| null | Membuf;
}
export interface vkReleaseSwapchainImagesEXTInputWithInstance {
  device: uint64_t | Membuf;
  pReleaseInfo: VkReleaseSwapchainImagesInfoEXT| null | Membuf;
}

const vkReleaseSwapchainImagesEXTParamsTypes = {"device":{"simple":"uint64_t","isPointer":false},"pReleaseInfo":{"simple":"VkReleaseSwapchainImagesInfoEXT","isPointer":true}} as const;
export const vkReleaseSwapchainImagesEXT = (input: vkReleaseSwapchainImagesEXTInputWithDevice | vkReleaseSwapchainImagesEXTInputWithInstance): VkResult.VK_SUCCESS | VkResult.VK_ERROR_SURFACE_LOST_KHR => {
   // const lastAllocationId = getMembufScratchBuffer().lastAllocationId;
    const transformed = Object.fromEntries(Object.entries(input).map((e) => {
        return [e[0], transformParameter(e[1], vkReleaseSwapchainImagesEXTParamsTypes[e[0] as keyof typeof vkReleaseSwapchainImagesEXTParamsTypes])];
    }));
    const result = vsnative.vts_native_vkReleaseSwapchainImagesEXT(transformed);
    //getMembufScratchBuffer().revertToAllocationId(lastAllocationId);
    return result;
}
